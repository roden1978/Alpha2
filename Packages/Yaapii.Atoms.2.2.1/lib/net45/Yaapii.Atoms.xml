<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Yaapii.Atoms</name>
    </assembly>
    <members>
        <member name="T:Yaapii.Atoms.Bytes.Base64Bytes">
            <summary>
            Origin bytes decoded using the Base64 encoding scheme.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.Base64Bytes.#ctor(Yaapii.Atoms.IBytes)">
            <summary>
            Origin bytes decoded using the Base64 encoding scheme.
            </summary>
            <param name="bytes">origin bytes</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.Base64Bytes.AsBytes">
            <summary>
            The 
            </summary>
            <returns></returns>
        </member>
        <member name="T:Yaapii.Atoms.Bytes.BytesAsInput">
            <summary>
            Bytes as input.
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Bytes.BytesAsInput.source">
            <summary>
            the source
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesAsInput.#ctor(Yaapii.Atoms.IText)">
            <summary>
            Bytes as input.
            </summary>
            <param name="text">a text</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesAsInput.#ctor(System.String)">
            <summary>
            Bytes as input.
            </summary>
            <param name="text">a string</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesAsInput.#ctor(System.Byte[])">
            <summary>
            Bytes as input.
            </summary>
            <param name="bytes">byte array</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesAsInput.#ctor(Yaapii.Atoms.IBytes)">
            <summary>
            Bytes as input.
            </summary>
            <param name="bytes">bytes</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesAsInput.Stream">
            <summary>
            Get the stream.
            </summary>
            <returns>the stream</returns>
        </member>
        <member name="T:Yaapii.Atoms.Bytes.BytesBase64">
            <summary>
            Encodes all origin bytes using the Base64 encoding scheme.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesBase64.#ctor(Yaapii.Atoms.IBytes)">
            <summary>
            Encoded origin bytes using the Base64 encoding scheme.
            </summary>
            <param name="bytes"></param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesBase64.AsBytes">
            <summary>
            The bytes encoded as Base64
            </summary>
            <returns></returns>
        </member>
        <member name="T:Yaapii.Atoms.Bytes.BytesEqual">
            <summary>
            Equality for <see cref="T:Yaapii.Atoms.IBytes"/>
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesEqual.#ctor(Yaapii.Atoms.IBytes,Yaapii.Atoms.IBytes)">
            <summary>
            Makes a truth about <see cref="T:Yaapii.Atoms.IBytes"/> are equal or not.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesEqual.Value">
            <summary>
            Equal or not
            </summary>
            <returns></returns>
        </member>
        <member name="T:Yaapii.Atoms.Bytes.BytesOf">
            <summary>
            Bytes out of other objects.
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Bytes.BytesOf.origin">
            <summary>
            original
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesOf.#ctor(Yaapii.Atoms.IInput)">
            <summary>
            Bytes out of a input.
            </summary>
            <param name="input">the input</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesOf.#ctor(Yaapii.Atoms.IInput,System.Int32)">
            <summary>
            Bytes out of a input.
            </summary>
            <param name="input">the input</param>
            <param name="max">max buffer size</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesOf.#ctor(System.Text.StringBuilder)">
            <summary>
            Bytes out of a StringBuilder.
            </summary>
            <param name="builder">stringbuilder</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesOf.#ctor(System.Text.StringBuilder,System.Text.Encoding)">
            <summary>
            Bytes out of a StringBuilder.
            </summary>
            <param name="builder">stringbuilder</param>
            <param name="enc">encoding of stringbuilder</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesOf.#ctor(System.IO.StringReader)">
            <summary>
            Bytes out of a StringReader.
            </summary>
            <param name="rdr">stringreader</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesOf.#ctor(System.IO.StreamReader)">
            <summary>
            Bytes out of a StreamReader.
            </summary>
            <param name="rdr">streamreader</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesOf.#ctor(System.IO.StreamReader,System.Text.Encoding,System.Int32)">
            <summary>
            Bytes out of a StreamReader.
            </summary>
            <param name="rdr">the reader</param>
            <param name="enc">encoding of the reader</param>
            <param name="max">max buffer size of the reader</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesOf.#ctor(System.Collections.Generic.IEnumerable{System.Char})">
            <summary>
            Bytes out of a list of chars.
            </summary>
            <param name="chars">enumerable of bytes</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesOf.#ctor(System.Collections.Generic.IEnumerable{System.Char},System.Text.Encoding)">
            <summary>
            Bytes out of a list of chars.
            </summary>
            <param name="chars">enumerable of chars</param>
            <param name="enc">encoding of chars</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesOf.#ctor(System.Char[])">
            <summary>
            Bytes out of a char array.
            </summary>
            <param name="chars">array of chars</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesOf.#ctor(System.Char[],System.Text.Encoding)">
            <summary>
            Bytes out of a char array.
            </summary>
            <param name="chars">an array of chars</param>
            <param name="encoding">encoding of chars</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesOf.#ctor(System.String)">
            <summary>
            Bytes out of a string.
            </summary>
            <param name="source">a string</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesOf.#ctor(System.String,System.Text.Encoding)">
            <summary>
            Bytes out of a string.
            </summary>
            <param name="source">a string</param>
            <param name="encoding">encoding of the string</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesOf.#ctor(Yaapii.Atoms.IText)">
            <summary>
            Bytes out of Text.
            </summary>
            <param name="text">a text</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesOf.#ctor(Yaapii.Atoms.IText,System.Text.Encoding)">
            <summary>
            Bytes out of Text.
            </summary>
            <param name="text">a text</param>
            <param name="encoding">encoding of the string</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesOf.#ctor(System.Exception)">
            <summary>
            Bytes out of Exception object.
            </summary>
            <param name="error">exception to serialize</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesOf.#ctor(Yaapii.Atoms.IBytes)">
            <summary>
            Bytes out of IBytes object.
            </summary>
            <param name="bytes">bytes</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesOf.#ctor(System.Func{System.Byte[]})">
            <summary>
            Bytes out of function which returns a byte array.
            </summary>
            <param name="bytes">byte aray</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesOf.#ctor(System.Byte[])">
            <summary>
            Bytes out of byte array.
            </summary>
            <param name="bytes">byte aray</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesOf.#ctor(System.Int32)">
            <summary>
            Bytes out of an int.
            </summary>
            <param name="number">an int</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesOf.#ctor(System.Int64)">
            <summary>
            Bytes out of a long.
            </summary>
            <param name="number">a long</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesOf.#ctor(System.Single)">
            <summary>
            Bytes out of a float.
            </summary>
            <param name="number">a float</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesOf.#ctor(System.Double)">
            <summary>
            Bytes out of a double.
            </summary>
            <param name="number">a double</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesOf.#ctor(Yaapii.Atoms.IScalar{System.Byte[]})">
            <summary>
            Bytes out of other objects.
            </summary>
            <param name="bytes">scalar of bytes</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.BytesOf.AsBytes">
            <summary>
            Get the content as byte array.
            </summary>
            <returns>content as byte array</returns>
        </member>
        <member name="T:Yaapii.Atoms.Bytes.EmptyBytes">
            <summary>
            Bytes without data.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.EmptyBytes.#ctor">
            <summary>
            Bytes without data.
            </summary>        
        </member>
        <member name="M:Yaapii.Atoms.Bytes.EmptyBytes.AsBytes">
            <summary>
            Get the content as byte array.
            </summary>
            <returns>content as byte array</returns>
        </member>
        <member name="T:Yaapii.Atoms.Bytes.HexBytes">
            <summary>
            Bytes from Hex String
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.HexBytes.#ctor(System.String)">
            <summary>
            Bytes from Hex String
            </summary>
            <param name="origin">The string in Hex format</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.HexBytes.#ctor(Yaapii.Atoms.IText)">
            <summary>
            Bytes from Hex String
            </summary>
            <param name="origin">The string in Hex format</param>
        </member>
        <member name="T:Yaapii.Atoms.Bytes.InputAsBytes">
            <summary>
            Input as bytes. Disposes input.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.InputAsBytes.#ctor(Yaapii.Atoms.IInput,System.Int32)">
            <summary>
            Input as bytes.
            </summary>
            <param name="input">the input</param>
            <param name="max">maximum buffer size</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.InputAsBytes.AsBytes">
            <summary>
            Get the content as byte array. (Self-Disposing)
            </summary>
            <returns>content as byte array</returns>
        </member>
        <member name="T:Yaapii.Atoms.Bytes.LiveBytes">
            <summary>
            Bytes out of other objects that are reloaded on every call
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.LiveBytes.#ctor(System.Func{Yaapii.Atoms.IInput})">
            <summary>
            Reloads the bytes input on every call
            </summary>
            <param name="input">The input</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.LiveBytes.#ctor(System.Func{Yaapii.Atoms.IBytes})">
            <summary>
            Relaods the bytes on every call
            </summary>
            <param name="bytes"></param>
        </member>
        <member name="T:Yaapii.Atoms.Bytes.ReaderAsBytes">
            <summary>
            A <see cref="T:System.IO.StringReader"/> as <see cref="T:Yaapii.Atoms.IBytes"/>
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Bytes.ReaderAsBytes._reader">
            <summary>
            a reader
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Bytes.ReaderAsBytes._encoding">
            <summary>
            encoding of the reader
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Bytes.ReaderAsBytes._size">
            <summary>
            maximum buffer size
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.ReaderAsBytes.#ctor(System.IO.StringReader,System.Int32)">
            <summary>
            A <see cref="T:System.IO.StringReader"/> as <see cref="T:Yaapii.Atoms.IBytes"/>
            </summary>
            <param name="rdr">the reader</param>
            <param name="max">maximum buffer size</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.ReaderAsBytes.#ctor(System.IO.StreamReader)">
            <summary>
            A <see cref="T:System.IO.StreamReader"/> as <see cref="T:Yaapii.Atoms.IBytes"/>
            </summary>
            <param name="rdr">the reader</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.ReaderAsBytes.#ctor(System.IO.StreamReader,System.Text.Encoding,System.Int32)">
            <summary>
            A <see cref="T:System.IO.StreamReader"/> as <see cref="T:Yaapii.Atoms.IBytes"/>
            </summary>
            <param name="rdr">the reader</param>
            <param name="enc">encoding of the reader</param>
            <param name="max">maximum buffer size</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.ReaderAsBytes.#ctor(System.Func{System.IO.StreamReader},System.Text.Encoding,System.Int32)">
            <summary>
            A <see cref="T:System.IO.StreamReader"/> returned by a <see cref="T:System.Func`1"/>as <see cref="T:Yaapii.Atoms.IBytes"/>
            </summary>
            <param name="rdr">function to retrieve the reader</param>
            <param name="enc">encoding of the reader</param>
            <param name="max">maximum buffer size</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.ReaderAsBytes.#ctor(Yaapii.Atoms.IScalar{System.IO.StreamReader},System.Text.Encoding,System.Int32)">
            <summary>
            A <see cref="T:System.IO.StreamReader"/> returned by a <see cref="T:Yaapii.Atoms.IScalar`1"/> as <see cref="T:Yaapii.Atoms.IBytes"/>
            </summary>
            <param name="rdr">the reader</param>
            <param name="enc">encoding of the reader</param>
            <param name="max">maximum buffer size</param>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.ReaderAsBytes.AsBytes">
            <summary>
            Get the content as byte array.
            </summary>
            <returns>content as a byte array.</returns>
        </member>
        <member name="M:Yaapii.Atoms.Bytes.ReaderAsBytes.Dispose">
            <summary>
            Clean up.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Collection.ArrayListAsCollection">
            <summary>
            An ArrayList converted to a IList&lt;object&gt;
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Collection.ArrayListAsCollection.#ctor(System.Collections.ArrayList)">
            <summary>
            A ArrayList converted to IList&lt;object&gt;
            </summary>
            <param name="src">source ArrayList</param>
        </member>
        <member name="T:Yaapii.Atoms.Collection.CollectionEnvelope`1">
            <summary>
            Envelope for Collections. It enables ICollection classes from .Net to accept scalars.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Yaapii.Atoms.Collection.CollectionEnvelope`1.readonlyError">
            <summary>
            scalar of collection
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Collection.CollectionEnvelope`1.#ctor(System.Func{System.Collections.Generic.ICollection{`0}},System.Boolean)">
            <summary>
            ctor
            </summary>
            <param name="fnc">Func which delivers <see cref="T:System.Collections.Generic.ICollection`1"/></param>
            <param name="live">value is handled live or sticky</param>
        </member>
        <member name="M:Yaapii.Atoms.Collection.CollectionEnvelope`1.#ctor(Yaapii.Atoms.IScalar{System.Collections.Generic.ICollection{`0}},System.Boolean)">
            <summary>
            ctor
            </summary>
            <param name="slr">Scalar of ICollection</param>
            <param name="live">value is handled live or sticky</param>
        </member>
        <member name="P:Yaapii.Atoms.Collection.CollectionEnvelope`1.Count">
            <summary>
            Number of elements
            </summary>
        </member>
        <member name="P:Yaapii.Atoms.Collection.CollectionEnvelope`1.IsReadOnly">
            <summary>
            Is the collection readonly?
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Collection.CollectionEnvelope`1.Add(`0)">
            <summary>
            Add an element
            </summary>
            <param name="item">Item to add</param>
        </member>
        <member name="M:Yaapii.Atoms.Collection.CollectionEnvelope`1.Clear">
            <summary>
            Clear all items
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Collection.CollectionEnvelope`1.Contains(`0)">
            <summary>
            Test if the collection contains an item
            </summary>
            <param name="item">Item to lookup</param>
            <returns>True if item is found</returns>
        </member>
        <member name="M:Yaapii.Atoms.Collection.CollectionEnvelope`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies items from given index to target array
            </summary>
            <param name="array">Target array</param>
            <param name="arrayIndex">Index to start</param>
        </member>
        <member name="M:Yaapii.Atoms.Collection.CollectionEnvelope`1.GetEnumerator">
            <summary>
            A enumerator to iterate through the items.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Yaapii.Atoms.Collection.CollectionEnvelope`1.Remove(`0)">
            <summary>
            Remove an item
            </summary>
            <param name="item">Item to remove</param>
            <returns>True if success</returns>
        </member>
        <member name="M:Yaapii.Atoms.Collection.CollectionEnvelope`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get the enumerator to iterate through the items
            </summary>
            <returns></returns>
        </member>
        <member name="T:Yaapii.Atoms.Collection.CollectionOf`1">
            <summary>
            Envelope for collections. 
            It accepts a scalar and makes readonly Collection from it.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Collection.CollectionOf`1.#ctor(`0[])">
            <summary>
            Makes a collection from an array
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:Yaapii.Atoms.Collection.CollectionOf`1.#ctor(System.Collections.Generic.IEnumerator{`0})">
            <summary>
            Makes a collection from an <see cref="T:System.Collections.Generic.IEnumerator`1"/>
            </summary>
            <param name="src"></param>
        </member>
        <member name="M:Yaapii.Atoms.Collection.CollectionOf`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Makes a collection from an <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
            <param name="src"></param>
        </member>
        <member name="T:Yaapii.Atoms.Collection.Filtered`1">
            <summary>
            A filtered <see cref="T:System.Collections.Generic.ICollection`1"/>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Collection.Filtered`1.#ctor(System.Func{`0,System.Boolean},`0,`0,`0[])">
            <summary>
            A filtered <see cref="T:System.Collections.Generic.ICollection`1"/> which filters by the given condition <see cref="T:System.Func`2"/>.
            </summary>
            <param name="func">filter function</param>
            <param name="item1">first item to filter</param>
            <param name="item2">secound item to filter</param>
            <param name="items">other items to filter</param>
        </member>
        <member name="M:Yaapii.Atoms.Collection.Filtered`1.#ctor(System.Func{`0,System.Boolean},System.Collections.Generic.IEnumerator{`0})">
            <summary>
            A <see cref="T:System.Collections.Generic.ICollection`1"/> filtered by the given <see cref="T:System.Func`2"/>
            </summary>
            <param name="func">filter func</param>
            <param name="src">items to filter</param>
        </member>
        <member name="M:Yaapii.Atoms.Collection.Filtered`1.#ctor(System.Func{`0,System.Boolean},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            A <see cref="T:System.Collections.Generic.ICollection`1"/> filtered by the given <see cref="T:System.Func`2"/>
            </summary>
            <param name="func">filter func</param>
            <param name="src">items to filter</param>
        </member>
        <member name="T:Yaapii.Atoms.Collection.HeadOf`1">
            <summary>
            A collection which is limited to a number of elements.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Collection.HeadOf`1.#ctor(System.Int32,`0[])">
            <summary>
            ctor
            </summary>
            <param name="lmt">max number of items to limit to</param>
            <param name="src">items to limit</param>
        </member>
        <member name="M:Yaapii.Atoms.Collection.HeadOf`1.#ctor(System.Int32,System.Collections.Generic.IEnumerator{`0})">
            <summary>
            ctor
            </summary>
            <param name="lmt">max number of items to limit to</param>
            <param name="src">Enumerator to limit</param>
        </member>
        <member name="M:Yaapii.Atoms.Collection.HeadOf`1.#ctor(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            ctor
            </summary>
            <param name="lmt">requested number of items</param>
            <param name="src">enumerable of items</param>
        </member>
        <member name="M:Yaapii.Atoms.Collection.HeadOf`1.#ctor(System.Int32,System.Collections.Generic.ICollection{`0})">
            <summary>
            ctor
            </summary>
            <param name="src">source collection</param>
            <param name="lmt">requested number of elements</param>
        </member>
        <member name="T:Yaapii.Atoms.Collection.Joined`1">
            <summary>
            Joins collections together as one.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Collection.Joined`1.#ctor(System.Collections.Generic.IEnumerable{`0}[])">
            <summary>
            ctor
            </summary>
            <param name="list">List of collections to join together</param>
        </member>
        <member name="T:Yaapii.Atoms.Collection.LiveCollection`1">
            <summary>
            Envelope for collections. 
            It accepts a scalar and makes readonly Collection from it.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Collection.LiveCollection`1.#ctor(`0[])">
            <summary>
            Makes a collection from an array
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:Yaapii.Atoms.Collection.LiveCollection`1.#ctor(System.Collections.Generic.IEnumerator{`0})">
            <summary>
            Makes a collection from an <see cref="T:System.Collections.Generic.IEnumerator`1"/>
            </summary>
            <param name="src"></param>
        </member>
        <member name="M:Yaapii.Atoms.Collection.LiveCollection`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Makes a collection from an <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
            <param name="src"></param>
        </member>
        <member name="T:Yaapii.Atoms.Collection.Mapped`2">
            <summary>
            A collection which is mapped to the output type.
            </summary>
            <typeparam name="In">source type</typeparam>
            <typeparam name="Out">target type</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Collection.Mapped`2.#ctor(System.Func{`0,`1},`0[])">
            <summary>
            ctor
            </summary>
            <param name="mapping">mapping function</param>
            <param name="src">source items</param>
        </member>
        <member name="M:Yaapii.Atoms.Collection.Mapped`2.#ctor(System.Func{`0,`1},System.Collections.Generic.IEnumerator{`0})">
            <summary>
            ctor
            </summary>
            <param name="mapping">mapping function</param>
            <param name="src">source enumerator</param>
        </member>
        <member name="M:Yaapii.Atoms.Collection.Mapped`2.#ctor(System.Func{`0,`1},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            ctor
            </summary>
            <param name="mapping">mapping function</param>
            <param name="src">source enumerable</param>
        </member>
        <member name="M:Yaapii.Atoms.Collection.Mapped`2.#ctor(System.Func{`0,`1},System.Collections.Generic.ICollection{`0})">
            <summary>
            ctor
            </summary>
            <param name="mapping">mapping function</param>
            <param name="src">source collection</param>
        </member>
        <member name="T:Yaapii.Atoms.Collection.NotEmpty`1">
            <summary>
            Ensures that <see cref="T:System.Collections.Generic.ICollection`1" /> is not empty/>
            </summary>
            <typeparam name="T">Type of the collection</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Collection.NotEmpty`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            Ensures that <see cref="T:System.Collections.Generic.ICollection`1" /> is not empty/>
            </summary>
            <param name="origin">Collection</param>
        </member>
        <member name="M:Yaapii.Atoms.Collection.NotEmpty`1.#ctor(System.Collections.Generic.ICollection{`0},System.Exception)">
            <summary>
            Ensures that <see cref="T:System.Collections.Generic.ICollection`1" /> is not empty/>
            </summary>
            <param name="origin">Collection</param>
            <param name="ex">Execption to be thrown if empty</param>
        </member>
        <member name="T:Yaapii.Atoms.Collection.Reversed`1">
            
             Reversed collection.
            
             <para>There is no thread-safety guarantee.</para>
            
        </member>
        <member name="M:Yaapii.Atoms.Collection.Reversed`1.#ctor(`0[])">
            <summary>
            ctor
            </summary>
            <param name="src"></param>
        </member>
        <member name="M:Yaapii.Atoms.Collection.Reversed`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            ctor
            </summary>
            <param name="src">source collection</param>
        </member>
        <member name="M:Yaapii.Atoms.Collection.Reversed`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            ctor
            </summary>
            <param name="src">source collection</param>
        </member>
        <member name="T:Yaapii.Atoms.Collection.Solid`1">
            
             A <see cref="T:System.Collections.Generic.ICollection`1"/> that is both synchronized and sticky.
            
             <para>Objects of this class are thread-safe.</para>
            
        </member>
        <member name="M:Yaapii.Atoms.Collection.Solid`1.#ctor(`0[])">
            <summary>
            ctor
            </summary>
            <param name="array">source items</param>
        </member>
        <member name="M:Yaapii.Atoms.Collection.Solid`1.#ctor(System.Collections.Generic.IEnumerator{`0})">
            <summary>
            ctor
            </summary>
            <param name="src">source enumerator</param>
        </member>
        <member name="M:Yaapii.Atoms.Collection.Solid`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            ctor
            </summary>
            <param name="src">source enumerable</param>
        </member>
        <member name="M:Yaapii.Atoms.Collection.Solid`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            ctor
            </summary>
            <param name="src">source collection</param>
        </member>
        <member name="T:Yaapii.Atoms.Collection.Sorted`1">
            <summary>
            A sorted <see cref="T:System.Collections.Generic.ICollection`1"/>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Collection.Sorted`1.#ctor(`0[])">
            <summary>
            A list with default sorting (ascending)
            </summary>
            <param name="src">the source enumerable</param>
        </member>
        <member name="M:Yaapii.Atoms.Collection.Sorted`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            A <see cref="T:System.Collections.Generic.ICollection`1"/> with default sorting (ascending)
            </summary>
            <param name="src">the source enumerable</param>
        </member>
        <member name="M:Yaapii.Atoms.Collection.Sorted`1.#ctor(System.Collections.Generic.Comparer{`0},`0[])">
            <summary>
            A <see cref="T:System.Collections.Generic.ICollection`1"/> sorted using the given <see cref="T:System.Collections.Generic.Comparer`1"/>
            </summary>
            <param name="cmp">the comparer</param>
            <param name="src">the source enumerable</param>
        </member>
        <member name="M:Yaapii.Atoms.Collection.Sorted`1.#ctor(System.Collections.Generic.Comparer{`0},System.Collections.Generic.IEnumerator{`0})">
            <summary>
            A <see cref="T:System.Collections.Generic.ICollection`1"/> sorted using the given <see cref="T:System.Collections.Generic.Comparer`1"/>
            </summary>
            <param name="cmp">the comparer</param>
            <param name="src">the source enumerator</param>
        </member>
        <member name="M:Yaapii.Atoms.Collection.Sorted`1.#ctor(System.Collections.Generic.Comparer{`0},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            A <see cref="T:System.Collections.Generic.ICollection`1"/> sorted using the given <see cref="T:System.Collections.Generic.Comparer`1"/>
            </summary>
            <param name="cmp">the comparer</param>
            <param name="src">the source enumerable</param>
        </member>
        <member name="M:Yaapii.Atoms.Collection.Sorted`1.#ctor(System.Collections.Generic.Comparer{`0},System.Collections.Generic.ICollection{`0})">
            <summary>
            A <see cref="T:System.Collections.Generic.ICollection`1"/> sorted using the given <see cref="T:System.Collections.Generic.Comparer`1"/>
            </summary>
            <param name="cmp">the comparer</param>
            <param name="src">the source collection</param>
        </member>
        <member name="T:Yaapii.Atoms.Collection.Sync`1">
            <summary>
            A collection which is threadsafe.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Collection.Sync`1.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Collection.Sync`1.#ctor(System.Object)">
            <summary>
            ctor
            </summary>
            <param name="syncRoot"></param>
        </member>
        <member name="M:Yaapii.Atoms.Collection.Sync`1.#ctor(`0[])">
            <summary>
            ctor
            </summary>
            <param name="items">items to make collection from</param>
        </member>
        <member name="M:Yaapii.Atoms.Collection.Sync`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            ctor
            </summary>
            <param name="col">Collection to sync</param>
        </member>
        <member name="M:Yaapii.Atoms.Collection.Sync`1.#ctor(System.Object,System.Collections.Generic.ICollection{`0})">
            <summary>
            ctor
            </summary>
            <param name="syncRoot">root object to sync</param>
            <param name="col"></param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.Contains`1">
            <summary>
            Lookup if an item is in a enumerable.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Contains`1.#ctor(System.Collections.Generic.IEnumerable{`0},`0)">
            <summary>
            Lookup if an item is in a enumerable by calling .Equals(...) of the item.
            </summary>
            <param name="item">item to lookup</param>
            <param name="src">enumerable to test</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Contains`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Func{`0,System.Boolean})">
            <summary>
            Lookup if any item matches the given function
            </summary>
            <param name="items">enumerable to search through</param>
            <param name="match">check to perform on each item</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Contains`1.Value">
            <summary>
            see if the item is in the enumerable.
            </summary>
            <returns>true if item is in the enumerable</returns>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.Cycled`1">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerable`1"/> that starts from the beginning when ended.
            </summary>
            <typeparam name="T">type of the contents</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Cycled`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that starts from the beginning when ended.
            </summary>
            <param name="enumerable">an enum to cycle</param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.Distinct`1">
            <summary>
            Multiple enumerables merged together, so that every entry is unique.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Distinct`1.#ctor(System.Collections.Generic.IEnumerable{`0}[])">
            <summary>
            The distinct elements of one or multiple Enumerables.
            </summary>
            <param name="enumerables">enumerables to get distinct elements from</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Distinct`1.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{`0}})">
            <summary>
            The distinct elements of one or multiple Enumerables.
            </summary>
            <param name="enumerables">enumerables to get distinct elements from</param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.Divergency`1">
            <summary>
            Items which do only exist in one enumerable.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Divergency`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0},System.Func{`0,System.Boolean})">
            <summary>
            Items which do only exist in one enumerable.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Divergency`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Items which do only exist in one enumerable.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Divergency`1.#ctor(System.Func{System.Collections.Generic.IEnumerable{`0}})">
            <summary>
            Items which do only exist in one enumerable.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.Endless`1">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerable`1"/> that repeats one element infinitely.
            </summary>
            <typeparam name="T">type of the elements</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Endless`1.#ctor(`0)">
            <summary>
            A <see cref="T:System.Collections.IEnumerable"/> that repeats one element infinitely.
            </summary>
            <param name="elm">element to repeat</param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.Filtered`1">
            <summary>
            A filtered <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            Pass a filter function which will applied to all items, similar to List{T}.Where(...) in LinQ
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Filtered`1.#ctor(System.Func{`0,System.Boolean},`0,`0,`0[])">
            <summary>
            A filtered <see cref="T:System.Collections.Generic.IEnumerable`1"/> which filters by the given condition <see cref="T:System.Func`2"/>.
            </summary>
            <param name="fnc">filter function</param>
            <param name="item1">first item to filter</param>
            <param name="item2">secound item to filter</param>
            <param name="items">other items to filter</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Filtered`1.#ctor(System.Func{`0,System.Boolean},System.Collections.Generic.IEnumerable{`0},System.Boolean)">
            <summary>
            A filtered <see cref="T:System.Collections.Generic.IEnumerable`1"/> which filters by the given condition <see cref="T:System.Func`2"/>.
            </summary>
            <param name="src">enumerable to filter</param>
            <param name="fnc">filter function</param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.HeadOf`1">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerable`1"/> limited to an item maximum.
            </summary>
            <typeparam name="T">type of elements</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.HeadOf`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            ctor
            </summary>
            <param name="enumerable">enumerable to limit</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.HeadOf`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Int32)">
            <summary>
            ctor
            </summary>
            <param name="enumerable">enumerable to limit</param>
            <param name="limit">maximum item count</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.HeadOf`1.#ctor(System.Collections.Generic.IEnumerable{`0},Yaapii.Atoms.IScalar{System.Int32})">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerable`1"/> limited to an item maximum.
            </summary>
            <param name="enumerable">enumerable to limit</param>
            <param name="limit">maximum item count</param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.Joined`1">
            <summary>
            Multiple <see cref="T:System.Collections.Generic.IEnumerable`1"/> joined together.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Joined`1.#ctor(`0,`0,System.Collections.Generic.IEnumerable{`0},`0[])">
            <summary>
            Join a <see cref="T:System.Collections.Generic.IEnumerable`1"/> with (multiple) single Elements.
            </summary>
            <param name="lst">enumerable of items to join</param>
            <param name="items">array of items to join</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Joined`1.#ctor(`0,System.Collections.Generic.IEnumerable{`0},`0[])">
            <summary>
            Join a <see cref="T:System.Collections.Generic.IEnumerable`1"/> with (multiple) single Elements.
            </summary>
            <param name="lst">enumerable of items to join</param>
            <param name="items">array of items to join</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Joined`1.#ctor(System.Collections.Generic.IEnumerable{`0},`0[])">
            <summary>
            Join a <see cref="T:System.Collections.Generic.IEnumerable`1"/> with (multiple) single Elements.
            </summary>
            <param name="lst">enumerable of items to join</param>
            <param name="items">array of items to join</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Joined`1.#ctor(System.Collections.Generic.IEnumerable{`0}[])">
            <summary>
            Multiple <see cref="T:System.Collections.Generic.IEnumerable`1"/> joined together.
            </summary>
            <param name="items">enumerables to join</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Joined`1.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{`0}})">
            <summary>
            Multiple <see cref="T:System.Collections.Generic.IEnumerable`1"/> joined together.
            </summary>
            <param name="items">enumerables to join</param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.LengthOf">
            <summary>
            Length of an <see cref="T:System.Collections.IEnumerable"/>.
            Important: You must understand that this object will iterate over the passed items 
            every time when you call .Value(). It is recommended to use a StickyScalar, 
            if you want to re-use its value.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.LengthOf.#ctor(System.Collections.IEnumerable)">
            <summary>
            Length of an <see cref="T:System.Collections.IEnumerable"/>
            </summary>
            <param name="items">the enumerable</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.LengthOf.Value">
            <summary>
            Get the length.
            </summary>
            <returns>the length</returns>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.LiveMany`1">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerable`1"/> out of other objects.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.LiveMany`1.#ctor(`0[])">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerable`1"/> out of an array.
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.LiveMany`1.#ctor(System.Func{System.Collections.Generic.IEnumerator{`0}})">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerable`1"/> out of a <see cref="T:System.Collections.Generic.IEnumerator`1"/> returned by a <see cref="T:System.Func`1"/>"/>.
            </summary>
            <param name="fnc">function which retrieves enumerator</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.LiveMany`1.#ctor(System.Func{System.Collections.Generic.IEnumerable{`0}})">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerable`1"/> out of a <see cref="T:System.Collections.Generic.IEnumerator`1"/> returned by a <see cref="T:System.Func`1"/>"/>.
            </summary>
            <param name="fnc">function which retrieves enumerator</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.LiveMany`1.#ctor(Yaapii.Atoms.IScalar{System.Collections.Generic.IEnumerator{`0}})">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerable`1"/> out of a <see cref="T:System.Collections.Generic.IEnumerator`1"/> encapsulated in a <see cref="T:Yaapii.Atoms.IScalar`1"/>"/>.
            </summary>
            <param name="origin">scalar to return the IEnumerator</param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.LiveMany`1.LiveEnumeratorAsEnumerable`1">
            <summary>
            Makes enumerable from an enumerator
            </summary>
            <typeparam name="X"></typeparam>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.Logging`1">
            <summary>
            Enumerable that logs object T when it is iterated.
            T is logged right after the underlying enumerator is moved.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Logging`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Enumerable that logs object T to debug console when it is iterated.
            T is logged right after the underlying enumerator is moved.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Logging`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Action{`0})">
            <summary>
            Enumerable that logs object T when it is iterated.
            T is logged right after the underlying enumerator is moved.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.ManyEnvelope">
            <summary>
            Envelope for Enumerable of strings.
            It bundles the methods offered by IEnumerable and enables scalar based ctors.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ManyEnvelope.#ctor(Yaapii.Atoms.IScalar{System.Collections.Generic.IEnumerable{System.String}},System.Boolean)">
            <summary>
            Envelope for Enumerable.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ManyEnvelope.#ctor(System.Func{System.Collections.Generic.IEnumerable{System.String}},System.Boolean)">
            <summary>
            Envelope for Enumerable.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ManyEnvelope.#ctor(System.Func{System.Collections.Generic.IEnumerator{System.String}},System.Boolean)">
            <summary>
            Envelope for Enumerable.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ManyEnvelope.GetEnumerator">
            <summary>
            Enumerator for this envelope.
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ManyEnvelope.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Enumerator for this envelope.
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.ManyEnvelope`1">
            <summary>
            Envelope for Enumerable.
            It bundles the methods offered by IEnumerable and enables scalar based ctors.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ManyEnvelope`1.#ctor(Yaapii.Atoms.IScalar{System.Collections.Generic.IEnumerable{`0}},System.Boolean)">
            <summary>
            Envelope for Enumerable.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ManyEnvelope`1.#ctor(System.Func{System.Collections.Generic.IEnumerable{`0}},System.Boolean)">
            <summary>
            Envelope for Enumerable.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ManyEnvelope`1.#ctor(System.Func{System.Collections.Generic.IEnumerator{`0}},System.Boolean)">
            <summary>
            Envelope for Enumerables.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ManyEnvelope`1.GetEnumerator">
            <summary>
            Enumerator for this envelope.
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ManyEnvelope`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Enumerator for this envelope.
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.ManyOf">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerable`1"/> out of strings.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ManyOf.#ctor(System.String[])">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerable`1"/> out of an array.
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ManyOf.#ctor(System.Collections.Generic.IEnumerator{System.String})">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerable`1"/> out of a <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
            <param name="e">a enumerator</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ManyOf.#ctor(Yaapii.Atoms.IScalar{System.Collections.Generic.IEnumerator{System.String}})">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerable`1"/> out of a <see cref="T:System.Collections.Generic.IEnumerator`1"/> returned by a <see cref="T:System.Func`1"/>"/>.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ManyOf.#ctor(System.Func{System.Collections.Generic.IEnumerable{System.String}})">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerable`1"/> out of a <see cref="T:System.Collections.Generic.IEnumerator`1"/> returned by a <see cref="T:System.Func`1"/>"/>.
            </summary>
            <param name="fnc">function which retrieves enumerator</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ManyOf.#ctor(System.Func{System.Collections.Generic.IEnumerator{System.String}})">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerable`1"/> out of a <see cref="T:System.Collections.Generic.IEnumerator`1"/> encapsulated in a <see cref="T:Yaapii.Atoms.IScalar`1"/>"/>.
            </summary>
            <param name="origin">scalar to return the IEnumerator</param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.ManyOf`1">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerable`1"/> out of other objects.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ManyOf`1.#ctor(`0[])">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerable`1"/> out of an array.
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ManyOf`1.#ctor(System.Collections.Generic.IEnumerator{`0})">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerable`1"/> out of a <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
            <param name="e">a enumerator</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ManyOf`1.#ctor(Yaapii.Atoms.IScalar{System.Collections.Generic.IEnumerator{`0}})">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerable`1"/> out of a <see cref="T:System.Collections.Generic.IEnumerator`1"/> returned by a <see cref="T:System.Func`1"/>"/>.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ManyOf`1.#ctor(System.Func{System.Collections.Generic.IEnumerable{`0}})">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerable`1"/> out of a <see cref="T:System.Collections.Generic.IEnumerator`1"/> returned by a <see cref="T:System.Func`1"/>"/>.
            </summary>
            <param name="fnc">function which retrieves enumerator</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ManyOf`1.#ctor(System.Func{System.Collections.Generic.IEnumerator{`0}})">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerable`1"/> out of a <see cref="T:System.Collections.Generic.IEnumerator`1"/> encapsulated in a <see cref="T:Yaapii.Atoms.IScalar`1"/>"/>.
            </summary>
            <param name="origin">scalar to return the IEnumerator</param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.ManyOfArrayList">
            <summary>
            A <see cref="T:System.Collections.ArrayList"/> converted to IEnumerable&lt;object&gt;
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ManyOfArrayList.#ctor(System.Collections.ArrayList)">
            <summary>
            A ArrayList converted to IEnumerable&lt;object&gt;
            </summary>
            <param name="src">source ArrayList</param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.ManyOfArrayList`1">
            <summary>
            A <see cref="T:System.Collections.ArrayList"/> converted to IEnumerable&lt;T&gt;
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ManyOfArrayList`1.#ctor(System.Collections.ArrayList)">
            <summary>
            A ArrayList converted to IEnumerable&lt;object&gt;
            </summary>
            <param name="src">source ArrayList</param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.Mapped`2">
            <summary>
            Mapped content of an <see cref="T:System.Collections.Generic.IEnumerable`1"/> to another type using the given function.
            </summary>
            <typeparam name="In">type of input elements</typeparam>
            <typeparam name="Out">type of mapped elements</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Mapped`2.#ctor(Yaapii.Atoms.IFunc{`0,`1},`0[])">
            <summary>
            Mapped content of an <see cref="T:System.Collections.Generic.IEnumerable`1"/> to another type using the given <see cref="T:Yaapii.Atoms.IFunc`2"/> function.
            </summary>
            <param name="src">enumerable to map</param>
            <param name="fnc">function used to map</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Mapped`2.#ctor(Yaapii.Atoms.IBiFunc{`0,System.Int32,`1},`0[])">
            <summary>
            Mapped content of an <see cref="T:System.Collections.Generic.IEnumerable`1"/> to another type using the given <see cref="T:Yaapii.Atoms.IBiFunc`3"/> function with index.
            </summary>
            <param name="src">enumerable to map</param>
            <param name="fnc">function used to map</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Mapped`2.#ctor(System.Func{`0,`1},System.Collections.Generic.IEnumerable{`0},System.Boolean)">
            <summary>
            Mapped content of an <see cref="T:System.Collections.Generic.IEnumerable`1"/> to another type using the given <see cref="T:System.Func`2"/> function.
            </summary>
            <param name="src">enumerable to map</param>
            <param name="fnc">function used to map</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Mapped`2.#ctor(System.Func{`0,System.Int32,`1},System.Collections.Generic.IEnumerable{`0},System.Boolean)">
            <summary>
            Mapped content of an <see cref="T:System.Collections.Generic.IEnumerable`1"/> to another type using the given <see cref="T:System.Func`3"/> function with index.
            </summary>
            <param name="src">enumerable to map</param>
            <param name="fnc">function used to map</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Mapped`2.#ctor(Yaapii.Atoms.IFunc{`0,`1},System.Collections.Generic.IEnumerable{`0},System.Boolean)">
            <summary>
            Mapped content of an <see cref="T:System.Collections.Generic.IEnumerable`1"/> to another type using the given <see cref="T:Yaapii.Atoms.IFunc`2"/> function.
            </summary>
            <param name="src">enumerable to map</param>
            <param name="fnc">function used to map</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Mapped`2.#ctor(Yaapii.Atoms.IBiFunc{`0,System.Int32,`1},System.Collections.Generic.IEnumerable{`0},System.Boolean)">
            <summary>
            Mapped content of an <see cref="T:System.Collections.Generic.IEnumerable`1"/> to another type using the given <see cref="T:Yaapii.Atoms.IBiFunc`3"/> function with index.
            </summary>
            <param name="src">enumerable to map</param>
            <param name="fnc">function used to map</param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.NotEmpty`1">
            <summary>
            Ensures that <see cref="T:System.Collections.Generic.IEnumerable`1" /> is not empty/>
            </summary>
            <typeparam name="T">Type of the enumerable</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.NotEmpty`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Ensures that <see cref="T:System.Collections.Generic.IEnumerable`1" /> is not empty/>
            </summary>
            <param name="origin">Enumerable</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.NotEmpty`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Exception)">
            <summary>
            Ensures that <see cref="T:System.Collections.Generic.IEnumerable`1" /> is not empty/>
            </summary>
            <param name="origin">Enumerable</param>
            <param name="ex">Execption to be thrown if empty</param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.Partitioned`1">
            <summary>
            Enumerable partitioned by a given size.
            <para>Is a IEnumerable</para>
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Partitioned`1.#ctor(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Enumerable partitioned by a given size.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.Reduced`1">
            <summary>
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose items are reduced to one item using the given function.
            </summary>
            <typeparam name="T">type of elements in a list to reduce</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Reduced`1.#ctor(System.Collections.Generic.IEnumerable{`0},Yaapii.Atoms.IBiFunc{`0,`0,`0})">
            <summary>
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose items are folded to one item using the given function.
            </summary>
            <param name="elements">enumerable to reduce</param>
            <param name="fnc">reducing function</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Reduced`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Func{`0,`0,`0})">
            <summary>
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> whose items are reduced to one item using the given function.
            </summary>
            <param name="elements">enumerable to reduce</param>
            <param name="fnc">reducing function</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Reduced`1.Value">
            <summary>
            Get the value.
            </summary>
            <returns>the value</returns>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.Repeated`1">
            <summary>
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> which repeats one element multiple times.
            </summary>
            <typeparam name="T">type of element to repeat</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Repeated`1.#ctor(System.Func{`0},System.Int32)">
            <summary>
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> which repeats one element multiple times.
            </summary>
            <param name="elm">function to get element to repeat</param>
            <param name="cnt">how often to repeat</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Repeated`1.#ctor(`0,System.Int32)">
            <summary>
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> which repeats one element multiple times.
            </summary>
            <param name="elm">element to repeat</param>
            <param name="cnt">how often to repeat</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Repeated`1.#ctor(Yaapii.Atoms.IScalar{`0},System.Int32)">
            <summary>
            ctor
            </summary>
            <param name="elm">scalar to get element to repeat</param>
            <param name="cnt">how often to repeat</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Repeated`1.#ctor(Yaapii.Atoms.IScalar{`0},Yaapii.Atoms.IScalar{System.Int32})">
            <summary>
            ctor
            </summary>
            <param name="elm">scalar to get element to repeat</param>
            <param name="cnt">how often to repeat</param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.Replaced`1">
            <summary>
            A <see cref="T:System.Collections.IEnumerable"/> whose items are replaced if they match a condition.
            </summary>
            <typeparam name="T">type of items in enumerable</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Replaced`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Func{`0,System.Boolean},`0)">
            <summary>
            A <see cref="T:System.Collections.IEnumerable"/> whose items are replaced if they match a condition.
            </summary>
            <param name="origin">enumerable</param>
            <param name="condition">matching condition</param>
            <param name="replacement">item to insert instead</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Replaced`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Int32,`0)">
            <summary>
            A <see cref="T:System.Collections.IEnumerable"/> where an item at a given index is replaced.
            </summary>
            <param name="origin">enumerable</param>
            <param name="index">index at which to replace the item</param>
            <param name="replacement">item to insert instead</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Replaced`1.#ctor(System.Collections.Generic.IEnumerable{`0},Yaapii.Atoms.IFunc{`0,System.Boolean},`0)">
            <summary>
            A <see cref="T:System.Collections.IEnumerable"/> whose items are replaced if they match a condition.
            </summary>
            <param name="origin">enumerable</param>
            <param name="condition">matching condition</param>
            <param name="replacement">item to insert instead</param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.Reversed`1">
            <summary>
            A reversed <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
            <typeparam name="X">type of items in enumerable</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Reversed`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            A reversed <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
            <param name="src">enumerable to reverse</param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.Sibling`1">
            <summary>
            Element before another element in a <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <typeparam name="T">type of element</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Sibling`1.#ctor(`0,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Next neighbour element in a <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <param name="source">source enum</param>
            <param name="item">item to start</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Sibling`1.#ctor(`0,System.Collections.Generic.IEnumerable{`0},`0)">
            <summary>
            Next neighbour in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> with a fallback value.
            </summary>
            <param name="source">source enum</param>
            <param name="fallback">fallback func</param>
            <param name="item">item to start</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Sibling`1.#ctor(`0,System.Collections.Generic.IEnumerable{`0},System.Int32)">
            <summary>
            Element at a position in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> with a fallback value.
            </summary>
            <param name="source">source enum</param>
            <param name="relativeposition">requested position relative to the given item</param>
            <param name="item">item to start</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Sibling`1.#ctor(`0,System.Collections.Generic.IEnumerable{`0},System.Int32,`0)">
            <summary>
            Element at a position in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> with a fallback value.
            </summary>
            <param name="source">source enum</param>
            <param name="relativeposition">requested position relative to the given item</param>
            <param name="fallback">fallback func</param>
            <param name="item">item to start</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Sibling`1.#ctor(`0,System.Collections.Generic.IEnumerable{`0},Yaapii.Atoms.IFunc{System.Collections.Generic.IEnumerable{`0},`0})">
            <summary>
            Next neighbour of an item in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> with a fallback function <see cref="T:Yaapii.Atoms.IFunc`2"/>.
            </summary>
            <param name="source">soruce enum</param>
            <param name="fallback">fallback value</param>
            <param name="item">item to start</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Sibling`1.#ctor(`0,System.Collections.Generic.IEnumerable{`0},System.Int32,Yaapii.Atoms.IFunc{System.Collections.Generic.IEnumerable{`0},`0})">
            <summary>
            Element that comes before another element in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> fallback function <see cref="T:Yaapii.Atoms.IFunc`2"/>.
            </summary>
            <param name="source">source enum</param>
            <param name="item">item to start</param>
            <param name="fallback">fallback func</param>
            <param name="relativeposition">requested position relative to the given item</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Sibling`1.Value">
            <summary>
            Get the item.
            </summary>
            <returns>the item</returns>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.Skipped`1">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerable`1"/> which skips a given count of items.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Skipped`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Int32)">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerable`1"/> which skips a given count of items.
            </summary>
            <param name="enumerable">enumerable to skip items in</param>
            <param name="skip">how many to skip</param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.Sorted`1">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerable`1"/> sorted by the given <see cref="T:System.Collections.Generic.Comparer`1"/>.
            </summary>
            <typeparam name="T">type of elements</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Sorted`1.#ctor(`0[])">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerable`1"/> with the given items sorted by default.
            </summary>
            <param name="src">enumerable to sort</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Sorted`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerable`1"/> sorted by the given <see cref="T:System.Collections.Generic.Comparer`1"/>.
            </summary>
            <param name="src">enumerable to sort</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Sorted`1.#ctor(System.Collections.Generic.Comparer{`0},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerable`1"/> sorted by the given <see cref="T:System.Collections.Generic.Comparer`1"/>.
            </summary>
            <param name="cmp">comparer</param>
            <param name="src">enumerable to sort</param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.Union`1">
            <summary>
            Union objects in two enumerables.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Union`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0},System.Func{`0,`0,System.Boolean})">
            <summary>
            Union objects in two enumerables.
            </summary>
            <param name="compare">Condition to match</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Union`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Union objects in two enumerables.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Union`1.#ctor(System.Func{System.Collections.Generic.IEnumerable{`0}})">
            <summary>
            Union objects in two enumerables.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.LoggingEnumerator`1">
            <summary>
            An enumerator that logs the object T when it is moved.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.LoggingEnumerator`1.#ctor(System.Collections.Generic.IEnumerator{`0},System.Action{`0})">
            <summary>
            An enumerator that logs the object T when it is moved.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.ItemAt`1">
            <summary>
            Element from position in a <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <typeparam name="T">type of element</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ItemAt`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Exception)">
            <summary>
            First element in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> with given Exception thrwon on fallback
            </summary>
            <param name="source"></param>
            <param name="ex"></param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ItemAt`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Int32,System.Exception)">
            <summary>
            Element at position in <see cref="T:System.Collections.Generic.IEnumerable`1"/> with given Exception thrown on fallback
            </summary>
            <param name="source"></param>
            <param name="position"></param>
            <param name="ex"></param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ItemAt`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            First element in a <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <param name="source">source enum</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ItemAt`1.#ctor(System.Collections.Generic.IEnumerable{`0},`0)">
            <summary>
            First element in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> with a fallback value.
            </summary>
            <param name="source">source enum</param>
            <param name="fallback">fallback func</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ItemAt`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Int32,`0)">
            <summary>
            Element at a position in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> with a fallback value.
            </summary>
            <param name="source">source enum</param>
            <param name="position">position</param>
            <param name="fallback">fallback func</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ItemAt`1.#ctor(System.Collections.Generic.IEnumerable{`0},Yaapii.Atoms.IBiFunc{System.Exception,System.Collections.Generic.IEnumerable{`0},`0})">
            <summary>
            First element in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> with a fallback function <see cref="T:Yaapii.Atoms.IFunc`2"/>.
            </summary>
            <param name="source">soruce enum</param>
            <param name="fallback">fallback value</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ItemAt`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Func{System.Collections.Generic.IEnumerable{`0},`0})">
            <summary>
            First element in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> with a fallback function <see cref="T:Yaapii.Atoms.IFunc`2"/>.
            </summary>
            <param name="source">soruce enum</param>
            <param name="fallback">fallback value</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ItemAt`1.#ctor(System.Collections.Generic.IEnumerable{`0},Yaapii.Atoms.IFunc{System.Collections.Generic.IEnumerable{`0},`0})">
            <summary>
            First element in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> with a fallback function <see cref="T:Yaapii.Atoms.IFunc`2"/>.
            </summary>
            <param name="source">soruce enum</param>
            <param name="fallback">fallback value</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ItemAt`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Int32)">
            <summary>
            Element from position in a <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <param name="source">source enum</param>
            <param name="position">position of item</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ItemAt`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Int32,Yaapii.Atoms.IFunc{System.Collections.Generic.IEnumerable{`0},`0})">
            <summary>
            Element from position in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> fallback function <see cref="T:Yaapii.Atoms.IFunc`2"/>.
            </summary>
            <param name="source">source enum</param>
            <param name="position">position of item</param>
            <param name="fallback">fallback func</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ItemAt`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Int32,System.Func{System.Collections.Generic.IEnumerable{`0},`0})">
            <summary>
            Element from position in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> fallback function <see cref="T:Yaapii.Atoms.IFunc`2"/>.
            </summary>
            <param name="source">source enum</param>
            <param name="position">position of item</param>
            <param name="fallback">fallback func</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ItemAt`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Int32,System.Func{System.Exception,System.Collections.Generic.IEnumerable{`0},`0})">
            <summary>
            Element from position in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> fallback function <see cref="T:Yaapii.Atoms.IFunc`2"/>.
            </summary>
            <param name="source">source enum</param>
            <param name="position">position of item</param>
            <param name="fallback">fallback func</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.ItemAt`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Int32,Yaapii.Atoms.IBiFunc{System.Exception,System.Collections.Generic.IEnumerable{`0},`0})">
            <summary>
            Element from position in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> fallback function <see cref="T:Yaapii.Atoms.IFunc`2"/>.
            </summary>
            <param name="source">source enum</param>
            <param name="position">position of item</param>
            <param name="fallback">fallback func</param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.LastOf`1">
            <summary>
            Last element in a <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.LastOf`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Exception)">
            <summary>
            Last element in <see cref="T:System.Collections.Generic.IEnumerable`1"/> with given Exception thrown on fallback
            </summary>
            <param name="source"></param>
            <param name="ex"></param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.LastOf`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Last element in a <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <param name="source">source enum</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.LastOf`1.#ctor(System.Collections.Generic.IEnumerable{`0},`0)">
            <summary>
            Last element in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> with a fallback value.
            </summary>
            <param name="source">source enum</param>
            <param name="fallback">fallback func</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.LastOf`1.#ctor(System.Collections.Generic.IEnumerable{`0},Yaapii.Atoms.IFunc{System.Collections.Generic.IEnumerable{`0},`0})">
            <summary>
            Last element in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> fallback function <see cref="T:Yaapii.Atoms.IFunc`2"/>.
            </summary>
            <param name="source">source enum</param>
            <param name="fallback">fallback func</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.LastOf`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Func{System.Exception,System.Collections.Generic.IEnumerable{`0},`0})">
            <summary>
            Last Element in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> fallback function <see cref="T:Yaapii.Atoms.IFunc`2"/>.
            </summary>
            <param name="source">source enum</param>
            <param name="fallback">fallback func</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.LastOf`1.#ctor(System.Collections.Generic.IEnumerable{`0},Yaapii.Atoms.IBiFunc{System.Exception,System.Collections.Generic.IEnumerable{`0},`0})">
            <summary>
            Last Element in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> fallback function <see cref="T:Yaapii.Atoms.IFunc`2"/>.
            </summary>
            <param name="source">source enum</param>
            <param name="fallback">fallback func</param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.Max`1">
            <summary>
            The greatest item in the given <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Max`1.#ctor(System.Func{`0}[])">
            <summary>
            The greatest item in the given <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
            <param name="items">list of items</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Max`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            The greatest item in the given <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
            <param name="items">list of items</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Max`1.#ctor(`0[])">
            <summary>
            The greatest item in the given items.
            </summary>
            <param name="items">list of items</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Max`1.#ctor(Yaapii.Atoms.IScalar{`0}[])">
            <summary>
            The greatest item in the given <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
            <param name="items">list of items</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Max`1.#ctor(System.Collections.Generic.IEnumerable{Yaapii.Atoms.IScalar{`0}})">
            <summary>
            The greatest item in the given <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
            <param name="items">list of items</param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerable.Min`1">
            <summary>
            Find the smallest item in a <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Min`1.#ctor(System.Func{`0}[])">
            <summary>
            Find the smallest item in a <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
            <param name="items"><see cref="T:System.Func`1"/> functions which retrieve items to compare</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Min`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Find the smallest item in a <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
            <param name="items">items to compare</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Min`1.#ctor(`0[])">
            <summary>
            Find the smallest item in the given items
            </summary>
            <param name="items">items to compare</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Min`1.#ctor(Yaapii.Atoms.IScalar{`0}[])">
            <summary>
            Find the smallest item in the given scalars.
            </summary>
            <param name="items">items to compare</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerable.Min`1.#ctor(System.Collections.Generic.IEnumerable{Yaapii.Atoms.IScalar{`0}})">
            <summary>
            Find the smallest item in a <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
            <param name="items">items to compare</param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerator.Contains`1">
            <summary>
            Lookup if an item is in a enumerable
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.Contains`1.#ctor(System.Collections.Generic.IEnumerator{`0},System.Func{`0,System.Boolean})">
            <summary>
            Lookup the item in the src.
            </summary>
            <param name="src">src enumerable</param>
            <param name="match">lookup item</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.Contains`1.Value">
            <summary>
            Determine if the item is in the enumerable.
            </summary>
            <returns>true if item is present in enumerable.</returns>
        </member>
        <member name="T:Yaapii.Atoms.Enumerator.Cycled`1">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that starts from the beginning when ended.
            </summary>
            <typeparam name="T">type of the contents</typeparam>
        </member>
        <member name="F:Yaapii.Atoms.Enumerator.Cycled`1.enumerable">
            <summary>
            enum to cycle
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Enumerator.Cycled`1.buffer">
            <summary>
            cache
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.Cycled`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that starts from the beginning when ended.
            </summary>
            <param name="enumerable">enum to cycle</param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerator.Distinct`1">
            <summary>
            Enumerator that only gives the distinct elements of multiple enumerators.
            </summary>
            <typeparam name="T">type of elements</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.Distinct`1.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerator{`0}})">
            <summary>
            Enumerator that only gives the distinct elements of multiple enumerators.
            </summary>
            <param name="enumerators"></param>
        </member>
        <member name="P:Yaapii.Atoms.Enumerator.Distinct`1.Current">
            <summary>
            Current element
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.Distinct`1.MoveNext">
            <summary>
            Move to next element
            </summary>
            <returns></returns>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.Distinct`1.Reset">
            <summary>
            Reset this enumerator
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Enumerator.Endless`1">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that repeats one element infinitely.
            </summary>
            <typeparam name="T">type of the contents</typeparam>
        </member>
        <member name="F:Yaapii.Atoms.Enumerator.Endless`1.element">
            <summary>
            element to repeat
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.Endless`1.#ctor(`0)">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that repeats one element infinitely.
            </summary>
            <param name="elm">element to repeat</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.Endless`1.#ctor(Yaapii.Atoms.IScalar{`0})">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that repeats one element infinitely.
            </summary>
            <param name="elm">scalar of element to repeat</param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerator.Filtered`1">
            <summary>
            A filtered <see cref="T:System.Collections.Generic.IEnumerable`1"/> which filters by the given condition.
            </summary>
            <typeparam name="X"></typeparam>
        </member>
        <member name="F:Yaapii.Atoms.Enumerator.Filtered`1.enumerator">
            <summary>
            enumerator to filter
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Enumerator.Filtered`1.func">
            <summary>
            filter function
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Enumerator.Filtered`1.buffer">
            <summary>
            buffer to store filtered elements
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.Filtered`1.#ctor(System.Collections.Generic.IEnumerator{`0},Yaapii.Atoms.IFunc{`0,System.Boolean})">
            <summary>
            A filtered <see cref="T:System.Collections.Generic.IEnumerable`1"/> which filters by the given condition <see cref="T:System.Func`2"/>.
            </summary>
            <param name="src">enumerable to filter</param>
            <param name="fnc">filter function</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.Filtered`1.#ctor(System.Collections.Generic.IEnumerator{`0},System.Func{`0,System.Boolean})">
            <summary>
            A filtered <see cref="T:System.Collections.Generic.IEnumerable`1"/> which filters by the given condition <see cref="T:Yaapii.Atoms.IFunc`2"/>.
            </summary>
            <param name="src">enumerable to filter</param>
            <param name="fnc">filter function</param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerator.HeadOf`1">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> limited to an item maximum.
            </summary>
            <typeparam name="T">type of the enumerator content</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.HeadOf`1.#ctor(System.Collections.Generic.IEnumerator{`0},System.Int32)">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> limited to an item maximum.
            </summary>
            <param name="enumerator">enumerator to limit</param>
            <param name="limit">maximum item count</param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerator.ItemAt`1">
            <summary>
            Element from position in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> fallback function <see cref="T:Yaapii.Atoms.IFunc`2"/>.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Yaapii.Atoms.Enumerator.ItemAt`1.src">
            <summary>
            enumerator to get item from
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Enumerator.ItemAt`1.fallback">
            <summary>
            fallback function for alternative value
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Enumerator.ItemAt`1.pos">
            <summary>
            position of the item
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.ItemAt`1.#ctor(System.Collections.Generic.IEnumerator{`0})">
            <summary>
            First element in a <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <param name="src">source <see cref="T:System.Collections.Generic.IEnumerable`1"/></param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.ItemAt`1.#ctor(System.Collections.Generic.IEnumerator{`0},`0)">
            <summary>
            First element in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> with a fallback value.
            </summary>
            <param name="src">source <see cref="T:System.Collections.Generic.IEnumerable`1"/></param>
            <param name="fallback">fallback value</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.ItemAt`1.#ctor(System.Collections.Generic.IEnumerator{`0},System.Func{System.Collections.Generic.IEnumerable{`0},`0})">
            <summary>
            First element in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> with a fallback function <see cref="T:System.Func`2"/>.
            </summary>
            <param name="src">source <see cref="T:System.Collections.Generic.IEnumerable`1"/></param>
            <param name="fallback">fallback function</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.ItemAt`1.#ctor(System.Collections.Generic.IEnumerator{`0},System.Func{System.Exception,System.Collections.Generic.IEnumerable{`0},`0})">
            <summary>
            First element in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> with a fallback function <see cref="T:System.Func`2"/>.
            </summary>
            <param name="src">source <see cref="T:System.Collections.Generic.IEnumerable`1"/></param>
            <param name="fallback">fallback function</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.ItemAt`1.#ctor(System.Collections.Generic.IEnumerator{`0},Yaapii.Atoms.IBiFunc{System.Exception,System.Collections.Generic.IEnumerable{`0},`0})">
            <summary>
            First element in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> with a fallback function <see cref="T:Yaapii.Atoms.IFunc`2"/>.
            </summary>
            <param name="src">source <see cref="T:System.Collections.Generic.IEnumerable`1"/></param>
            <param name="fallback">fallback function</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.ItemAt`1.#ctor(System.Collections.Generic.IEnumerator{`0},System.Int32)">
            <summary>
            Element at a position in a <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <param name="src">source <see cref="T:System.Collections.Generic.IEnumerable`1"/></param>
            <param name="pos">position</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.ItemAt`1.#ctor(System.Collections.Generic.IEnumerator{`0},System.Int32,Yaapii.Atoms.IBiFunc{System.Exception,System.Collections.Generic.IEnumerable{`0},`0})">
            <summary>
            Element at position in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> with a fallback function <see cref="T:Yaapii.Atoms.IFunc`2"/>.
            </summary>
            <param name="src">source <see cref="T:System.Collections.Generic.IEnumerable`1"/></param>
            <param name="fbk">fallback function</param>
            <param name="pos">position</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.ItemAt`1.Value">
            <summary>
            Get the item.
            </summary>
            <returns>the item</returns>
        </member>
        <member name="T:Yaapii.Atoms.Enumerator.Joined`1">
            <summary>
            Multiple <see cref="T:System.Collections.Generic.IEnumerator`1"/> joined together.
            </summary>
            <typeparam name="T">type of elements</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.Joined`1.#ctor(System.Collections.Generic.IEnumerator{`0}[])">
            <summary>
            Multiple <see cref="T:System.Collections.Generic.IEnumerator`1"/> joined together.
            </summary>
            <param name="items">enumerables to join together</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.Joined`1.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerator{`0}})">
            <summary>
            Multiple <see cref="T:System.Collections.Generic.IEnumerator`1"/> joined together.
            </summary>
            <param name="items">enumerables to join together</param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerator.LengthOf">
            <summary>
            Length of an <see cref="T:System.Collections.IEnumerator"/>
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.LengthOf.#ctor(System.Collections.IEnumerator)">
            <summary>
            Length of an <see cref="T:System.Collections.IEnumerator"/>
            </summary>
            <param name="items">enumerator to count</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.LengthOf.Value">
            <summary>
            Get the length.
            </summary>
            <returns>the length</returns>
        </member>
        <member name="T:Yaapii.Atoms.Enumerator.LiveLengthOf">
            <summary>
            Length of an <see cref="T:System.Collections.IEnumerator"/>
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.LiveLengthOf.#ctor(System.Collections.IEnumerator)">
            <summary>
            Length of an <see cref="T:System.Collections.IEnumerator"/>
            </summary>
            <param name="items">enumerator to count</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.LiveLengthOf.Value">
            <summary>
            Get the length.
            </summary>
            <returns>the length</returns>
        </member>
        <member name="T:Yaapii.Atoms.Enumerator.Mapped`2">
            <summary>
            Mapped content of an <see cref="T:System.Collections.Generic.IEnumerable`1"/> to another type using the given function.
            </summary>
            <typeparam name="In">type of items</typeparam>
            <typeparam name="Out">type of mapped items</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.Mapped`2.#ctor(System.Collections.Generic.IEnumerator{`0},Yaapii.Atoms.IFunc{`0,`1})">
            <summary>
            Mapped content of an <see cref="T:System.Collections.Generic.IEnumerable`1"/> to another type using the given <see cref="T:Yaapii.Atoms.IBiFunc`3"/> function with index.
            </summary>
            <param name="src">source enumerable</param>
            <param name="fnc">mapping function</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.Mapped`2.#ctor(System.Collections.Generic.IEnumerator{`0},System.Func{`0,`1})">
            <summary>
            Mapped content of an <see cref="T:System.Collections.Generic.IEnumerable`1"/> to another type using the given <see cref="T:System.Func`3"/> function with index.
            </summary>
            <param name="src">source enumerable</param>
            <param name="fnc">mapping function</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.Mapped`2.#ctor(System.Collections.Generic.IEnumerator{`0},Yaapii.Atoms.IBiFunc{`0,System.Int32,`1})">
            <summary>
            Mapped content of an <see cref="T:System.Collections.Generic.IEnumerable`1"/> to another type using the given <see cref="T:Yaapii.Atoms.IBiFunc`3"/> function with index.
            </summary>
            <param name="src">source enumerable</param>
            <param name="fnc">mapping function</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.Mapped`2.#ctor(System.Collections.Generic.IEnumerator{`0},System.Func{`0,System.Int32,`1})">
            <summary>
            Mapped content of an <see cref="T:System.Collections.Generic.IEnumerable`1"/> to another type using the given <see cref="T:System.Func`3"/> function with index.
            </summary>
            <param name="src">source enumerable</param>
            <param name="fnc">mapping function</param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerator.Partitioned`1">
            <summary>
            Partitiones an Enumerator by a given size
            <para>Is a IEnumerator</para>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.Partitioned`1.#ctor(System.Int32,System.Collections.Generic.IEnumerator{`0})">
            <summary>
            Partitiones an Enumerator by a given size
            </summary>
            <param name="size"></param>
            <param name="enumerator"></param>
        </member>
        <member name="P:Yaapii.Atoms.Enumerator.Partitioned`1.Current">
            <summary>
            Returns the current buffer value.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.Partitioned`1.MoveNext">
            <summary>
            Moves to the next object in the Enumerator
            </summary>
            <returns></returns>ma
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.Partitioned`1.Reset">
            <summary>
            Resets the enumerator as well as the control buffer.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Enumerator.Repeated`1">
            <summary>
            <see cref="T:System.Collections.Generic.IEnumerator`1"/> which repeats one value multiple times.
            </summary>
            <typeparam name="T">type of element to repeat</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.Repeated`1.#ctor(`0,System.Int32)">
            <summary>
            <see cref="T:System.Collections.Generic.IEnumerator`1"/> which repeats one value multiple times.
            </summary>
            <param name="elm">element to repeat</param>
            <param name="max">how often to repeat</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.Repeated`1.#ctor(Yaapii.Atoms.IScalar{`0},System.Int32)">
            <summary>
            <see cref="T:System.Collections.Generic.IEnumerator`1"/> which repeats one value multiple times.
            </summary>
            <param name="elm">element to repeat</param>
            <param name="max">how often to repeat</param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerator.Sibling`1">
            <summary>
            Element from position, starting with given item in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> fallback function <see cref="T:Yaapii.Atoms.IFunc`2"/>.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Yaapii.Atoms.Enumerator.Sibling`1.src">
            <summary>
            enumerator to get item from
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Enumerator.Sibling`1.fallback">
            <summary>
            fallback function for alternative value
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Enumerator.Sibling`1.pos">
            <summary>
            position of the item
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Enumerator.Sibling`1.needle">
            <summary>
            item to start with
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.Sibling`1.#ctor(System.Collections.Generic.IEnumerator{`0},`0,`0)">
            <summary>
            Right neighbour of a given item with a fallback value.
            </summary>
            <param name="src">the enumerator</param>
            <param name="item">the item to start with</param>
            <param name="fallback">the fallback to return if fails</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.Sibling`1.#ctor(System.Collections.Generic.IEnumerator{`0},`0,System.Int32,`0)">
            <summary>
            Right neighbour of a given item with a fallback value.
            </summary>
            <param name="src">the enumerator</param>
            <param name="item">the item to start with</param>
            <param name="pos">position of the neighbour</param>
            <param name="fallback">the fallback to return if fails</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.Sibling`1.#ctor(System.Collections.Generic.IEnumerator{`0},`0,System.Int32)">
            <summary>
            Element at a position in a <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <param name="src">source <see cref="T:System.Collections.Generic.IEnumerable`1"/></param>
            <param name="pos">position</param>
            <param name="item">item to start with</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.Sibling`1.#ctor(System.Collections.Generic.IEnumerator{`0},`0,System.Int32,Yaapii.Atoms.IFunc{System.Collections.Generic.IEnumerable{`0},`0})">
            <summary>
            Element at position in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> with a fallback function <see cref="T:Yaapii.Atoms.IFunc`2"/>.
            </summary>
            <param name="src">source <see cref="T:System.Collections.Generic.IEnumerable`1"/></param>
            <param name="fbk">fallback function</param>
            <param name="pos">position</param>
            <param name="item">item to start with</param>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.Sibling`1.Value">
            <summary>
            Get the item.
            </summary>
            <returns>the item</returns>
        </member>
        <member name="T:Yaapii.Atoms.Enumerator.Skipped`1">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> which skips a given count of items.
            </summary>
            <typeparam name="T">type of items in enumerable</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.Skipped`1.#ctor(System.Collections.Generic.IEnumerator{`0},System.Int32)">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> which skips a given count of items.
            </summary>
            <param name="enumerator"><see cref="T:System.Collections.Generic.IEnumerator`1"/> to skip items in</param>
            <param name="skip">how many to skip</param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerator.Sorted`1">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> sorted by the given <see cref="T:System.Collections.Generic.Comparer`1"/>.
            </summary>
            <typeparam name="T">type of items in enumertor</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.Sorted`1.#ctor(System.Collections.Generic.Comparer{`0},System.Collections.Generic.IEnumerator{`0})">
            <summary>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> sorted by the given <see cref="T:System.Collections.Generic.Comparer`1"/>.
            </summary>
            <param name="cmp">comparer</param>
            <param name="src">enumerator to sort</param>
        </member>
        <member name="T:Yaapii.Atoms.Enumerator.Sticky`1">
            <summary>
            An enumerator which is sticky. 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.Sticky`1.#ctor(System.Collections.Generic.IEnumerator{`0})">
            In order to allow enumerables to not pre-compute/copy all elements,
            this ctor allows injecting and therefore re-using the caching elements.
            An enumerable like <see cref="T:Yaapii.Atoms.Enumerable.ManyEnvelope"/> can then issue multiple 
            Enumerators while the same cache is filled when advancing them.
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.Sticky`1.#ctor(System.Func{System.Collections.Generic.IEnumerator{`0}})">
            In order to allow enumerables to not pre-compute/copy all elements,
            this ctor allows injecting and therefore re-using the caching elements.
            An enumerable like <see cref="T:Yaapii.Atoms.Enumerable.ManyEnvelope"/> can then issue multiple 
            Enumerators while the same cache is filled when advancing them.
        </member>
        <member name="M:Yaapii.Atoms.Enumerator.Sticky`1.#ctor(System.Collections.Generic.IDictionary{System.Int32,`0})">
            In order to allow enumerables to not pre-compute/copy all elements,
            this ctor allows injecting and therefore re-using the caching elements.
            An enumerable like <see cref="T:Yaapii.Atoms.Enumerable.ManyEnvelope"/> can then issue multiple 
            Enumerators while the same cache is filled when advancing them.
        </member>
        <member name="T:Yaapii.Atoms.Enumerator.Sticky`1.Cache`1">
            <summary>
            A cache for the enumerator, realized as map.
            When asking for a key, the enumerator will be advanced until the 
            position, if existing, is found.
            All values which are visited will be cached.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Error.FailAlways">
            <summary>
            Fail always with the given message.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailAlways.#ctor(System.String)">
            <summary>
            Fail always with <see cref="T:System.Exception"/> with the given message.
            </summary>
            <param name="msg">message to wrap in exception</param>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailAlways.#ctor(Yaapii.Atoms.IText)">
            <summary>
            Fail always with <see cref="T:System.Exception"/> with the given message.
            </summary>
            <param name="msg">message to wrap in exception</param>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailAlways.#ctor(System.Exception)">
            <summary>
            Fail always with specified exception with the given message.
            </summary>
            <param name="error">ex to throw</param>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailAlways.#ctor(System.Func{System.Exception})">
            <summary>
            Fail always with specified exception with the given message.
            </summary>
            <param name="error">ex to throw</param>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailAlways.Go">
            <summary>
            Fail if necessary.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Error.FailEmpty`1">
            <summary>
            Fail if enum is empty.
            </summary>
            <typeparam name="T">type of enum</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailEmpty`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Fail with <see cref="T:System.Exception"/> if enum is empty.
            </summary>
            <param name="enumerable">enum to check</param>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailEmpty`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.String)">
            <summary>
            Fail with <see cref="T:System.Exception"/> if enum is empty.
            </summary>
            <param name="enumerable">enum to check</param>
            <param name="hint">msg to display in exception</param>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailEmpty`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Exception)">
            <summary>
            Fail with specified exception if enum is empty.
            </summary>
            <param name="enumerable">enum to check</param>
            <param name="ex">specific exception which will be thrown</param>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailEmpty`1.Go">
            <summary>
            Fail if necessary.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Error.FailNoNumber">
            <summary>
            Fail if is not a number.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailNoNumber.#ctor(System.String)">
            <summary>
            Fail with <see cref="T:System.ArgumentNullException"/> if is not a number.
            </summary>
            <param name="value">string to check</param>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailNoNumber.#ctor(System.String,System.String)">
            <summary>
            Fail with <see cref="T:System.ArgumentNullException"/> if is not a number.
            </summary>
            <param name="value">string to check</param>
            <param name="hint">msg to throw in exception</param>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailNoNumber.#ctor(System.String,System.Exception)">
            <summary>
            Fail with specified exception if is not a number.
            </summary>
            <param name="value">string to check</param>
            <param name="ex">specific exception which will be thrown</param>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailNoNumber.Go">
            <summary>
            Fail if necessary.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Error.FailNotNull">
            <summary>
            Fail if object is not null.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailNotNull.#ctor(System.Object)">
            <summary>
            Fail with <see cref="T:System.ArgumentException"/> if object is not null.
            </summary>
            <param name="obj">object to check</param>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailNotNull.#ctor(System.Object,System.String)">
            <summary>
            Fail with <see cref="T:System.ArgumentException"/> if object is not null.
            </summary>
            <param name="obj">object to check</param>
            <param name="hint">msg to display</param>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailNotNull.#ctor(System.Object,System.Exception)">
            <summary>
            Fail with specified exception if object is not null.
            </summary>
            <param name="obj">object to check</param>
            <param name="ex">specific exception which will be thrown</param>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailNotNull.Go">
            <summary>
            Fail if necessary.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Error.FailNull">
            <summary>
            Fail if object is null.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailNull.#ctor(System.Object)">
            <summary>
            Fail with <see cref="T:System.ArgumentNullException"/> if object is null.
            </summary>
            <param name="obj">object to check</param>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailNull.#ctor(System.Object,System.String)">
            <summary>
            Fail with <see cref="T:System.ArgumentNullException"/> if object is null.
            </summary>
            <param name="obj">object to check</param>
            <param name="hint">msg to put in exception</param>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailNull.#ctor(System.Object,System.Exception)">
            <summary>
            Fail with specified exception if object is null.
            </summary>
            <param name="obj">object to check</param>
            <param name="ex">specific exception which will be thrown</param>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailNull.Go">
            <summary>
            Fail if necessary.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Error.FailNullOrEmpty">
            <summary>
            Fail if object is null or empty.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailNullOrEmpty.#ctor(System.String)">
            <summary>
            Fail with <see cref="T:System.ArgumentNullException"/> if object is null or empty.
            </summary>
            <param name="str">string to check</param>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailNullOrEmpty.#ctor(System.String,System.String)">
            <summary>
            Fail with <see cref="T:System.ArgumentNullException"/> if object is null or empty.
            </summary>
            <param name="str">string to check</param>
            <param name="hint">msg to display in exception</param>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailNullOrEmpty.#ctor(System.String,System.Exception)">
            <summary>
            Fail with specified exception if object is null or empty.
            </summary>
            <param name="str">string to check</param>
            <param name="ex">specific exception which will be thrown</param>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailNullOrEmpty.Go">
            <summary>
            Fail if necessary.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Error.FailPrecise">
            <summary>
            Fail with changed exception.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailPrecise.#ctor(Yaapii.Atoms.IFail,System.Exception)">
            <summary>
            Decorates a Failing by replacing the thrown Exception with the injected one
            </summary>
            <param name="origin">The Failing to decorate</param>
            <param name="precision">The new Exception to throw when necessary</param>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailPrecise.Go">
            <summary>
            Fail if necessary.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Error.FailWhen">
            <summary>
            Fail if condition is matched.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailWhen.#ctor(System.Boolean)">
            <summary>
            Fail with <see cref="T:System.ArgumentException"/> if condition is matched.
            </summary>
            <param name="condition">condition to apply</param>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailWhen.#ctor(System.Boolean,System.String)">
            <summary>
            Fail with <see cref="T:System.ArgumentException"/> if condition is matched.
            </summary>
            <param name="condition">condition to apply</param>
            <param name="hint">msg to put in exception</param>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailWhen.#ctor(System.Boolean,System.Exception)">
            <summary>
            Fail with <see cref="T:System.ArgumentException"/> if condition is matched.
            </summary>
            <param name="condition">condition to apply</param>
            <param name="ex">specific exception which will be thrown</param>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailWhen.#ctor(System.Func{System.Boolean})">
            <summary>
            Fail if condition is matched.
            </summary>
            <param name="condition">condition to apply</param>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailWhen.#ctor(System.Func{System.Boolean},System.String)">
            <summary>
            Fail with <see cref="T:System.ArgumentException"/> if condition is matched.
            </summary>
            <param name="condition">condition to apply</param>
            <param name="hint">msg to put in exception</param>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailWhen.#ctor(System.Func{System.Boolean},System.Exception)">
            <summary>
            Fail with specified exception if condition is matched.
            </summary>
            <param name="condition">condition to apply</param>
            <param name="ex">specific exception which will be thrown</param>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailWhen.Go">
            <summary>
            Fail if necessary.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Error.FailZero">
            <summary>
            Fail if number is 0.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailZero.#ctor(System.Int64)">
            <summary>
            Fail with <see cref="T:System.Exception"/> if number is 0.
            </summary>
            <param name="number">number to check</param>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailZero.#ctor(System.Int64,System.String)">
            <summary>
            Fail with <see cref="T:System.Exception"/> if number is 0.
            </summary>
            <param name="number">number to check</param>
            <param name="hint">msg to put in exception</param>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailZero.#ctor(System.Int64,System.Exception)">
            <summary>
            Fail with specified exception if number is 0.
            </summary>
            <param name="number">number to check</param>
            <param name="ex">specific exception which will be thrown</param>
        </member>
        <member name="M:Yaapii.Atoms.Error.FailZero.Go">
            <summary>
            Fail if necessary.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Fail.NoSuchElementException">
            <summary>
            Exception to occur when a requested element can't be found.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Fail.NoSuchElementException.#ctor(System.String)">
            <summary>
            Exception to occur when a requested element can't be found.
            </summary>
            <param name="message">message to display</param>
        </member>
        <member name="T:Yaapii.Atoms.Fail.UnsupportedOperationException">
            <summary>
            exception to occur when a requested operation is not supported
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Fail.UnsupportedOperationException.#ctor(System.String)">
            <summary>
            An exception to throw when operation is unsupported.
            </summary>
            <param name="message">message to put in the exception</param>
        </member>
        <member name="T:Yaapii.Atoms.Func.ActionOf">
            <summary>
            Action with input but no output as runnable.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Func.ActionOf.#ctor(System.Action)">
            <summary>
            Action with input but no output as runnable.
            </summary>
            <param name="fnc"></param>
        </member>
        <member name="M:Yaapii.Atoms.Func.ActionOf.Invoke">
            <summary>
            Run the runnable.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Func.ActionOf`1">
            <summary>
            Action<typeparamref name="In"/> as IAction<typeparamref name="In"/>
            </summary>
            <typeparam name="In"></typeparam>
        </member>
        <member name="F:Yaapii.Atoms.Func.ActionOf`1._func">
            <summary>
            the action
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Func.ActionOf`1.#ctor(System.Action)">
            <summary>
            ctor
            </summary>
            <param name="action">action to execute</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.ActionOf`1.#ctor(System.Action{`0})">
            <summary>
            ctor
            </summary>
            <param name="fnc">action to execute</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.ActionOf`1.Invoke(`0)">
            <summary>
            Execute the action.
            </summary>
            <param name="input">input argument</param>
        </member>
        <member name="T:Yaapii.Atoms.Func.ActionWithFallback">
            <summary>
            A action that executes a fallback if it fails (= an <see cref="T:System.Exception"/> occurs).
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Func.ActionWithFallback.func">
            <summary>
            Action to call.
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Func.ActionWithFallback.fallback">
            <summary>
            Fallback to call when the action fails.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Func.ActionWithFallback.#ctor(Yaapii.Atoms.IAction,System.Action{System.Exception})">
            <summary>
            A Action that executes a callback if it fails (= an <see cref="T:System.Exception"/> occurs).
            </summary>
            <param name="fnc">Action to call</param>
            <param name="fbk">Fallback action</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.ActionWithFallback.#ctor(System.Action,Yaapii.Atoms.IAction{System.Exception})">
            <summary>
            A Action that executes a callback if it fails (= an <see cref="T:System.Exception"/> occurs).
            </summary>
            <param name="fnc">Action to call</param>
            <param name="fbk">Fallback action</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.ActionWithFallback.#ctor(System.Action,System.Action{System.Exception})">
            <summary>
            A Action that executes a callback if it fails (= an <see cref="T:System.Exception"/> occurs).
            </summary>
            <param name="fnc">Action to call</param>
            <param name="fbk">Fallback action</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.ActionWithFallback.#ctor(Yaapii.Atoms.IAction,Yaapii.Atoms.IAction{System.Exception})">
            <summary>
            A Action that executes a callback if it fails (= an <see cref="T:System.Exception"/> occurs).
            </summary>
            <param name="fnc">Action to call</param>
            <param name="fbk">Fallback action</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.ActionWithFallback.Invoke">
            <summary>
            Invoke action.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Func.ActionWithFallback`1">
            <summary>
            A Action with input that executes a callback if it fails (= an <see cref="T:System.Exception"/> occurs).
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Func.ActionWithFallback`1._func">
            <summary>
            Action to call.
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Func.ActionWithFallback`1._fallback">
            <summary>
            Fallback to call when the action falis.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Func.ActionWithFallback`1.#ctor(Yaapii.Atoms.IAction{`0},System.Action{System.Exception})">
            <summary>
            A Action with input that executes a callback if it fails (= an <see cref="T:System.Exception"/> occurs).
            </summary>
            <param name="fnc">Action to call</param>
            <param name="fbk">Fallback action</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.ActionWithFallback`1.#ctor(System.Action,Yaapii.Atoms.IAction{System.Exception})">
            <summary>
            A Action with input that executes a callback if it fails (= an <see cref="T:System.Exception"/> occurs).
            </summary>
            <param name="fnc">Action to call</param>
            <param name="fbk">Fallback action</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.ActionWithFallback`1.#ctor(System.Action{`0},System.Action{System.Exception})">
            <summary>
            A Action with input that executes a callback if it fails (= an <see cref="T:System.Exception"/> occurs).
            </summary>
            <param name="fnc">Action to call</param>
            <param name="fbk">Fallback action</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.ActionWithFallback`1.#ctor(Yaapii.Atoms.IAction{`0},Yaapii.Atoms.IAction{System.Exception})">
            <summary>
            A Action with input that executes a callback if it fails (= an <see cref="T:System.Exception"/> occurs).
            </summary>
            <param name="fnc">Action to call</param>
            <param name="fbk">Fallback action</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.ActionWithFallback`1.Invoke(`0)">
            <summary>
            Invoke action.
            </summary>
            <param name="input">The input parameter</param>
        </member>
        <member name="T:Yaapii.Atoms.Func.AsyncFunc`2">
            <summary>
            Func that runs in the background.
            If you want your piece of code to be executed in the background, use
            <see cref="T:Yaapii.Atoms.Func.AsyncFunc`2"/> as following:
            int length = new AsyncFunc(
                input => input.length()
            ).Apply("Hello, world!").Length;
            </summary>
            <typeparam name="In">type of input</typeparam>
            <typeparam name="Out">type of output</typeparam>
        </member>
        <member name="F:Yaapii.Atoms.Func.AsyncFunc`2._func">
            <summary>
            func to call
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Func.AsyncFunc`2.#ctor(Yaapii.Atoms.IAction{`0})">
            <summary>
            Func that runs in the background.
            </summary>
            <param name="proc">procedure to call</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.AsyncFunc`2.#ctor(System.Func{`0,`1})">
            <summary>
            Func that runs in the background.
            If you want your piece of code to be executed in the background, use
            <see cref="T:Yaapii.Atoms.Func.AsyncFunc`2"/> as following:
            int length = new AsyncFunc(
                input => input.length()
            ).Apply("Hello, world!").Length;
            </summary>
            <param name="func">func to call</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.AsyncFunc`2.#ctor(Yaapii.Atoms.IFunc{`0,`1})">
            <summary>
            Func that runs in the background.
            If you want your piece of code to be executed in the background, use
            <see cref="T:Yaapii.Atoms.Func.AsyncFunc`2"/> as following:
            int length = new AsyncFunc(
                input => input.length()
            ).Apply("Hello, world!").Length;
            </summary>
            <param name="fnc">func to call</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.AsyncFunc`2.Invoke(`0)">
            <summary>
            Invoke the function and retrieve the output.
            </summary>
            <param name="input">the input argument</param>
            <returns>the output</returns>
        </member>
        <member name="T:Yaapii.Atoms.Func.BiFuncOf`3">
            <summary>
            Function that has two inputs and an output
            </summary>
            <typeparam name="In1">type of first input</typeparam>
            <typeparam name="In2">type of second input</typeparam>
            <typeparam name="Out">type of output</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Func.BiFuncOf`3.#ctor(System.Func{`0,`1,`2})">
            <summary>
            Function that has two inputs and an output.
            </summary>
            <param name="func"></param>
        </member>
        <member name="M:Yaapii.Atoms.Func.BiFuncOf`3.Invoke(`0,`1)">
            <summary>
            Invoke the function with arguments and retrieve th output.
            </summary>
            <param name="arg1">first argument</param>
            <param name="arg2">second argument</param>
            <returns>the output</returns>
        </member>
        <member name="T:Yaapii.Atoms.Func.BiFuncWithFallback`3">
            <summary>
            A bi-function that executes a callback if it fails (= an <see cref="T:System.Exception"/> occurs).
            </summary>
            <typeparam name="In1">First argument type</typeparam>
            <typeparam name="In2">Second argument type</typeparam>
            <typeparam name="Out">Return type</typeparam>
        </member>
        <member name="F:Yaapii.Atoms.Func.BiFuncWithFallback`3._func">
            <summary>
            Func to call
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Func.BiFuncWithFallback`3._fallback">
            <summary>
            Fallback to call wehen func fails
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Func.BiFuncWithFallback`3._follow">
            <summary>
            A follow function
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Func.BiFuncWithFallback`3.#ctor(System.Func{`0,`1,`2},System.Func{System.Exception,`2})">
            <summary>
            A bi-function that executes a callback if it fails (= an <see cref="T:System.Exception"/> occurs).
            </summary>
            <param name="fnc">Func to call</param>
            <param name="fbk">Fallback func</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.BiFuncWithFallback`3.#ctor(System.Func{`0,`1,`2},Yaapii.Atoms.IFunc{System.Exception,`2})">
            <summary>
            A bi-function that executes a callback if it fails (= an <see cref="T:System.Exception"/> occurs).
            </summary>
            <param name="fnc">Func to call</param>
            <param name="fbk">Fallback func</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.BiFuncWithFallback`3.#ctor(System.Func{`0,`1,`2},System.Func{System.Exception,`2},Yaapii.Atoms.IFunc{`2,`2})">
            <summary>
            A bi-function that executes a callback if it fails (= an <see cref="T:System.Exception"/> occurs).
            </summary>
            <param name="fnc">Func to call</param>
            <param name="fbk">Fallback func</param>
            <param name="flw">Func to call aferwards</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.BiFuncWithFallback`3.#ctor(System.Func{`0,`1,`2},Yaapii.Atoms.IFunc{System.Exception,`2},System.Func{`2,`2})">
            <summary>
            A bi-function that executes a callback if it fails (= an <see cref="T:System.Exception"/> occurs).
            </summary>
            <param name="fnc">Func to call</param>
            <param name="fbk">Fallback func</param>
            <param name="flw">Func to call aferwards</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.BiFuncWithFallback`3.#ctor(System.Func{`0,`1,`2},System.Func{System.Exception,`2},System.Func{`2,`2})">
            <summary>
            A bi-function that executes a callback if it fails (= an <see cref="T:System.Exception"/> occurs).
            </summary>
            <param name="fnc">Func to call</param>
            <param name="fbk">Fallback func</param>
            <param name="flw">Func to call aferwards</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.BiFuncWithFallback`3.#ctor(System.Func{`0,`1,`2},Yaapii.Atoms.IFunc{System.Exception,`2},Yaapii.Atoms.IFunc{`2,`2})">
            <summary>
            A bi-function that executes a callback if it fails (= an <see cref="T:System.Exception"/> occurs).
            </summary>
            <param name="fnc">Func to call</param>
            <param name="fbk">Fallback func</param>
            <param name="flw">Func to call aferwards</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.BiFuncWithFallback`3.Invoke(`0,`1)">
            <summary>
            Invoke bi-function with input and retrieve output.
            </summary>
            <param name="first">First input argument</param>
            <param name="second">Second input argument</param>
            <returns>The reault</returns>
        </member>
        <member name="T:Yaapii.Atoms.Func.BowAction">
            <summary>
            An action which waits for a trigger to return true before executing.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Func.BowAction.#ctor(System.Func{System.Boolean},System.Action)">
            <summary>
            An action which waits for a trigger to return true before executing.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Func.BowAction.#ctor(System.Func{System.Boolean},System.Action,System.TimeSpan)">
            <summary>
            An action which waits for a trigger to return true before executing.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Func.BowAction.#ctor(System.Func{System.Boolean},System.Action,System.Action)">
            <summary>
            An action which waits for a trigger to return true before executing.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Func.BowAction.#ctor(System.Func{System.Boolean},System.Collections.Generic.IDictionary{System.String,System.Action},System.Collections.Generic.IDictionary{System.String,System.TimeSpan})">
            <summary>
            An action which waits for a trigger to return true before executing.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Func.BowFunc`1">
            <summary>
            An Function which waits for a trigger to return true before executing.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Func.BowFunc`1.#ctor(System.Func{System.Boolean},System.Action{`0})">
            <summary>
            A Function which waits for a trigger to return true before executing.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Func.BowFunc`1.#ctor(System.Func{System.Boolean},System.Action,System.Action{`0},System.TimeSpan)">
            <summary>
            A Function which waits for a trigger to return true before executing.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Func.BowFunc`1.#ctor(System.Func{System.Boolean},System.Action,System.Action{`0},System.TimeSpan,System.TimeSpan)">
            <summary>
            A Function which waits for a trigger to return true before executing.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Func.BowFunc`1.#ctor(System.Func{System.Boolean},System.Action,System.Action{`0},System.Collections.Generic.IDictionary{System.String,System.TimeSpan})">
            <summary>
            A Function which waits for a trigger to return true before executing.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Func.ChainedFunc`3">
            <summary>
            Chains functions together.
            </summary>
            <typeparam name="In"></typeparam>
            <typeparam name="Between"></typeparam>
            <typeparam name="Out"></typeparam>
        </member>
        <member name="F:Yaapii.Atoms.Func.ChainedFunc`3._before">
            <summary>
            first function
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Func.ChainedFunc`3._funcs">
            <summary>
            chained functions
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Func.ChainedFunc`3._after">
            <summary>
            last function
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Func.ChainedFunc`3.#ctor(System.Func{`0,`1},System.Func{`1,`2})">
            <summary>
            Chains functions together.
            </summary>
            <param name="before">first function</param>
            <param name="after">last function</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.ChainedFunc`3.#ctor(Yaapii.Atoms.IFunc{`0,`1},Yaapii.Atoms.IFunc{`1,`2})">
            <summary>
            ctor
            </summary>
            <param name="before">first function</param>
            <param name="after">last function</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.ChainedFunc`3.#ctor(System.Func{`0,`1},System.Collections.Generic.IEnumerable{Yaapii.Atoms.IFunc{`1,`1}},System.Func{`1,`2})">
            <summary>
            ctor
            </summary>
            <param name="before">first function</param>
            <param name="funcs">functions to chain</param>
            <param name="after">last function</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.ChainedFunc`3.#ctor(System.Func{`0,`1},System.Collections.Generic.IEnumerable{System.Func{`1,`1}},System.Func{`1,`2})">
            <summary>
            ctor
            </summary>
            <param name="before">first function</param>
            <param name="funcs">functions to chain</param>
            <param name="after">last function</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.ChainedFunc`3.#ctor(Yaapii.Atoms.IFunc{`0,`1},System.Collections.Generic.IEnumerable{Yaapii.Atoms.IFunc{`1,`1}},Yaapii.Atoms.IFunc{`1,`2})">
            <summary>
            ctor
            </summary>
            <param name="before">first function</param>
            <param name="funcs">functions to chain</param>
            <param name="after">last function</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.ChainedFunc`3.Invoke(`0)">
            <summary>
            applys input to the chain
            </summary>
            <param name="input">input to apply</param>
            <returns>output</returns>
        </member>
        <member name="T:Yaapii.Atoms.Func.FuncOf`1">
            <summary>
            Function that has only output.
            </summary>
            <typeparam name="Out">type of output</typeparam>
        </member>
        <member name="F:Yaapii.Atoms.Func.FuncOf`1._func">
            <summary>
            func that will be called
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Func.FuncOf`1.#ctor(System.Func{`0})">
            <summary>
            Function that has only output.
            </summary>
            <param name="fnc">func to call</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.FuncOf`1.Invoke">
            <summary>
            Call function and retrieve output.
            </summary>
            <returns>the output</returns>
        </member>
        <member name="T:Yaapii.Atoms.Func.FuncOf`2">
            <summary>
            Function that has input and output
            </summary>
            <typeparam name="In">input</typeparam>
            <typeparam name="Out">output</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Func.FuncOf`2.#ctor(System.Func{`1})">
            <summary>
            ctor
            </summary>
            <param name="fnc"></param>
        </member>
        <member name="M:Yaapii.Atoms.Func.FuncOf`2.#ctor(Yaapii.Atoms.IAction{`0},`1)">
            <summary>
            Function that has input and output
            </summary>
            <param name="proc">procedure to execute</param>
            <param name="result"></param>
        </member>
        <member name="M:Yaapii.Atoms.Func.FuncOf`2.#ctor(System.Func{`0,`1})">
            <summary>
            Function that has input and output
            </summary>
            <param name="func">function to execute</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.FuncOf`2.Invoke(`0)">
            <summary>
            Generate the Output from the input
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="T:Yaapii.Atoms.Func.FuncWithFallback`2">
            <summary>
            A function that executes a callback if it fails (= an <see cref="T:System.Exception"/> occurs).
            </summary>
            <typeparam name="In"></typeparam>
            <typeparam name="Out"></typeparam>
        </member>
        <member name="F:Yaapii.Atoms.Func.FuncWithFallback`2._func">
            <summary>
            func to call
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Func.FuncWithFallback`2._fallback">
            <summary>
            fallback to call when necessary
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Func.FuncWithFallback`2._follow">
            <summary>
            a followup function
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Func.FuncWithFallback`2.#ctor(System.Func{`0,`1},System.Func{System.Exception,`1})">
            <summary>
            A function that executes a callback if it fails (= an <see cref="T:System.Exception"/> occurs).
            </summary>
            <param name="func">func to call</param>
            <param name="fallback">fallback func</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.FuncWithFallback`2.#ctor(System.Func{`0,`1},Yaapii.Atoms.IFunc{System.Exception,`1})">
            <summary>
            A function that executes a callback if it fails (= an <see cref="T:System.Exception"/> occurs).
            </summary>
            <param name="func">func to call</param>
            <param name="fallback">fallback func</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.FuncWithFallback`2.#ctor(Yaapii.Atoms.IFunc{`0,`1},Yaapii.Atoms.IFunc{System.Exception,`1})">
            <summary>
            A function that executes a callback if it fails (= an <see cref="T:System.Exception"/> occurs).
            </summary>
            <param name="fnc">func to call</param>
            <param name="fbk">fallback func</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.FuncWithFallback`2.#ctor(System.Func{`0,`1},System.Func{System.Exception,`1},System.Func{`1,`1})">
            <summary>
            A function that executes a callback if it fails (= an <see cref="T:System.Exception"/> occurs).
            </summary>
            <param name="func">func to call</param>
            <param name="fallback">fallback func</param>
            <param name="flw">func to call afterwards</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.FuncWithFallback`2.#ctor(Yaapii.Atoms.IFunc{`0,`1},Yaapii.Atoms.IFunc{System.Exception,`1},Yaapii.Atoms.IFunc{`1,`1})">
            <summary>
            A function that executes a callback if it fails (= an <see cref="T:System.Exception"/> occurs).
            </summary>
            <param name="fnc">func to call</param>
            <param name="fbk">fallback func</param>
            <param name="flw">func to call afterwards</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.FuncWithFallback`2.Invoke(`0)">
            <summary>
            invoke function with input and retrieve output.
            </summary>
            <param name="input">input argument</param>
            <returns>the result</returns>
        </member>
        <member name="T:Yaapii.Atoms.Func.FuncWithFallback`1">
            <summary>
            A function that executes a callback if it fails (= an <see cref="T:System.Exception"/> occurs).
            </summary>
            <typeparam name="Out">Return type</typeparam>
        </member>
        <member name="F:Yaapii.Atoms.Func.FuncWithFallback`1._func">
            <summary>
            func to call
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Func.FuncWithFallback`1._fallback">
            <summary>
            fallback to call when necessary
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Func.FuncWithFallback`1._follow">
            <summary>
            a followup function
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Func.FuncWithFallback`1.#ctor(System.Func{`0},System.Func{System.Exception,`0})">
            <summary>
            A function that executes a callback if it fails (= an <see cref="T:System.Exception"/> occurs).
            </summary>
            <param name="func">func to call</param>
            <param name="fallback">fallback func</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.FuncWithFallback`1.#ctor(System.Func{`0},Yaapii.Atoms.IFunc{System.Exception,`0})">
            <summary>
            A function that executes a callback if it fails (= an <see cref="T:System.Exception"/> occurs).
            </summary>
            <param name="func">func to call</param>
            <param name="fallback">fallback func</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.FuncWithFallback`1.#ctor(Yaapii.Atoms.IFunc{`0},Yaapii.Atoms.IFunc{System.Exception,`0})">
            <summary>
            A function that executes a callback if it fails (= an <see cref="T:System.Exception"/> occurs).
            </summary>
            <param name="fnc">func to call</param>
            <param name="fbk">fallback func</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.FuncWithFallback`1.#ctor(System.Func{`0},System.Func{System.Exception,`0},System.Func{`0,`0})">
            <summary>
            A function that executes a callback if it fails (= an <see cref="T:System.Exception"/> occurs).
            </summary>
            <param name="func">func to call</param>
            <param name="fallback">fallback func</param>
            <param name="flw">func to call afterwards</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.FuncWithFallback`1.#ctor(Yaapii.Atoms.IFunc{`0},Yaapii.Atoms.IFunc{System.Exception,`0},Yaapii.Atoms.IFunc{`0,`0})">
            <summary>
            A function that executes a callback if it fails (= an <see cref="T:System.Exception"/> occurs).
            </summary>
            <param name="fnc">func to call</param>
            <param name="fbk">fallback func</param>
            <param name="flw">func to call afterwards</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.FuncWithFallback`1.Invoke">
            <summary>
            Get output
            </summary>
            <returns></returns>
        </member>
        <member name="T:Yaapii.Atoms.Func.NoNullsFunc`2">
            <summary>
            Function that does not allow null as input.
            </summary>
            <typeparam name="In">type of input</typeparam>
            <typeparam name="Out">type of output</typeparam>
        </member>
        <member name="F:Yaapii.Atoms.Func.NoNullsFunc`2._func">
            <summary>
            The function
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Func.NoNullsFunc`2.#ctor(Yaapii.Atoms.IFunc{`0,`1})">
            <summary>
            Function that does not allow null as input.
            </summary>
            <param name="func">the function</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.NoNullsFunc`2.Invoke(`0)">
            <summary>
            Apply it
            </summary>
            <param name="input">input</param>
            <returns>the output</returns>
        </member>
        <member name="T:Yaapii.Atoms.Func.NoNullsFunc`1">
            <summary>
            Check whether a func returns null. React with Exception or fallback value / function.
            </summary>
            <typeparam name="Out">The type of output</typeparam>
        </member>
        <member name="F:Yaapii.Atoms.Func.NoNullsFunc`1._fnc">
            <summary>
            fnc to call
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Func.NoNullsFunc`1._fbk">
            <summary>
            error to raise
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Func.NoNullsFunc`1.#ctor(System.Func{`0})">
            <summary>
            Raises an <see cref="T:System.IO.IOException"/> when the return value is null.
            </summary>
            <param name="fnc">func to check</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.NoNullsFunc`1.#ctor(Yaapii.Atoms.IFunc{`0})">
            <summary>
            Raises an <see cref="T:System.IO.IOException"/> when the return value is null.
            </summary>
            <param name="fnc">func to check</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.NoNullsFunc`1.#ctor(System.Func{`0},System.Exception)">
            <summary>
            Raises given <see cref="T:System.Exception"/> when the return value is null.
            </summary>
            <param name="fnc">func to check</param>
            <param name="ex">Exception to throw</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.NoNullsFunc`1.#ctor(Yaapii.Atoms.IFunc{`0},System.Exception)">
            <summary>
            Raises given <see cref="T:System.Exception"/> when the return value is null.
            </summary>
            <param name="fnc">func to check</param>
            <param name="ex">Exception to throw</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.NoNullsFunc`1.#ctor(System.Func{`0},`0)">
            <summary>
            Returns the fallback if the func returns null.
            </summary>
            <param name="fnc">func to check</param>
            <param name="fallback">fallback value</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.NoNullsFunc`1.#ctor(Yaapii.Atoms.IFunc{`0},`0)">
            <summary>
            Returns the fallback if the func returns null.
            </summary>
            <param name="fnc">func to check</param>
            <param name="fallback">fallback value</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.NoNullsFunc`1.#ctor(System.Func{`0},System.Func{`0})">
            <summary>
            Calls the fallback function if the func return null.
            </summary>
            <param name="fnc">func to check</param>
            <param name="fallback">fallback value</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.NoNullsFunc`1.#ctor(Yaapii.Atoms.IFunc{`0},Yaapii.Atoms.IFunc{`0})">
            <summary>
            Calls the fallback function if the func return null.
            </summary>
            <param name="fnc">func to check</param>
            <param name="fallback">fallback value</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.NoNullsFunc`1.Invoke">
            <summary>
            Call the function to get the value
            </summary>
            <returns>The value or the fallback value (if any)</returns>
        </member>
        <member name="T:Yaapii.Atoms.Func.RepeatedFunc`2">
            <summary>
            Function that repeats its calculation a few times before returning the result.
            </summary>
            <typeparam name="In">type of input</typeparam>
            <typeparam name="Out">type of output</typeparam>
        </member>
        <member name="F:Yaapii.Atoms.Func.RepeatedFunc`2._func">
            <summary>
            function to call
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Func.RepeatedFunc`2._times">
            <summary>
            how often to run
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Func.RepeatedFunc`2.#ctor(System.Func{`0,`1},System.Int32)">
            <summary>
            Function that repeats its calculation a few times before returning the result.
            </summary>
            <param name="fnc">function to call</param>
            <param name="max">how often it repeats</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.RepeatedFunc`2.#ctor(Yaapii.Atoms.IFunc{`0,`1},System.Int32)">
            <summary>
            Function that repeats its calculation a few times before returning the result.
            </summary>
            <param name="fnc">function to call</param>
            <param name="max">how often it repeats</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.RepeatedFunc`2.Invoke(`0)">
            <summary>
            Invoke the function and retrieve the output.
            </summary>
            <param name="input">the input argument</param>
            <returns>the output</returns>
        </member>
        <member name="T:Yaapii.Atoms.Func.RetryFunc`2">
            <summary>
            Function that will retry if it fails.
            </summary>
            <typeparam name="In">type of input</typeparam>
            <typeparam name="Out">type of output</typeparam>
        </member>
        <member name="F:Yaapii.Atoms.Func.RetryFunc`2._func">
            <summary>
            func to retry
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Func.RetryFunc`2._exit">
            <summary>
            exit condition
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Func.RetryFunc`2.#ctor(System.Func{`0,`1})">
            <summary>
            Function that will retry if it fails.
            </summary>
            <param name="fnc">func to retry</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.RetryFunc`2.#ctor(Yaapii.Atoms.IFunc{`0,`1})">
            <summary>
            Function that will retry if it fails.
            </summary>
            <param name="fnc">func to retry</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.RetryFunc`2.#ctor(System.Func{`0,`1},System.Int32)">
            <summary>
            Function that will retry if it fails.
            </summary>
            <param name="fnc">func to retry</param>
            <param name="attempts">how often to retry</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.RetryFunc`2.#ctor(Yaapii.Atoms.IFunc{`0,`1},System.Int32)">
            <summary>
            Function that will retry if it fails.
            </summary>
            <param name="fnc">func to retry</param>
            <param name="attempts">how often to retry</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.RetryFunc`2.#ctor(Yaapii.Atoms.IFunc{`0,`1},System.Func{System.Int32,System.Boolean})">
            <summary>
            Function that will retry if it fails.
            </summary>
            <param name="fnc">func to retry</param>
            <param name="ext">exit condition</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.RetryFunc`2.#ctor(System.Func{`0,`1},System.Func{System.Int32,System.Boolean})">
            <summary>
            Function that will retry if it fails.
            </summary>
            <param name="fnc">func to retry</param>
            <param name="ext">exit condition</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.RetryFunc`2.#ctor(Yaapii.Atoms.IFunc{`0,`1},Yaapii.Atoms.IFunc{System.Int32,System.Boolean})">
            <summary>
            Function that will retry if it fails.
            </summary>
            <param name="fnc">func to retry</param>
            <param name="ext">exit condition</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.RetryFunc`2.Invoke(`0)">
            <summary>
            Invoke the function and retrieve the output.
            </summary>
            <param name="input">the input argument</param>
            <returns>the output</returns>
        </member>
        <member name="T:Yaapii.Atoms.Func.StickyBiFunc`3">
            <summary>
            Function with two inputs which returns the output from cache.
            </summary>
            <typeparam name="In1">type of first argument</typeparam>
            <typeparam name="In2">type of second argument</typeparam>
            <typeparam name="Out">type of output</typeparam>
        </member>
        <member name="F:Yaapii.Atoms.Func.StickyBiFunc`3._func">
            <summary>
            original func
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Func.StickyBiFunc`3._cache">
            <summary>
            cache
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Func.StickyBiFunc`3.#ctor(System.Func{`0,`1,`2})">
            <summary>
            Function with two inputs which returns the output from cache.
            </summary>
            <param name="fnc">func to cache result from</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.StickyBiFunc`3.#ctor(Yaapii.Atoms.IBiFunc{`0,`1,`2})">
            <summary>
            Function with two inputs which returns the output from cache.
            </summary>
            <param name="fnc">func to cache result from</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.StickyBiFunc`3.Apply(`0,`1)">
            <summary>
            Invoke the function and get the output.
            </summary>
            <param name="first"></param>
            <param name="second"></param>
            <returns></returns>
        </member>
        <member name="T:Yaapii.Atoms.Func.StickyFunc`2">
            <summary>
            Func that caches the result and returns from cache.
            </summary>
            <typeparam name="In">type of input</typeparam>
            <typeparam name="Out">type of output</typeparam>
        </member>
        <member name="F:Yaapii.Atoms.Func.StickyFunc`2._func">
            <summary>
            original func
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Func.StickyFunc`2._cache">
            <summary>
            cache
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Func.StickyFunc`2._reloadConditionFnc">
            <summary>
            Reload Condition Func
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Func.StickyFunc`2.#ctor(System.Func{`0,`1})">
            <summary>
            Func that caches the result and returns from cache.
            </summary>
            <param name="fnc">func to cache output from</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.StickyFunc`2.#ctor(Yaapii.Atoms.IFunc{`0,`1})">
            <summary>
            Func that caches the result and returns from cache.
            </summary>
            <param name="fnc">func to cache output from</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.StickyFunc`2.#ctor(System.Func{`0,`1},System.Func{`1,System.Boolean})">
            <summary>
            Func that caches the result and returns from cache with reload condition func
            </summary>
            <param name="fnc">func to cache output from</param>
            <param name="reloadConditionFnc">reload condition func</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.StickyFunc`2.#ctor(Yaapii.Atoms.IFunc{`0,`1},System.Func{`1,System.Boolean})">
            <summary>
            Func that caches the result and returns from cache with reload condition func
            </summary>
            <param name="fnc">func to cache output from</param>
            <param name="reloadConditionFnc">reload condition func</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.StickyFunc`2.#ctor(System.Func{`0,`1},Yaapii.Atoms.IFunc{`1,System.Boolean})">
            <summary>
            Func that caches the result and returns from cache with reload condition func
            </summary>
            <param name="fnc">func to cache output from</param>
            <param name="reloadConditionFnc">reload condition func</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.StickyFunc`2.#ctor(Yaapii.Atoms.IFunc{`0,`1},Yaapii.Atoms.IFunc{`1,System.Boolean})">
            <summary>
            Func that caches the result and returns from cache with reload condition func
            </summary>
            <param name="fnc">func to cache output from</param>
            <param name="reloadConditionFnc">reload condition func</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.StickyFunc`2.Invoke(`0)">
            <summary>
            Invoke the function and retrieve the output.
            </summary>
            <param name="input">input argument</param>
            <returns>output</returns>
        </member>
        <member name="T:Yaapii.Atoms.Func.SyncAction`1">
            <summary>
            Proc that is threadsafe.
            </summary>
            <typeparam name="In">type of input</typeparam>
        </member>
        <member name="F:Yaapii.Atoms.Func.SyncAction`1.act">
            <summary>
            original proc
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Func.SyncAction`1.lck">
            <summary>
            threadsafe-lock
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Func.SyncAction`1.#ctor(Yaapii.Atoms.IAction{`0})">
            <summary>
            Proc that is threadsafe.
            </summary>
            <param name="prc">proc to make threadsafe</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.SyncAction`1.#ctor(Yaapii.Atoms.IAction{`0},System.Object)">
            <summary>
            Proc that is threadsafe.
            </summary>
            <param name="prc">proc to make threadsafe</param>
            <param name="lck">object to lock threadsafe</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.SyncAction`1.Invoke(`0)">
            <summary>
            Execute procedure with given input.
            </summary>
            <param name="input"></param>
        </member>
        <member name="T:Yaapii.Atoms.Func.SyncAction">
            <summary>
            Action that is threadsafe.
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Func.SyncAction.proc">
            <summary>
            original proc
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Func.SyncAction.lck">
            <summary>
            threadsafe-lock
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Func.SyncAction.#ctor(Yaapii.Atoms.IAction)">
            <summary>
            Proc that is threadsafe.
            </summary>
            <param name="prc">proc to make threadsafe</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.SyncAction.#ctor(Yaapii.Atoms.IAction,System.Object)">
            <summary>
            Proc that is threadsafe.
            </summary>
            <param name="prc">proc to make threadsafe</param>
            <param name="lck">object to lock threadsafe</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.SyncAction.Invoke">
            <summary>
            Execute procedure with given input.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Func.SyncFunc`2">
            <summary>
            Function that is threadsafe.
            </summary>
            <typeparam name="In">type of input</typeparam>
            <typeparam name="Out">type of output</typeparam>
        </member>
        <member name="F:Yaapii.Atoms.Func.SyncFunc`2._func">
            <summary>
            original func
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.Func.SyncFunc`2._lck">
            <summary>
            threadsafe-lock
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Func.SyncFunc`2.#ctor(System.Func{`0,`1})">
            <summary>
            Function that is threadsafe.
            </summary>
            <param name="fnc">func to cache output from</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.SyncFunc`2.#ctor(Yaapii.Atoms.IFunc{`0,`1})">
            <summary>
            Function that is threadsafe.
            </summary>
            <param name="fnc">func to cache output from</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.SyncFunc`2.#ctor(Yaapii.Atoms.IFunc{`0,`1},System.Object)">
            <summary>
            Function that is threadsafe.
            </summary>
            <param name="fnc">func to cache result from</param>
            <param name="lck">object that will be locked</param>
        </member>
        <member name="M:Yaapii.Atoms.Func.SyncFunc`2.Invoke(`0)">
            <summary>
            Invoke function with given input and retrieve output.
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="T:Yaapii.Atoms.IAction">
            <summary>
            Represents a function that you call without input and that has no output.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IAction.Invoke">
            <summary>
            Run the action.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.IAction`1">
            <summary>
            A function with input, but no output.
            </summary>
            <typeparam name="In"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.IAction`1.Invoke(`0)">
            <summary>
            Execute the proc.
            </summary>
            <param name="input">input argument</param>
        </member>
        <member name="T:Yaapii.Atoms.IBiFunc`3">
            <summary>
            Function that accepts two arguments
            </summary>
            <typeparam name="X">Type of Input</typeparam>
            <typeparam name="Y">Type of Input</typeparam>
            <typeparam name="Z">Type of Output</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.IBiFunc`3.Invoke(`0,`1)">
            <summary>
            Apply it
            </summary>
            <param name="first"></param>
            <param name="second"></param>
            <returns>Output</returns>
        </member>
        <member name="T:Yaapii.Atoms.IBytes">
            <summary>
            Represents a sequence of bytes.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IBytes.AsBytes">
            <summary>
            Get the content as a byte array.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Yaapii.Atoms.IFail">
            <summary>
            Something that can fail when calling go.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IFail.Go">
            <summary>
            Fail if necessary.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.IFunc`1">
            <summary>
            Represents a function that you call without an argument and which returns something.
            </summary>
            <typeparam name="Out"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.IFunc`1.Invoke">
            <summary>
            Call the function and retrieve the output.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Yaapii.Atoms.IFunc`2">
            <summary>
            A function that has one input and an output.
            </summary>
            <typeparam name="In"></typeparam>
            <typeparam name="Out"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.IFunc`2.Invoke(`0)">
            <summary>
            Apply it
            </summary>
            <param name="input">the input</param>
            <returns>the output</returns>
        </member>
        <member name="T:Yaapii.Atoms.IInput">
             <summary>
             Input.
            
             <para>Here is for example how <see cref="T:Yaapii.Atoms.IInput"/>  can be used
             in order to read the content of a text file:</para>
            
             <code>String content = new BytesAsText(
             new InputAsBytes(
                new InputOf(new Uri("file:///C:/tmp/names.txt")
               )
             ).asString();</code>
            
             <para>Here <see cref="T:Yaapii.Atoms.IO.InputOf"/> 
             implements <see cref="T:Yaapii.Atoms.IInput"/> and behaves like
             one, providing read-only access to the encapsulated <see cref="T:System.Uri"/> pointing to a file.</para>
             </summary>
        </member>
        <member name="M:Yaapii.Atoms.IInput.Stream">
            <summary>
            Get the stream.
            </summary>
            <returns>the stream</returns>
        </member>
        <member name="T:Yaapii.Atoms.IKvp">
            <summary>
            A key-value pair string to string to add to a map.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.IKvp`1">
            <summary>
            A key-value pair to add to a map.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.IKvp`2">
            <summary>
            A key-value pair to add to a map.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.INumber">
            <summary>
            Representation of a number.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.INumber.AsLong">
            <summary>
            The number represented as LONG
            </summary>
            <returns>the long</returns>
        </member>
        <member name="M:Yaapii.Atoms.INumber.AsInt">
            <summary>
            The number represented as INTEGER
            </summary>
            <returns>the integer</returns>
        </member>
        <member name="M:Yaapii.Atoms.INumber.AsDouble">
            <summary>
            The number represented as DOUBLE
            </summary>
            <returns>the double</returns>
        </member>
        <member name="M:Yaapii.Atoms.INumber.AsFloat">
            <summary>
            The number represented as FLOAT
            </summary>
            <returns>the float</returns>
        </member>
        <member name="T:Yaapii.Atoms.IOutput">
             Output.
            
             <para>Here is for example how <see cref="T:Yaapii.Atoms.IOutput"/> can be used
             together with <see cref="T:Yaapii.Atoms.IInput"/> in order to modify the content
             of a text file:</para>
            
             <code> new LengthOfInput(
               new TeeInput(
                 new InputOf(new StringAsText("Hello, world!")),
                 new OutputTo(new Uri("file:///C:/tmp/names.txt"))
               )
             ).AsValue();</code>
            
             <para>Here <see cref="T:Yaapii.Atoms.IO.OutputTo"/> implements {@link Output} and behaves like
             one, providing write-only access to the encapsulated
             <see cref="T:System.Uri"/>. The <see cref="T:Yaapii.Atoms.IO.TeeInput"/> copies the content of the
             input to the output. The <see cref="T:Yaapii.Atoms.IO.LengthOf"/>
             calculates the size of the copied data.</para>
            
             <para>There is no thread-safety guarantee.</para>
            
        </member>
        <member name="M:Yaapii.Atoms.IOutput.Stream">
            <summary>
            Get the stream.
            </summary>
            <returns>the stream</returns>
        </member>
        <member name="T:Yaapii.Atoms.IO.AppendTo">
            <summary>
            Append <see cref="T:Yaapii.Atoms.IOutput"/> to a target.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.AppendTo.#ctor(System.String)">
            <summary>
            a path
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:Yaapii.Atoms.IO.AppendTo.#ctor(System.Uri)">
            <summary>
            Append <see cref="T:Yaapii.Atoms.IOutput"/> to a target file Uri.
            </summary>
            <param name="path">a file uri, retrieve with Path.GetFullPath(absOrRelativePath) or prefix with file://. Must be absolute</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.AppendTo.#ctor(System.IO.StreamWriter)">
            <summary>
            Append <see cref="T:Yaapii.Atoms.IOutput"/> to a target <see cref="T:System.IO.StreamWriter"/>.
            </summary>
            <param name="wtr">a writer</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.AppendTo.#ctor(System.IO.StreamWriter,System.Text.Encoding)">
            <summary>
            Append <see cref="T:Yaapii.Atoms.IOutput"/> to a target <see cref="T:System.IO.StreamWriter"/>.
            </summary>
            <param name="wtr">a writer</param>
            <param name="enc"><see cref="T:System.Text.Encoding"/> of the writer</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.AppendTo.#ctor(System.Func{System.IO.Stream})">
            <summary>
            Append <see cref="T:Yaapii.Atoms.IOutput"/> to a target <see cref="M:Yaapii.Atoms.IO.AppendTo.Stream"/> returned by a <see cref="T:System.Func`1"/>.
            </summary>
            <param name="fnc">target stream returning function</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.AppendTo.#ctor(System.IO.Stream)">
            <summary>
            Append <see cref="T:Yaapii.Atoms.IOutput"/> to a target <see cref="M:Yaapii.Atoms.IO.AppendTo.Stream"/>.
            </summary>
            <param name="stream">target stream</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.AppendTo.#ctor(Yaapii.Atoms.IOutput)">
            <summary>
            Append <see cref="T:Yaapii.Atoms.IOutput"/> to a target <see cref="T:Yaapii.Atoms.IOutput"/>.
            </summary>
            <param name="output">target output</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.AppendTo.#ctor(Yaapii.Atoms.IScalar{Yaapii.Atoms.IOutput})">
            <summary>
            Append <see cref="T:Yaapii.Atoms.IOutput"/> to a target <see cref="T:Yaapii.Atoms.IScalar`1"/>.
            </summary>
            <param name="outputSc">target output scalar</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.AppendTo.Dispose">
            <summary>
            Disposes the stream
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.AppendTo.Stream">
            <summary>
            Get the stream to append
            </summary>
            <returns>the stream</returns>
        </member>
        <member name="T:Yaapii.Atoms.IO.ConsoleErrorOutput">
            <summary>
            Console error output stream.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.ConsoleErrorOutput.#ctor">
            <summary>
            Console error output stream.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.ConsoleErrorOutput.Stream">
            <summary>
            Get the stream.
            </summary>
            <returns>the stream</returns>
        </member>
        <member name="T:Yaapii.Atoms.IO.ConsoleInput">
            <summary>
            Console input stream.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.ConsoleInput.#ctor">
            <summary>
            Console input stream.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.ConsoleInput.Stream">
            <summary>
            Get the stream.
            </summary>
            <returns>the stream</returns>
        </member>
        <member name="T:Yaapii.Atoms.IO.ConsoleOutput">
            <summary>
            Console output stream.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.ConsoleOutput.#ctor">
            <summary>
            Console output stream.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.ConsoleOutput.Stream">
            <summary>
            Get the stream.
            </summary>
            <returns>the stream</returns>
        </member>
        <member name="T:Yaapii.Atoms.IO.DeadInput">
            <summary>
            Input with no data.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.DeadInput.#ctor">
            <summary>
            Input with no data.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.DeadInput.Stream">
            <summary>
            Get the stream.
            </summary>
            <returns>the stream</returns>
        </member>
        <member name="T:Yaapii.Atoms.IO.DeadOutput">
            <summary>
            Output to dev/null.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.DeadOutput.#ctor">
            <summary>
            Output to dev/null.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.DeadOutput.Stream">
            <summary>
            Get the stream.
            </summary>
            <returns>the stream</returns>
        </member>
        <member name="T:Yaapii.Atoms.IO.DeadStream">
            <summary>
            Stream with killed methods.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.DeadStream.#ctor">
            <summary>
            Stream with killed methods.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.IO.DecodedUrl">
            <summary>
            Decoded url from a string.
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.IO.DecodedUrl.source">
            <summary>
            source text
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.DecodedUrl.#ctor(System.String)">
            <summary>
            ctor
            </summary>
            <param name="url">url as string</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.DecodedUrl.#ctor(System.String,System.Text.Encoding)">
            <summary>
            Decoded url from a string.
            </summary>
            <param name="url">url as string</param>
            <param name="enc">encoding of the string</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.DecodedUrl.#ctor(Yaapii.Atoms.IText)">
            <summary>
            Decoded url from a string.
            </summary>
            <param name="url">url as text</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.DecodedUrl.Value">
            <summary>
            Get the value.
            </summary>
            <returns>the value</returns>
        </member>
        <member name="T:Yaapii.Atoms.IO.DigestEnvelope">
            <summary>
            Digest Envelope
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.DigestEnvelope.#ctor(Yaapii.Atoms.IInput,Yaapii.Atoms.IScalar{System.Security.Cryptography.HashAlgorithm})">
            <summary>
            Digest Envelope of Input
            </summary>
            <param name="source">Input</param>
            <param name="algorithmFactory">Factory to create Hash Algorithm</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.DigestEnvelope.AsBytes">
            <summary>
            Digest
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.IO.DirectoryOf._dir">
            <summary>
            Path of the directory.
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.IO.DirectoryOf._recursive">
            <summary>
            include all files from sub directories
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.DirectoryOf.#ctor(System.IO.DirectoryInfo)">
            <summary>
            Ctor.
            </summary>
            <param name="dir">DirectoryInfo</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.DirectoryOf.#ctor(System.IO.DirectoryInfo,System.Boolean)">
            <summary>
            Ctor.
            </summary>
            <param name="dir">DirectoryInfo</param>
            <param name="recursive">include all files from sub directories</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.DirectoryOf.#ctor(System.Uri)">
            <summary>
            Ctor.
            </summary>
            <param name="file">File as a uri</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.DirectoryOf.#ctor(System.Uri,System.Boolean)">
            <summary>
            Ctor.
            </summary>
            <param name="file">File as a uri</param>
            <param name="recursive">include all files from sub directories</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.DirectoryOf.#ctor(System.IO.FileInfo)">
            <summary>
            Ctor.
            </summary>
            <param name="file">File as a path to directory.</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.DirectoryOf.#ctor(System.IO.FileInfo,System.Boolean)">
            <summary>
            Ctor.
            </summary>
            <param name="file">File as a path to directory.</param>
            <param name="recursive">include all files from sub directories</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.DirectoryOf.#ctor(System.String)">
            <summary>
            ctor
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:Yaapii.Atoms.IO.DirectoryOf.#ctor(System.String,System.Boolean)">
            <summary>
            ctor
            </summary>
            <param name="path"></param>
            <param name="recursive">include all files from sub directories</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.DirectoryOf.#ctor(Yaapii.Atoms.IScalar{System.String})">
            <summary>
            ctor
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:Yaapii.Atoms.IO.DirectoryOf.#ctor(Yaapii.Atoms.IScalar{System.String},Yaapii.Atoms.IScalar{System.Boolean})">
            <summary>
            ctor
            </summary>
            <param name="path"></param>
            <param name="recursive">include all files from sub directories</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.DirectoryOf.GetEnumerator">
            <summary>
            Enumerate directory and file paths as string.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Yaapii.Atoms.IO.GZipInput">
            <summary>
            A input that decompresses.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.GZipInput.#ctor(Yaapii.Atoms.IInput)">
            <summary>
            The input as a gzip stream.
            </summary>
            <param name="input">the input</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.GZipInput.Stream">
            <summary>
            A stream which is decompressing.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Yaapii.Atoms.IO.GZipOutput">
            <summary>
            A output that compresses.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.GZipOutput.#ctor(Yaapii.Atoms.IOutput)">
            <summary>
            The output as a gzip output. It compresses with level 'optimal'.
            </summary>
            <param name="output">the input</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.GZipOutput.#ctor(Yaapii.Atoms.IOutput,System.IO.Compression.CompressionLevel)">
            <summary>
            The output as a gzip compressed stream.
            </summary>
            <param name="output">the output to compress</param>
            <param name="level">the compression level</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.GZipOutput.Stream">
            <summary>
            A stream configured to decompressing.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Yaapii.Atoms.IO.HeadInputStream">
            <summary>
            Input stream that only shows the first N bytes of the original stream.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.HeadInputStream.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Input stream that only shows the first N bytes of the original stream.
            </summary>
            <param name="origin">Stream</param>
            <param name="length">Length</param>
        </member>
        <member name="T:Yaapii.Atoms.IO.HeadOf">
            <summary>
            Input that only shows the first N bytes of the original input.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.HeadOf.#ctor(Yaapii.Atoms.IInput,System.Int32)">
            <summary>
            Input that only shows the first N bytes of the original input.
            </summary>
            <param name="origin">Input</param>
            <param name="length">Length</param>
        </member>
        <member name="T:Yaapii.Atoms.IO.InputNoNulls">
            <summary>
            Input that does not accept null.
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.IO.InputNoNulls._origin">
            <summary>
            original input
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputNoNulls.#ctor(Yaapii.Atoms.IInput)">
            <summary>
            Input that does not accept null.
            </summary>
            <param name="input">input to check</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputNoNulls.Stream">
            <summary>
            Get the stream.
            </summary>
            <returns>the stream</returns>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputNoNulls.Dispose">
            <summary>
            Clean up.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.IO.InputOf">
            <summary>
            Input out of other things.
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.IO.InputOf._origin">
            <summary>
            the input
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputOf.#ctor(System.Uri)">
            <summary>
            Input out of a file Uri.
            </summary>
            <param name="file">uri of a file, get with Path.GetFullPath(relativePath) or prefix with file://...</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputOf.#ctor(System.IO.FileInfo)">
            <summary>
            Input out of a file Uri.
            </summary>
            <param name="file">uri of a file, get with Path.GetFullPath(relativePath) or prefix with file://...</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputOf.#ctor(Yaapii.Atoms.IScalar{System.IO.FileInfo})">
            <summary>
            Input out of a scalar of a file Uri.
            </summary>
            <param name="file">scalar of a uri of a file, get with Path.GetFullPath(relativePath) or prefix with file://...</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputOf.#ctor(Yaapii.Atoms.IO.Url)">
            <summary>
            Input out of a Url.
            </summary>
            <param name="url">a url starting with http:// or https://</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputOf.#ctor(Yaapii.Atoms.IScalar{Yaapii.Atoms.IO.Url})">
            <summary>
            Input out of a Url scalar.
            </summary>
            <param name="url">a url starting with http:// or https://</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputOf.#ctor(System.IO.StringReader)">
            <summary>
            ctor
            </summary>
            <param name="rdr">a stringreader</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputOf.#ctor(System.IO.StreamReader)">
            <summary>
            ctor
            </summary>
            <param name="rdr">a streamreader</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputOf.#ctor(System.IO.StreamReader,System.Text.Encoding)">
            <summary>
            ctor
            </summary>
            <param name="rdr">a streamreader</param>
            <param name="enc">encoding of the reader</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputOf.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>
            ctor
            </summary>
            <param name="str">a stream</param>
            <param name="enc">encoding of the stream</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputOf.#ctor(System.IO.StreamReader,System.Text.Encoding,System.Int32)">
            <summary>
            ctor
            </summary>
            <param name="rdr">a streamreader</param>
            <param name="enc">encoding of the reader</param>
            <param name="max">maximum buffer size</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputOf.#ctor(System.Text.StringBuilder)">
            <summary>
            ctor
            </summary>
            <param name="builder">a stringbuilder</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputOf.#ctor(System.Text.StringBuilder,System.Text.Encoding)">
            <summary>
            ctor
            </summary>
            <param name="builder">a stringbuilder</param>
            <param name="enc">encoding of the stringbuilder</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputOf.#ctor(System.Char[])">
            <summary>
            ctor
            </summary>
            <param name="chars">some chars</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputOf.#ctor(System.Char[],System.Text.Encoding)">
            <summary>
            ctor
            </summary>
            <param name="chars">some chars</param>
            <param name="enc">encoding of the chars</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputOf.#ctor(System.String)">
            <summary>
            ctor
            </summary>
            <param name="text">some text</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputOf.#ctor(System.String,System.Text.Encoding)">
            <summary>
            ctor
            </summary>
            <param name="text">some <see cref="T:System.String"/></param>
            <param name="enc"><see cref="T:System.Text.Encoding"/> of the string</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputOf.#ctor(Yaapii.Atoms.IText)">
            <summary>
            ctor
            </summary>
            <param name="text">some <see cref="T:Yaapii.Atoms.IText"/></param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputOf.#ctor(Yaapii.Atoms.IText,System.Text.Encoding)">
            <summary>
            ctor
            </summary>
            <param name="text">some <see cref="T:Yaapii.Atoms.IText"/></param>
            <param name="encoding"><see cref="T:System.Text.Encoding"/> of the text</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputOf.#ctor(System.Exception)">
            <summary>
            ctor
            </summary>
            <param name="error"><see cref="T:System.Exception"/> to serialize</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputOf.#ctor(System.Byte[])">
            <summary>
            ctor
            </summary>
            <param name="bytes">a <see cref="T:System.Byte"/> array</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputOf.#ctor(Yaapii.Atoms.IBytes)">
            <summary>
            ctor
            </summary>
            <param name="src">a <see cref="T:Yaapii.Atoms.IBytes"/> object which will be copied to memory</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputOf.#ctor(System.IO.Stream)">
            <summary>
            ctor
            </summary>
            <param name="stream">a <see cref="M:Yaapii.Atoms.IO.InputOf.Stream"/> as input</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputOf.#ctor(System.Func{System.IO.Stream})">
            <summary>
            ctor
            </summary>
            <param name="fnc">a function retrieving a <see cref="M:Yaapii.Atoms.IO.InputOf.Stream"/> as input</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputOf.#ctor(Yaapii.Atoms.IScalar{System.IO.Stream})">
            <summary>
            ctor
            </summary>
            <param name="stream">the input <see cref="M:Yaapii.Atoms.IO.InputOf.Stream"/></param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputOf.Stream">
            <summary>
            Get the stream.
            </summary>
            <returns>the stream</returns>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputOf.Dispose">
            <summary>
            Clean up.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.IO.InputStreamOf">
            <summary>
            A readable stream out of other objects.
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.IO.InputStreamOf._source">
            <summary>
            the source
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputStreamOf.#ctor(System.Uri)">
            <summary>
            A readable stream out of a file Uri.
            </summary>
            <param name="path">uri of a file, get with Path.GetFullPath(relativePath) or prefix with file://...</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputStreamOf.#ctor(Yaapii.Atoms.IO.Url)">
            <summary>
            A readable stream out of a www Url.
            </summary>
            <param name="url">a url starting with http:// or https://</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputStreamOf.#ctor(Yaapii.Atoms.IBytes)">
            <summary>
            A readable stream out of Bytes.
            </summary>
            <param name="bytes">a <see cref="T:Yaapii.Atoms.IBytes"/> object which will be copied to memory</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputStreamOf.#ctor(System.Byte[])">
            <summary>
            A readable stream out of a Byte array.
            </summary>
            <param name="bytes">a <see cref="T:System.Byte"/> array</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputStreamOf.#ctor(Yaapii.Atoms.IText)">
            <summary>
            A readable stream out of a Text.
            </summary>
            <param name="text">some <see cref="T:Yaapii.Atoms.IText"/></param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputStreamOf.#ctor(System.String)">
            <summary>
            A readable stream out of a string.
            </summary>
            <param name="text">some string</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputStreamOf.#ctor(System.String,System.Text.Encoding)">
            <summary>
            A readable stream out of a string.
            </summary>
            <param name="text">some <see cref="T:System.String"/></param>
            <param name="enc"><see cref="T:System.Text.Encoding"/> of the string</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputStreamOf.#ctor(Yaapii.Atoms.IText,System.Text.Encoding)">
            <summary>
            A readable stream out of a <see cref="T:Yaapii.Atoms.IText"/> with <see cref="T:System.Text.Encoding"/>.
            </summary>
            <param name="text">some <see cref="T:Yaapii.Atoms.IText"/></param>
            <param name="enc"><see cref="T:System.Text.Encoding"/> of the text</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputStreamOf.#ctor(System.IO.StreamReader)">
            <summary>
            A readable stream out of a <see cref="T:System.IO.StreamReader"/>.
            </summary>
            <param name="rdr">a streamreader</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputStreamOf.#ctor(System.IO.StreamReader,System.Int32)">
            <summary>
            A readable stream out of a <see cref="T:System.IO.StreamReader"/>.
            </summary>
            <param name="rdr">a streamreader</param>
            <param name="max">maximum buffer size</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputStreamOf.#ctor(System.IO.StreamReader,System.Text.Encoding,System.Int32)">
            <summary>
            A readable stream out of a <see cref="T:System.IO.StreamReader"/>.
            </summary>
            <param name="rdr">a streamreader</param>
            <param name="enc">encoding of the reader</param>
            <param name="max">maximum buffer size</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputStreamOf.#ctor(Yaapii.Atoms.IInput)">
            <summary>
            A readable stream out of a <see cref="T:Yaapii.Atoms.IInput"/>.
            </summary>
            <param name="input">the input</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputStreamOf.#ctor(System.Func{System.IO.Stream})">
            <summary>
            A readable stream out of a <see cref="N:Yaapii.Atoms.Func"/> that returns a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="input">the input</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputStreamOf.#ctor(Yaapii.Atoms.IScalar{System.IO.Stream})">
            <summary>
            A readable stream out of a <see cref="T:Yaapii.Atoms.IScalar`1"/> that encapsulates a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="src">the source</param>
        </member>
        <member name="T:Yaapii.Atoms.IO.InputWithFallback">
            <summary>
            Input which returns an alternate value if it fails.
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.IO.InputWithFallback._main">
            <summary>
            main input
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.IO.InputWithFallback._alternative">
            <summary>
            alternative input
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputWithFallback.#ctor(Yaapii.Atoms.IInput)">
            <summary>
            Input which returns an alternate value if it fails.
            </summary>
            <param name="input">the input</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputWithFallback.#ctor(Yaapii.Atoms.IInput,Yaapii.Atoms.IInput)">
            <summary>
            Input which returns an alternate value if it fails.
            </summary>
            <param name="input">the input</param>
            <param name="alt">a fallback input</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputWithFallback.#ctor(Yaapii.Atoms.IInput,System.Func{System.IO.IOException,Yaapii.Atoms.IInput})">
            <summary>
            Input which returns an alternate value from the given <see cref="T:System.Func`2"/>if it fails.
            </summary>
            <param name="input">the input</param>
            <param name="alt">function to return alternative input</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputWithFallback.#ctor(Yaapii.Atoms.IInput,Yaapii.Atoms.IFunc{System.IO.IOException,Yaapii.Atoms.IInput})">
            <summary>
            Input which returns an alternate value from the given <see cref="T:Yaapii.Atoms.IFunc`2"/>if it fails.
            </summary>
            <param name="input">the input</param>
            <param name="alt">an alternative input</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputWithFallback.Stream">
            <summary>
            Get the stream.
            </summary>
            <returns>the stream</returns>
        </member>
        <member name="M:Yaapii.Atoms.IO.InputWithFallback.Dispose">
            <summary>
            Clean up.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.IO.LengthOf">
            <summary>
            Length of <see cref="T:Yaapii.Atoms.IInput"/>. (Self-Disposing)
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.IO.LengthOf._source">
            <summary>
            the source
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.IO.LengthOf._size">
            <summary>
            buffer size
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.LengthOf.#ctor(Yaapii.Atoms.IInput,System.Int32)">
            <summary>
            Length of <see cref="T:Yaapii.Atoms.IInput"/> by reading all bytes.
            </summary>
            <param name="input">the input</param>
            <param name="max">maximum buffer size</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.LengthOf.Value">
            <summary>
            Get the length. (Self-Disposing)
            </summary>
            <returns>the length</returns>
        </member>
        <member name="T:Yaapii.Atoms.IO.LoggingInput">
            <summary>
            Logged input.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.LoggingInput.#ctor(Yaapii.Atoms.IInput,System.String)">
            <summary>
            Logged input.
            </summary>
            <param name="input"></param>
            <param name="source"></param>
        </member>
        <member name="T:Yaapii.Atoms.IO.LoggingInputStream">
            <summary>
            Logged input stream.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.LoggingInputStream.#ctor(System.IO.Stream,System.String)">
            <summary>
            Logged input stream.
            </summary>
            <param name="input"></param>
            <param name="source"></param>
        </member>
        <member name="M:Yaapii.Atoms.IO.LoggingInputStream.#ctor(System.IO.Stream,System.String,System.Action{System.String})">
            <summary>
            Logged input stream
            </summary>
            <param name="input"></param>
            <param name="source"></param>
            <param name="log"></param>
        </member>
        <member name="T:Yaapii.Atoms.IO.LoggingOutput">
            <summary>
            Logged output.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.LoggingOutput.#ctor(Yaapii.Atoms.IOutput,System.String)">
            <summary>
            Logged output.
            </summary>
            <param name="output">Data output</param>
            <param name="destination">The name of destination data</param>
        </member>
        <member name="T:Yaapii.Atoms.IO.LoggingOutputStream">
            <summary>
            Logged output stream.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.LoggingOutputStream.#ctor(System.IO.Stream,System.String)">
            <summary>
            Logged output stream.
            </summary>
            <param name="output">Destination of data</param>
            <param name="destination">The name of source data</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.LoggingOutputStream.#ctor(System.IO.Stream,System.String,System.Action{System.String})">
            <summary>
            Logged output stream.
            </summary>
            <param name="output">Destination of data</param>
            <param name="destination">The name of the source data</param>
            <param name="log">The log action</param>
        </member>
        <member name="T:Yaapii.Atoms.IO.Md5DigestOf">
            <summary>
            MD5 checksum calculation
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.Md5DigestOf.#ctor(Yaapii.Atoms.IInput)">
            <summary>
            MD5 checksum calculation of IInput.
            </summary>
            <param name="source">Input</param>
        </member>
        <member name="T:Yaapii.Atoms.IO.MemoryInput">
            <summary>
            A <see cref="T:Yaapii.Atoms.IInput"/> which saves the input as memorystream
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.MemoryInput.#ctor(Yaapii.Atoms.IInput)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IInput"/> which saves the input as memorystream
            </summary>
            <param name="input"></param>
        </member>
        <member name="T:Yaapii.Atoms.IO.OutputStreamTo">
            <summary>
            A writable <see cref="T:System.IO.Stream"/> out of other objects.
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.IO.OutputStreamTo._target">
            <summary>
            the target
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.OutputStreamTo.#ctor(System.String)">
            <summary>
            A writable <see cref="T:System.IO.Stream"/> of a file path.
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:Yaapii.Atoms.IO.OutputStreamTo.#ctor(System.IO.StreamWriter)">
            <summary>
            A writable <see cref="T:System.IO.Stream"/> out of a StreamWriter.
            </summary>
            <param name="wtr">a writer</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.OutputStreamTo.#ctor(System.IO.StreamWriter,System.Text.Encoding)">
            <summary>
            A writable <see cref="T:System.IO.Stream"/> out of a StreamWriter.
            </summary>
            <param name="wtr">a writer</param>
            <param name="enc">encoding of the writer</param>        
        </member>
        <member name="M:Yaapii.Atoms.IO.OutputStreamTo.#ctor(Yaapii.Atoms.IOutput)">
            <summary>
            A writable <see cref="T:System.IO.Stream"/> out of a <see cref="T:Yaapii.Atoms.IOutput"/>.
            </summary>
            <param name="output">an output</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.OutputStreamTo.#ctor(Yaapii.Atoms.IScalar{System.IO.Stream})">
            <summary>
            A writable <see cref="T:System.IO.Stream"/> out of a <see cref="T:Yaapii.Atoms.IScalar`1"/> objects.
            </summary>
            <param name="tgt">the target</param>
        </member>
        <member name="T:Yaapii.Atoms.IO.OutputTo">
            <summary>
            <see cref="T:Yaapii.Atoms.IOutput"/> to a target.
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.IO.OutputTo._origin">
            <summary>
            the output
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.OutputTo.#ctor(System.String)">
            <summary>
            a path
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:Yaapii.Atoms.IO.OutputTo.#ctor(System.Uri)">
            <summary>
            <see cref="T:Yaapii.Atoms.IOutput"/> to a target file Uri.
            </summary>
            <param name="path">a file uri, retrieve with Path.GetFullPath(absOrRelativePath) or prefix with file://. Must be absolute</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.OutputTo.#ctor(System.IO.StreamWriter)">
            <summary>
            <see cref="T:Yaapii.Atoms.IOutput"/> to a target <see cref="T:System.IO.StreamWriter"/>.
            </summary>
            <param name="wtr">a writer</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.OutputTo.#ctor(System.IO.StreamWriter,System.Text.Encoding)">
            <summary>
            <see cref="T:Yaapii.Atoms.IOutput"/> to a target <see cref="T:System.IO.StreamWriter"/>.
            </summary>
            <param name="wtr">a writer</param>
            <param name="enc"><see cref="T:System.Text.Encoding"/> of the writer</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.OutputTo.#ctor(System.Func{System.IO.Stream})">
            <summary>
            <see cref="T:Yaapii.Atoms.IOutput"/> to a target <see cref="M:Yaapii.Atoms.IO.OutputTo.Stream"/> returned by a <see cref="T:System.Func`1"/>.
            </summary>
            <param name="fnc">target stream returning function</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.OutputTo.#ctor(System.IO.Stream)">
            <summary>
            <see cref="T:Yaapii.Atoms.IOutput"/> to a target <see cref="M:Yaapii.Atoms.IO.OutputTo.Stream"/>.
            </summary>
            <param name="stream">target stream</param>
        </member>
        <member name="T:Yaapii.Atoms.IO.ReaderOf">
            <summary>
            A <see cref="T:System.IO.StreamReader"/> out of other objects.
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.IO.ReaderOf._source">
            <summary>
            the source
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.ReaderOf.#ctor(System.Char[])">
            <summary>
            A <see cref="T:System.IO.StreamReader"/> out of a <see cref="T:System.Char"/> array.
            </summary>
            <param name="chars">some chars</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.ReaderOf.#ctor(System.Char[],System.Text.Encoding)">
            <summary>
            A <see cref="T:System.IO.StreamReader"/> out of a <see cref="T:System.Char"/> array.
            </summary>
            <param name="chars">some chars</param>
            <param name="enc">encoding of the chars</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.ReaderOf.#ctor(System.Byte[])">
            <summary>
            A <see cref="T:System.IO.StreamReader"/> out of a <see cref="T:System.Byte"/> array.
            </summary>
            <param name="bytes">some bytes</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.ReaderOf.#ctor(System.Byte[],System.Text.Encoding)">
            <summary>
            A <see cref="T:System.IO.StreamReader"/> out of a <see cref="T:System.Byte"/> array.
            </summary>
            <param name="bytes">some bytes</param>
            <param name="enc">encoding of the bytes</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.ReaderOf.#ctor(Yaapii.Atoms.IO.Url)">
            <summary>
            A <see cref="T:System.IO.StreamReader"/> out of a <see cref="T:Yaapii.Atoms.IO.Url"/> array.
            </summary>
            <param name="url">a www url starting with http:// or https://</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.ReaderOf.#ctor(System.String)">
            <summary>
            A <see cref="T:System.IO.StreamReader"/> out of a <see cref="T:System.String"/>.
            </summary>
            <param name="content">a string</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.ReaderOf.#ctor(System.Uri)">
            <summary>
            A <see cref="T:System.IO.StreamReader"/> out of a file <see cref="T:System.Uri"/> array.
            </summary>
            <param name="uri">a file Uri, create with Path.GetFullPath(absOrRelativePath) or prefix with file:/// </param>
        </member>
        <member name="M:Yaapii.Atoms.IO.ReaderOf.#ctor(Yaapii.Atoms.IBytes)">
            <summary>
            A <see cref="T:System.IO.StreamReader"/> out of a <see cref="T:Yaapii.Atoms.IBytes"/> object.
            </summary>
            <param name="bytes">a <see cref="T:Yaapii.Atoms.IBytes"/> object</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.ReaderOf.#ctor(Yaapii.Atoms.IText)">
            <summary>
            A <see cref="T:System.IO.StreamReader"/> out of a <see cref="T:Yaapii.Atoms.IText"/> object.
            </summary>
            <param name="text">some <see cref="T:Yaapii.Atoms.IText"/></param>
        </member>
        <member name="M:Yaapii.Atoms.IO.ReaderOf.#ctor(Yaapii.Atoms.IText,System.Text.Encoding)">
            <summary>
            A <see cref="T:System.IO.StreamReader"/> out of a <see cref="T:Yaapii.Atoms.IText"/> object.
            </summary>
            <param name="text">some <see cref="T:Yaapii.Atoms.IText"/></param>
            <param name="enc">encoding of the text</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.ReaderOf.#ctor(Yaapii.Atoms.IInput)">
            <summary>
            A <see cref="T:System.IO.StreamReader"/> out of a <see cref="T:Yaapii.Atoms.IInput"/> object.
            </summary>
            <param name="input">a input</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.ReaderOf.#ctor(Yaapii.Atoms.IInput,System.Text.Encoding)">
            <summary>
            A <see cref="T:System.IO.StreamReader"/> out of a <see cref="T:Yaapii.Atoms.IInput"/> object.
            </summary>
            <param name="input">a input</param>
            <param name="enc">encoding of the input</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.ReaderOf.#ctor(System.IO.Stream)">
            <summary>
            A <see cref="T:System.IO.StreamReader"/> out of a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="stream">a stream</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.ReaderOf.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>
            A <see cref="T:System.IO.StreamReader"/> out of a <see cref="T:System.IO.Stream"/> object.
            </summary>
            <param name="stream">a stream</param>
            <param name="enc">encoding of the stream</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.ReaderOf.#ctor(System.IO.StreamReader)">
            <summary>
            A <see cref="T:System.IO.StreamReader"/> out of a <see cref="T:System.IO.StreamReader"/>.
            </summary>
            <param name="rdr">a reader</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.ReaderOf.#ctor(System.Func{System.IO.StreamReader})">
            <summary>
            A <see cref="T:System.IO.StreamReader"/> out of a <see cref="T:System.Func`1"/> that returns a <see cref="T:System.IO.StreamReader"/>.
            </summary>
            <param name="src">func retrieving a reader</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.ReaderOf.#ctor(Yaapii.Atoms.IScalar{System.IO.StreamReader})">
            <summary>
            A <see cref="T:System.IO.StreamReader"/> encapsulated in a <see cref="T:Yaapii.Atoms.IScalar`1"/>.
            </summary>
            <param name="src">scalar of a reader</param>
        </member>
        <member name="T:Yaapii.Atoms.IO.Error.ResourceNotFoundException">
            <summary>
            When a resource cannot be found.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.Error.ResourceNotFoundException.#ctor(System.String,System.Reflection.Assembly)">
            <summary>
            Tell which one was searched for and which are available.
            </summary>
            <param name="missing">the missing one</param>
            <param name="container">the searched container</param>
        </member>
        <member name="T:Yaapii.Atoms.IO.ResourceOf">
            <summary>
            <para>An embedded resource.</para>
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.ResourceOf.#ctor(System.String,System.Type)">
            <summary>
            <para>A resource embedded in the container.</para>
            <para>Name must be provided as a relative path:</para>
            <para>If the resource is in project root path project\resource.txt, address it with resource.txt</para>
            <para>If the resource is in a subpath project\resources\resource.txt, address it with resources\resource.txt</para>
            <para>Please note that the the path is case sensitive.</para>
            </summary>
            <param name="name">name of the resource</param>
            <param name="type">a class that is in the same container (assembly) with the resource</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.ResourceOf.#ctor(System.String,System.Reflection.Assembly)">
            <summary>
            <para>A resource embedded in the container.</para>
            <para>Name must be provided as a relative path:</para>
            <para>If the resource is in project root path project\resource.txt, address it with resource.txt</para>
            <para>If the resource is in a subpath project\resources\resource.txt, address it with resources\resource.txt</para>
            <para>Please note that the the path is case sensitive.</para>
            </summary>
            <param name="name">name of the resource</param>
            <param name="container">container to search in. Use Assembly.GetExecutingAssembly() for the assembly your current code is in.</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.ResourceOf.#ctor(System.String,Yaapii.Atoms.IScalar{System.Reflection.Assembly})">
            <summary>
            <para>A resource embedded in the container.</para>
            <para>Name must be provided as a relative path:</para>
            <para>If the resource is in project root path project\resource.txt, address it with resource.txt</para>
            <para>If the resource is in a subpath project\resources\resource.txt, address it with resources\resource.txt</para>
            <para>Please note that the the path is case sensitive.</para>
            </summary>
            <param name="name">name of the resource</param>
            <param name="container">container to search in. Use Assembly.GetExecutingAssembly() for the assembly your current code is in.</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.ResourceOf.#ctor(System.String,Yaapii.Atoms.IScalar{System.Reflection.Assembly},System.Collections.Generic.IEnumerable{System.Char})">
            <summary>
            <para>A resource embedded in the container.</para>
            <para>Name must be provided as a relative path:</para>
            <para>If the resource is in project root path project\resource.txt, address it with resource.txt</para>
            <para>If the resource is in a subpath project\resources\resource.txt, address it with resources\resource.txt</para>
            <para>Please note that the the path is case sensitive.</para>
            </summary>
            <param name="name">name of the resource</param>
            <param name="container">container to search in. Use Assembly.GetExecutingAssembly() for the assembly your current code is in.</param>
            <param name="symbols">list of symbols which has to be encoded.</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.ResourceOf.Stream">
            <summary>
            Stream of the resource.
            </summary>
            <exception cref = "T:Yaapii.Atoms.IO.Error.ResourceNotFoundException" >if resource is not present</exception >
            <returns>stream of the resource</returns>
        </member>
        <member name="M:Yaapii.Atoms.IO.ResourceOf.DotsEncoded(System.String)">
            <summary>
            Replace all occurence of '.' by "._"
            Example: "_version8.1" -> "_version8._1"
            </summary>
            <param name="path">The path to translate</param>
            <returns>Result</returns>
        </member>
        <member name="M:Yaapii.Atoms.IO.ResourceOf.NumbersEncoded(System.String)">
            <summary>
            When the folder begins with a digit it will be amended by a leading '_'.
            Example: "7text7" -> "_7text7"
            </summary>
            <param name="path">The path to translate</param>
            <returns>Result</returns>
        </member>
        <member name="M:Yaapii.Atoms.IO.ResourceOf.SymbolsEndoced(System.String)">
            <summary>
            Replaces all symbols by '_'.
            When the path is equal to that symbol is will be replaced by "__".
            Example: "unique-name" -> "unique_name"
            Example: "{" -> "__"
            </summary>
            <param name="path">The path to translate</param>
            <returns>Result</returns>
        </member>
        <member name="T:Yaapii.Atoms.IO.Sha1DigestOf">
            <summary>
            SHA-1 checksum calculation
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.Sha1DigestOf.#ctor(Yaapii.Atoms.IInput)">
            <summary>
            SHA-1 checksum calculation of IInput.
            </summary>
            <param name="source">Input</param>
        </member>
        <member name="T:Yaapii.Atoms.IO.Sha256DigestOf">
            <summary>
            SHA-256 checksum calculation
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.Sha256DigestOf.#ctor(Yaapii.Atoms.IInput)">
            <summary>
            SHA-256 checksum calculation of IInput.
            </summary>
            <param name="source">Input</param>
        </member>
        <member name="T:Yaapii.Atoms.IO.StickyInput">
            <summary>
            <see cref="T:Yaapii.Atoms.IInput"/> that reads once and then returns from cache.
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.IO.StickyInput._cache">
            <summary>
            the cache
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.StickyInput.#ctor(Yaapii.Atoms.IInput)">
            <summary>
            <see cref="T:Yaapii.Atoms.IInput"/> that reads once and then returns from cache.
            Closes the input stream after first read.
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Yaapii.Atoms.IO.StickyInput.Stream">
            <summary>
            Get the stream.
            </summary>
            <returns>the stream</returns>
        </member>
        <member name="T:Yaapii.Atoms.IO.TailOf">
            <summary>
            Input showing only last N bytes of the stream.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.TailOf.#ctor(Yaapii.Atoms.IInput,System.Int32)">
            <summary>
            Input showing only last N bytes of the stream.
            </summary>
            <param name="input"></param>
            <param name="bytes"></param>
        </member>
        <member name="M:Yaapii.Atoms.IO.TailOf.#ctor(Yaapii.Atoms.IInput,System.Int32,System.Int32)">
            <summary>
            Input showing only last N bytes of the stream.
            </summary>
            <param name="input"></param>
            <param name="bytes"></param>
            <param name="max"></param>
        </member>
        <member name="T:Yaapii.Atoms.IO.TeeInput">
            <summary>
            <see cref="T:Yaapii.Atoms.IInput"/> which will be copied to output while reading.
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.IO.TeeInput.source">
            <summary>
            the source
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.IO.TeeInput.target">
            <summary>
            the destination
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.TeeInput.#ctor(System.Uri,System.Uri)">
            <summary>
            <see cref="T:Yaapii.Atoms.IInput"/> out of a file <see cref="T:System.Uri"/> which will be copied to <see cref="T:Yaapii.Atoms.IOutput"/> while reading.
            </summary>
            <param name="input">input Uri</param>
            <param name="output">output Uri</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.TeeInput.#ctor(System.String,System.Uri)">
            <summary>
            <see cref="T:Yaapii.Atoms.IInput"/> out of a <see cref="T:System.String"/> which will be copied to <see cref="T:Yaapii.Atoms.IOutput"/> while reading.
            </summary>
            <param name="input">input path</param>
            <param name="file">output Uri</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.TeeInput.#ctor(System.Byte[],System.Uri)">
            <summary>
            <see cref="T:Yaapii.Atoms.IInput"/> out of a <see cref="T:System.Byte"/> array which will be copied to <see cref="T:Yaapii.Atoms.IOutput"/> while reading.
            </summary>
            <param name="input">input byte array</param>
            <param name="file">output Uri</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.TeeInput.#ctor(System.String,Yaapii.Atoms.IOutput)">
            <summary>
            <see cref="T:Yaapii.Atoms.IInput"/> out of a <see cref="T:System.String"/>  which will be copied to <see cref="T:Yaapii.Atoms.IOutput"/> while reading.
            </summary>
            <param name="input">input string</param>
            <param name="output">output</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.TeeInput.#ctor(Yaapii.Atoms.IInput,Yaapii.Atoms.IOutput)">
            <summary>
            <see cref="T:Yaapii.Atoms.IInput"/> out of a <see cref="T:Yaapii.Atoms.IInput"/> array which will be copied to <see cref="T:Yaapii.Atoms.IOutput"/> while reading.
            </summary>
            <param name="input">input</param>
            <param name="output">output</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.TeeInput.Stream">
            <summary>
            Get the stream
            </summary>
            <returns></returns>
        </member>
        <member name="T:Yaapii.Atoms.IO.TeeInputStream">
            <summary>
            Readable <see cref="T:System.IO.Stream"/> that copies input to <see cref="T:Yaapii.Atoms.IOutput"/> while reading.
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.IO.TeeInputStream.input">
            <summary>
            input
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.IO.TeeInputStream.output">
            <summary>
            destination
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.TeeInputStream.#ctor(System.IO.Stream,System.IO.Stream)">
            <summary>
            Readable <see cref="T:System.IO.Stream"/> that copies input to <see cref="T:Yaapii.Atoms.IOutput"/> while reading.
            </summary>
            <param name="src">the source</param>
            <param name="tgt">the destination</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.TeeInputStream.Dispose(System.Boolean)">
            <summary>
            Clean up.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.IO.TeeOutput">
            <summary>
            A <see cref="T:Yaapii.Atoms.IOutput"/> which will copy to another <see cref="T:Yaapii.Atoms.IOutput"/> while writing.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.TeeOutput.#ctor(Yaapii.Atoms.IOutput,System.IO.StreamWriter)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IOutput"/> which will copy to another <see cref="T:Yaapii.Atoms.IOutput"/> while writing.
            </summary>
            <param name="tgt">the original target</param>
            <param name="cpy">the copy target</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.TeeOutput.#ctor(Yaapii.Atoms.IOutput,System.IO.StreamWriter,System.Text.Encoding)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IOutput"/> which will copy to another <see cref="T:System.IO.StreamWriter"/> while writing.
            </summary>
            <param name="tgt">the original target</param>
            <param name="cpy">the copy target</param>
            <param name="enc">encoding for the copy target</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.TeeOutput.#ctor(Yaapii.Atoms.IOutput,System.Uri)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IOutput"/> which will copy to a file <see cref="T:System.Uri"/> while writing.
            </summary>
            <param name="tgt">the original target</param>
            <param name="cpy">the copy target file <see cref="T:System.Uri"/></param>
        </member>
        <member name="M:Yaapii.Atoms.IO.TeeOutput.#ctor(Yaapii.Atoms.IOutput,System.IO.Stream)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IOutput"/> which will copy to a <see cref="M:Yaapii.Atoms.IO.TeeOutput.Stream"/> while writing.
            </summary>
            <param name="tgt">the original target</param>
            <param name="cpy">the copy target file <see cref="T:System.Uri"/></param>        
        </member>
        <member name="M:Yaapii.Atoms.IO.TeeOutput.#ctor(Yaapii.Atoms.IOutput,Yaapii.Atoms.IOutput)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IOutput"/> which will copy to another <see cref="T:Yaapii.Atoms.IOutput"/> while writing.
            </summary>
            <param name="tgt">the original target</param>
            <param name="cpy">the copy target file <see cref="T:System.Uri"/></param>        
        </member>
        <member name="M:Yaapii.Atoms.IO.TeeOutput.Stream">
            <summary>
            Get the stream.
            </summary>
            <returns>the stream</returns>
        </member>
        <member name="M:Yaapii.Atoms.IO.TeeOutput.Dispose">
            <summary>
            Clean up
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.IO.TeeOutputStream">
            <summary>
            <see cref="T:System.IO.Stream"/> which copies to another <see cref="T:System.IO.Stream"/> while writing.
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.IO.TeeOutputStream._target">
            <summary>
            the target
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.IO.TeeOutputStream._copy">
            <summary>
            the copy
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.TeeOutputStream.#ctor(System.IO.Stream,System.IO.Stream)">
            <summary>
            <see cref="T:System.IO.Stream"/> which copies to another <see cref="T:System.IO.Stream"/> while writing.
            </summary>
            <param name="tgt">the target</param>
            <param name="cpy">the copy target</param>
        </member>
        <member name="T:Yaapii.Atoms.IO.TeeReader">
            <summary>
            A  <see cref="T:System.IO.StreamReader"/> which copies to a <see cref="T:System.IO.StreamWriter"/> while reading.
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.IO.TeeReader._source">
            <summary>
            the source
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.IO.TeeReader._destination">
            <summary>
            the destination
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.TeeReader.#ctor(System.IO.StreamReader,System.IO.StreamWriter)">
            <summary>
            A  <see cref="T:System.IO.StreamReader"/> which copies to a <see cref="T:System.IO.StreamWriter"/> while reading.
            </summary>
            <param name="reader">the reader</param>
            <param name="writer">the copy target</param>
        </member>
        <member name="T:Yaapii.Atoms.IO.TempDirectory">
            <summary>
            A directory that cleans up when disposed.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.TempDirectory.#ctor">
            <summary>
            A directory that cleans up when disposed.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.TempDirectory.#ctor(System.String)">
            <summary>
            A directory that cleans up when disposed.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.TempDirectory.#ctor(Yaapii.Atoms.IScalar{System.String})">
            <summary>
            A directory that cleans up when disposed.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.IO.TempFile">
            <summary>
            Temporary file.
            The temporary file is deleted when the object is disposed.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.TempFile.#ctor(System.String)">
            <summary>
            Temporary file with given extension.
            The temporary file is deleted when the object is disposed.
            </summary>
            <param name="extension">The file extension for the temprary file</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.TempFile.#ctor(System.IO.FileInfo)">
            <summary>
            The temporary file is deleted when the object is disposed.
            </summary>
            <param name="file">The file</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.TempFile.#ctor">
            <summary>
            Ctor
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.TempFile.Value">
            <summary>
            Temporary file's path.
            The first call create the temporary file.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.TempFile.Dispose">
            <summary>
            Delete the temporary file.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.IO.UnzippedFile">
            <summary>
            Content of a file in a zip archive
            is tolerant to slash style
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.UnzippedFile.#ctor(Yaapii.Atoms.IInput,System.String)">
            <summary>
            Content of a file in a zip archive
            is tolerant to slash style
            leaves zip stream open
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.UnzippedFile.#ctor(Yaapii.Atoms.IInput,System.String,System.Boolean)">
            <summary>
            Content of a file in a zip archive
            is tolerant to slash style
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.IO.Url">
            <summary>
            www <see cref="T:System.Uri"/> from a <see cref="T:System.String"/> which checks for format.
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.IO.Url._source">
            <summary>
            the source
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.Url.#ctor(System.String)">
            <summary>
            Url from a <see cref="T:System.String"/> which checks for format.
            </summary>
            <param name="src">url prefixed with http:// or https://</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.Url.Value">
            <summary>
            Get the uri.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Yaapii.Atoms.IO.ValidatedZip">
            <summary>
            A validated Zip archive which is either a Pkzip or a Gzip (checked via lead bytes)
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.IO.WriterAsOutput">
            <summary>
            A <see cref="T:System.IO.StreamWriter"/> as <see cref="T:Yaapii.Atoms.IOutput"/>.
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.IO.WriterAsOutput._writer">
            <summary>
            the writer
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.IO.WriterAsOutput._decoder">
            <summary>
            encoding of the writer
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.WriterAsOutput.#ctor(System.IO.StreamWriter)">
            <summary>
            A <see cref="T:System.IO.StreamWriter"/> as <see cref="T:Yaapii.Atoms.IOutput"/>.
            </summary>
            <param name="wtr">a streamwriter</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.WriterAsOutput.#ctor(System.IO.StreamWriter,System.Text.Encoding)">
            <summary>
            A <see cref="T:System.IO.StreamWriter"/> as <see cref="T:Yaapii.Atoms.IOutput"/>.
            </summary>
            <param name="wtr">a streamwriter</param>
            <param name="enc">encoding of the streamwriter</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.WriterAsOutput.#ctor(System.IO.StreamWriter,System.Func{System.Text.Decoder})">
            <summary>
            A <see cref="T:System.IO.StreamWriter"/> as <see cref="T:Yaapii.Atoms.IOutput"/>.
            </summary>
            <param name="wtr">a streamwriter</param>
            <param name="fnc">function returning a decoder for the writer</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.WriterAsOutput.#ctor(System.IO.StreamWriter,Yaapii.Atoms.IScalar{System.Text.Decoder})">
            <summary>
            A <see cref="T:System.IO.StreamWriter"/> as <see cref="T:Yaapii.Atoms.IOutput"/>.
            </summary>
            <param name="wtr">a streamwriter</param>
            <param name="ddr">decoder for the writer</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.WriterAsOutput.Stream">
            <summary>
            Get the stream.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Yaapii.Atoms.IO.WriterAsOutput.Dispose">
            <summary>
            Clean up.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.IO.WriterAsOutputStream">
            <summary>
            <see cref="T:System.IO.StreamWriter"/> as a writable <see cref="T:System.IO.Stream"/>.
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.IO.WriterAsOutputStream._writer">
            <summary>
            the writer
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.IO.WriterAsOutputStream._decoder">
            <summary>
            encoding of the writer
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.WriterAsOutputStream.#ctor(System.IO.StreamWriter)">
            <summary>
            <see cref="T:System.IO.StreamWriter"/> as a writable <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="wtr">a writer</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.WriterAsOutputStream.#ctor(System.IO.StreamWriter,System.String)">
            <summary>
            <see cref="T:System.IO.StreamWriter"/> as a writable <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="wtr">a writer</param>
            <param name="encoding">encoding of the writer</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.WriterAsOutputStream.#ctor(System.IO.StreamWriter,System.Text.Encoding)">
            <summary>
            <see cref="T:System.IO.StreamWriter"/> as a writable <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="wtr">a writer</param>
            <param name="enc">encoding of the writer</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.WriterAsOutputStream.#ctor(System.IO.StreamWriter,Yaapii.Atoms.IScalar{System.Text.Decoder})">
            <summary>
            <see cref="T:System.IO.StreamWriter"/> as a writable <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="wtr">a writer</param>
            <param name="ddr">charset decoder for the writer</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.WriterAsOutputStream.Write(System.Int32)">
            <summary>
            <see cref="T:System.IO.StreamWriter"/> as a writable <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="data">some data</param>
        </member>
        <member name="T:Yaapii.Atoms.IO.WriterTo">
            <summary>
            A <see cref="T:System.IO.StreamWriter"/> to a target.
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.IO.WriterTo._target">
            <summary>
            the target
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.WriterTo.#ctor(System.Uri)">
            <summary>
            A <see cref="T:System.IO.StreamWriter"/> to a file <see cref="T:System.Uri"/>.
            </summary>
            <param name="path">a file Uri. Get with Path.GetFullPath(relOrAbsPath) or prefix with file:/// </param>
        </member>
        <member name="M:Yaapii.Atoms.IO.WriterTo.#ctor(System.IO.Stream)">
            <summary>
            A <see cref="T:System.IO.StreamWriter"/> to a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="stream">the output stream</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.WriterTo.#ctor(Yaapii.Atoms.IOutput)">
            <summary>
            A <see cref="T:System.IO.StreamWriter"/> to a <see cref="T:Yaapii.Atoms.IOutput"/>.
            </summary>
            <param name="output">the output</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.WriterTo.#ctor(Yaapii.Atoms.IOutput,System.Text.Encoding)">
            <summary>
            A <see cref="T:System.IO.StreamWriter"/> to a <see cref="T:Yaapii.Atoms.IOutput"/>.
            </summary>
            <param name="output">the output</param>
            <param name="enc">encoding of the output</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.WriterTo.#ctor(Yaapii.Atoms.IOutput,System.String)">
            <summary>
            A <see cref="T:System.IO.StreamWriter"/> to a <see cref="T:Yaapii.Atoms.IOutput"/>.
            </summary>
            <param name="output">the output</param>
            <param name="encoding">encoding of the output</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.WriterTo.#ctor(System.Func{System.IO.StreamWriter})">
            <summary>
            A <see cref="T:System.IO.StreamWriter"/> to a <see cref="T:Yaapii.Atoms.IOutput"/> returned by a <see cref="T:System.Func`1"/>.
            </summary>
            <param name="fnc">Function returning a streamwriter</param>
        </member>
        <member name="M:Yaapii.Atoms.IO.WriterTo.#ctor(Yaapii.Atoms.IScalar{System.IO.StreamWriter})">
            <summary>
            A <see cref="T:System.IO.StreamWriter"/> to a <see cref="T:Yaapii.Atoms.IOutput"/> encapsulated in a <see cref="T:Yaapii.Atoms.IScalar`1"/>.
            </summary>
            <param name="tgt">the target streamwriter</param>
        </member>
        <member name="T:Yaapii.Atoms.IO.ZipFiles">
            <summary>
            The files in a ZIP archive.
            Note: Extraction is sticky.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.ZipFiles.#ctor(Yaapii.Atoms.IInput)">
            <summary>
            The files in a ZIP archive.
            Note: Extraction is sticky.
            leaves zip stream open
            </summary>
            <param name="input"></param>
        </member>
        <member name="M:Yaapii.Atoms.IO.ZipFiles.#ctor(Yaapii.Atoms.IInput,System.Boolean)">
            <summary>
            The files in a ZIP archive.
            Note: Extraction is sticky.
            </summary>
            <param name="input"></param>
            <param name="leaveOpen"></param>
        </member>
        <member name="T:Yaapii.Atoms.IO.ZipMappedPaths">
            <summary>
            A zip input mapped from a given zip input
            Maps the zip entry paths according to the given mapping function
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.IO.ZipMappedPaths.#ctor(System.Func{System.String,System.String},Yaapii.Atoms.IInput)">
            <summary>
            A zip input mapped from a given zip input
            Maps the zip entry paths according to the given mapping function
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.OutputDeck.OutputNoNulls">
            <summary>
            <see cref="T:Yaapii.Atoms.IOutput"/> which does not accept null as stream
            </summary>
        </member>
        <member name="F:Yaapii.Atoms.OutputDeck.OutputNoNulls._origin">
            <summary>
            the origin
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.OutputDeck.OutputNoNulls.#ctor(Yaapii.Atoms.IOutput)">
            <summary>
            <see cref="T:Yaapii.Atoms.IOutput"/> which does not accept null as stream.
            </summary>
            <param name="output">the output</param>
        </member>
        <member name="M:Yaapii.Atoms.OutputDeck.OutputNoNulls.Stream">
            <summary>
            The stream.
            </summary>
            <returns>the stream, throws IOException if stream is null</returns>
        </member>
        <member name="M:Yaapii.Atoms.OutputDeck.OutputNoNulls.Dispose">
            <summary>
            Clean up.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Misc.IReverseCompare`1">
            <summary>
            <see cref="T:System.Collections.Generic.Comparer`1"/> that can compare reverse to help reversing lists.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Yaapii.Atoms.IScalar`1">
            <summary>
            A capsule for anything.
            </summary>
            <typeparam name="OutValue"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.IScalar`1.Value">
            <summary>
            Get the value.
            </summary>
            <returns>the value</returns>
        </member>
        <member name="T:Yaapii.Atoms.IText">
            
             Text. 
            
        </member>
        <member name="M:Yaapii.Atoms.IText.AsString">
            <summary>
            Get content as a string.
            </summary>
            <returns>the content as a string</returns>
        </member>
        <member name="T:Yaapii.Atoms.List.Joined`1">
            <summary>
            Multiple lists joined together as one.
            </summary>
            <typeparam name="T">type of items in list</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.List.Joined`1.#ctor(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{`0}[])">
            <summary>
            Multiple <see cref="T:System.Collections.Generic.IList`1"/> joined together
            </summary>
            <param name="origin">a list to join</param>
            <param name="src">lists to join</param>
        </member>
        <member name="M:Yaapii.Atoms.List.Joined`1.#ctor(System.Collections.Generic.IList{`0},`0[])">
            <summary>
            Multiple <see cref="T:System.Collections.Generic.IList`1"/> joined together
            </summary>
            <param name="src">The lists to join together</param>
            <param name="origin">a list to join</param>
        </member>
        <member name="M:Yaapii.Atoms.List.Joined`1.#ctor(System.Collections.Generic.IList{`0}[])">
            <summary>
            ctor
            </summary>
            <param name="src">The lists to join together</param>
        </member>
        <member name="M:Yaapii.Atoms.List.Joined`1.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.IList{`0}})">
            <summary>
            ctor
            </summary>
            <param name="src">The lists to join together</param>
        </member>
        <member name="T:Yaapii.Atoms.List.ListEnvelope`1">
            <summary>
            List envelope. Can make a readonly list from a scalar.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.List.ListEnvelope`1.#ctor(Yaapii.Atoms.IScalar{System.Collections.Generic.IEnumerable{`0}},System.Boolean)">
            <summary>
            ctor
            </summary>
            <param name="lst">A scalar to a <see cref="T:System.Collections.Generic.IList`1"/></param>
            <param name="live">value is handled live or sticky</param>
        </member>
        <member name="M:Yaapii.Atoms.List.ListEnvelope`1.#ctor(System.Func{System.Collections.Generic.IList{`0}},System.Boolean)">
            <summary>
            ctor
            </summary>
            <param name="live">value is handled live or sticky</param>
        </member>
        <member name="M:Yaapii.Atoms.List.ListEnvelope`1.#ctor(System.Func{System.Collections.Generic.IEnumerator{`0}},System.Boolean)">
            <summary>
            ctor
            </summary>
            <param name="live">value is handled live or sticky</param>
        </member>
        <member name="P:Yaapii.Atoms.List.ListEnvelope`1.Item(System.Int32)">
            <summary>
            access items
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:Yaapii.Atoms.List.ListEnvelope`1.Count">
            <summary>
            Count elements
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.List.ListEnvelope`1.Contains(`0)">
            <summary>
            Test if containing the given item
            </summary>
            <param name="item">Item to find</param>
            <returns>true if item is found</returns>
        </member>
        <member name="M:Yaapii.Atoms.List.ListEnvelope`1.CopyTo(`0[],System.Int32)">
            <summary>
            copy to a target array
            </summary>
            <param name="array">target array</param>
            <param name="arrayIndex">write start index</param>
        </member>
        <member name="M:Yaapii.Atoms.List.ListEnvelope`1.GetEnumerator">
            <summary>
            Enumerator for this list.
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Yaapii.Atoms.List.ListEnvelope`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Enumerator for this list.
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:Yaapii.Atoms.List.ListEnvelope`1.IndexOf(`0)">
            <summary>
            Index of given item
            </summary>
            <param name="item">item</param>
            <returns></returns>
        </member>
        <member name="P:Yaapii.Atoms.List.ListEnvelope`1.IsReadOnly">
            <summary>
            This is a readonly collection, always true.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.List.ListEnvelope`1.Add(`0)">
            <summary>
            Not supported.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Yaapii.Atoms.List.ListEnvelope`1.Clear">
            <summary>
            Unsupported.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.List.ListEnvelope`1.Insert(System.Int32,`0)">
            <summary>
            Unsupported.
            </summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:Yaapii.Atoms.List.ListEnvelope`1.Remove(`0)">
            <summary>
            Unsupported.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Yaapii.Atoms.List.ListEnvelope`1.RemoveAt(System.Int32)">
            <summary>
            Unsupported.
            </summary>
            <param name="index"></param>
        </member>
        <member name="T:Yaapii.Atoms.List.ListOf`1">
            <summary>
            Makes a readonly list.
            </summary>
            <typeparam name="T">type of items</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.List.ListOf`1.#ctor(`0[])">
            <summary>
            ctor
            </summary>
            <param name="array">source array</param>
        </member>
        <member name="M:Yaapii.Atoms.List.ListOf`1.#ctor(System.Collections.Generic.IEnumerator{`0})">
            <summary>
            ctor
            </summary>
            <param name="src">source enumerator</param>
        </member>
        <member name="M:Yaapii.Atoms.List.ListOf`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            ctor
            </summary>
            <param name="src">source enumerable</param>
        </member>
        <member name="T:Yaapii.Atoms.List.LiveList`1">
            <summary>
            Makes a readonly list.
            </summary>
            <typeparam name="T">type of items</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.List.LiveList`1.#ctor(System.Func{System.Collections.Generic.IList{`0}})">
            <summary>
            ctor
            </summary>
            <param name="src">source enumerable</param>
        </member>
        <member name="T:Yaapii.Atoms.List.Mapped`2">
            <summary>
            Mapped list
            </summary>
            <typeparam name="In">Type of source items</typeparam>
            <typeparam name="Out">Type of target items</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.List.Mapped`2.#ctor(Yaapii.Atoms.IFunc{`0,`1},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            ctor
            </summary>
            <param name="mapping">mapping function</param>
            <param name="src">source enumerator</param>
        </member>
        <member name="M:Yaapii.Atoms.List.Mapped`2.#ctor(System.Func{`0,`1},System.Collections.Generic.IEnumerator{`0})">
            <summary>
            ctor
            </summary>
            <param name="mapping">mapping function</param>
            <param name="src">source enumerator</param>
        </member>
        <member name="M:Yaapii.Atoms.List.Mapped`2.#ctor(System.Func{`0,`1},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            ctor
            </summary>
            <param name="mapping">mapping function</param>
            <param name="src">source enumerator</param>
        </member>
        <member name="M:Yaapii.Atoms.List.Mapped`2.#ctor(System.Func{`0,`1},System.Collections.Generic.ICollection{`0})">
            <summary>
            ctor
            </summary>
            <param name="mapping">mapping function</param>
            <param name="src">source enumerator</param>
        </member>
        <member name="T:Yaapii.Atoms.List.NotEmpty`1">
            <summary>
            Ensures that <see cref="T:System.Collections.Generic.IList`1" /> is not empty/>
            </summary>
            <typeparam name="T">Type of the list</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.List.NotEmpty`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            Ensures that <see cref="T:System.Collections.Generic.IList`1" /> is not empty/>
            </summary>
            <param name="origin">List</param>
        </member>
        <member name="M:Yaapii.Atoms.List.NotEmpty`1.#ctor(System.Collections.Generic.IList{`0},System.Exception)">
            <summary>
            Ensures that <see cref="T:System.Collections.Generic.IList`1" /> is not empty/>
            </summary>
            <param name="origin">List</param>
            <param name="ex">Execption to be thrown if empty</param>
        </member>
        <member name="T:Yaapii.Atoms.List.SolidList`1">
            <summary>
            A list that is both sticky and threadsafe.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.List.SolidList`1.#ctor(`0[])">
            <summary>
            ctor
            </summary>
            <param name="items">items to decorate</param>
        </member>
        <member name="M:Yaapii.Atoms.List.SolidList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            ctor
            </summary>
            <param name="items">items to decorate</param>
        </member>
        <member name="M:Yaapii.Atoms.List.SolidList`1.#ctor(System.Collections.Generic.IEnumerator{`0})">
            <summary>
            ctor
            </summary>
            <param name="enumerator">items to decorate</param>
        </member>
        <member name="M:Yaapii.Atoms.List.SolidList`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            ctor
            </summary>
            <param name="list">list to decorate</param>
        </member>
        <member name="T:Yaapii.Atoms.List.SyncList`1">
            <summary>
            A list which is threadsafe.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.List.SyncList`1.#ctor">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.List.SyncList`1.#ctor(System.Object)">
            <summary>
            ctor
            </summary>
            <param name="syncRoot"></param>
        </member>
        <member name="M:Yaapii.Atoms.List.SyncList`1.#ctor(`0[])">
            <summary>
            ctor
            </summary>
            <param name="items">items to make collection from</param>
        </member>
        <member name="M:Yaapii.Atoms.List.SyncList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            ctor
            </summary>
            <param name="lst">Collection to sync</param>
        </member>
        <member name="M:Yaapii.Atoms.List.SyncList`1.#ctor(System.Object,System.Collections.Generic.IList{`0})">
            <summary>
            ctor
            </summary>
            <param name="syncRoot">root object to sync</param>
            <param name="col"></param>
        </member>
        <member name="T:Yaapii.Atoms.Map.EmptyMap">
            <summary>
            A map without entries
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.EmptyMap.#ctor">
            <summary>
            A map without entries
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Map.FallbackMap`2">
            <summary>
            Map which can return a fallback value generated by a fallback function
            </summary>
            <typeparam name="Key">Key Type of the Map</typeparam>
            <typeparam name="Value">Value Type of the Map</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Map.FallbackMap`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Map which can return a fallback value generated by a fallback function
            </summary>
            <param name="map">Map returning existing values</param>
            <param name="fallbackMap">Fallback map containing missing values</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.FallbackMap`2.#ctor(System.Func{System.Collections.Generic.IDictionary{`0,`1}},System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Map which can return a fallback value generated by a fallback function
            </summary>
            <param name="map">Map returning existing values</param>
            <param name="fallbackMap">Fallback map containing missing values</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.FallbackMap`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Func{`0,`1})">
            <summary>
            Map which can return a fallback value generated by a fallback function
            </summary>
            <param name="map">Map returning existing values</param>
            <param name="fallback">Fallback generating missing values</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.FallbackMap`2.#ctor(System.Func{System.Collections.Generic.IDictionary{`0,`1}},System.Func{`0,`1})">
            <summary>
            Map which can return a fallback value generated by a fallback function
            </summary>
            <param name="map">Map returning existing values</param>
            <param name="fallback">Fallback generating missing values</param>
        </member>
        <member name="T:Yaapii.Atoms.Map.FallbackMap`1">
            <summary>
            Map which can return a fallback value generated by a fallback function
            </summary>
            <typeparam name="Value">Value Type of the Map</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Map.FallbackMap`1.#ctor(System.Collections.Generic.IDictionary{System.String,`0},System.Collections.Generic.IDictionary{System.String,`0})">
            <summary>
            Map which can return a fallback value generated by a fallback function
            </summary>
            <param name="map">Map returning existing values</param>
            <param name="fallbackMap">Fallback map containing missing values</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.FallbackMap`1.#ctor(System.Func{System.Collections.Generic.IDictionary{System.String,`0}},System.Collections.Generic.IDictionary{System.String,`0})">
            <summary>
            Map which can return a fallback value generated by a fallback function
            </summary>
            <param name="map">Map returning existing values</param>
            <param name="fallbackMap">Fallback map containing missing values</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.FallbackMap`1.#ctor(System.Collections.Generic.IDictionary{System.String,`0},System.Func{System.String,`0})">
            <summary>
            Map which can return a fallback value generated by a fallback function
            </summary>
            <param name="map">Map returning existing values</param>
            <param name="fallback">Fallback generating missing values</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.FallbackMap`1.#ctor(System.Func{System.Collections.Generic.IDictionary{System.String,`0}},System.Func{System.String,`0})">
            <summary>
            Map which can return a fallback value generated by a fallback function
            </summary>
            <param name="map">Map returning existing values</param>
            <param name="fallback">Fallback generating missing values</param>
        </member>
        <member name="T:Yaapii.Atoms.Map.FallbackMap">
            <summary>
            Map which can return a fallback value generated by a fallback function
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.FallbackMap.#ctor(System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Map which can return a fallback value generated by a fallback function
            </summary>
            <param name="map">Map returning existing values</param>
            <param name="fallbackMap">Fallback map containing missing values</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.FallbackMap.#ctor(System.Func{System.Collections.Generic.IDictionary{System.String,System.String}},System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Map which can return a fallback value generated by a fallback function
            </summary>
            <param name="map">Map returning existing values</param>
            <param name="fallbackMap">Fallback map containing missing values</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.FallbackMap.#ctor(System.Collections.Generic.IDictionary{System.String,System.String},System.Func{System.String,System.String})">
            <summary>
            Map which can return a fallback value generated by a fallback function
            </summary>
            <param name="map">Map returning existing values</param>
            <param name="fallback">Fallback generating missing values</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.FallbackMap.#ctor(System.Func{System.Collections.Generic.IDictionary{System.String,System.String}},System.Func{System.String,System.String})">
            <summary>
            Map which can return a fallback value generated by a fallback function
            </summary>
            <param name="map">Map returning existing values</param>
            <param name="fallback">Fallback generating missing values</param>
        </member>
        <member name="T:Yaapii.Atoms.Map.FkKvp`2">
            <summary>
            Fake Kvp
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.FkKvp`2.#ctor(System.Func{`0},System.Func{`1},System.Func{System.Boolean})">
            <summary>
            Fake Kvp
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Map.Grouped`3">
            <summary>
            Groups a list to Keys and Lists of Values according to the given Functions
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="Key"></typeparam>
            <typeparam name="Value"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Map.Grouped`3.#ctor(System.Collections.Generic.IEnumerable{`0},Yaapii.Atoms.IFunc{`0,`1},Yaapii.Atoms.IFunc{`0,`2})">
            <summary>
            ctor
            </summary>
            <param name="src">Source Enumerable</param>
            <param name="key">Function to convert Source Type to Key Type</param>
            <param name="value">Function to Convert Source Type to Key Týpe</param>
        </member>
        <member name="T:Yaapii.Atoms.Map.Joined">
            <summary>
            Joined map.
            Since 9.9.2019
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.Joined.#ctor(Yaapii.Atoms.IKvp,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Joined map.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.Joined.#ctor(IMapInput,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Joined map.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.Joined.#ctor(System.Collections.Generic.IDictionary{System.String,System.String}[])">
            <summary>
            Joined map.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.Joined.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.IDictionary{System.String,System.String}},System.Boolean)">
            <summary>
            Joined map.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Map.Joined`1">
            <summary>
            Joined map.
            Since 9.9.2019
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.Joined`1.#ctor(Yaapii.Atoms.IKvp{`0},System.Collections.Generic.IDictionary{System.String,`0},System.Boolean)">
            <summary>
            Joined map.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.Joined`1.#ctor(IMapInput{`0},System.Collections.Generic.IDictionary{System.String,`0},System.Boolean)">
            <summary>
            Joined map.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.Joined`1.#ctor(System.Collections.Generic.IDictionary{System.String,`0}[])">
            <summary>
            Joined map.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.Joined`1.#ctor(System.Boolean,System.Collections.Generic.IDictionary{System.String,`0}[])">
            <summary>
            Joined map.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.Joined`1.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.IDictionary{System.String,`0}},System.Boolean)">
            <summary>
            Joined map.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Map.Joined`2">
            <summary>
            Joined map.
            Since 9.9.2019
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.Joined`2.#ctor(Yaapii.Atoms.IKvp{`0,`1},System.Collections.Generic.IDictionary{`0,`1},System.Boolean)">
            <summary>
            Joined map.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.Joined`2.#ctor(IMapInput{`0,`1},System.Collections.Generic.IDictionary{`0,`1},System.Boolean)">
            <summary>
            Joined map.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.Joined`2.#ctor(System.Boolean,System.Collections.Generic.IDictionary{`0,`1}[])">
            <summary>
            Joined map.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.Joined`2.#ctor(System.Collections.Generic.IDictionary{`0,`1}[])">
            <summary>
            Joined map.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.Joined`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.IDictionary{`0,`1}},System.Boolean)">
            <summary>
            Joined map.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Map.KvpEnvelope">
            <summary>
            Simplification of Kvp-class-building.
            Since 9.9.2019
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Map.KvpEnvelope`1">
            <summary>
            Simplification of Kvp building.
            Since 9.9.2019
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.KvpEnvelope`1.#ctor(Yaapii.Atoms.IKvp{`0})">
            <summary>
            Simplification of Kvp building
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Map.KvpEnvelope`2">
            <summary>
            Simplification of Kvp-class-building.
            Since 9.9.2019
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.KvpEnvelope`2.#ctor(Yaapii.Atoms.IKvp{`0,`1})">
            <summary>
            Simplification of KVP building
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Map.KvpOf">
            <summary>
            Key-value pair made of strings.
            Since 9.9.2019
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.KvpOf.#ctor(Yaapii.Atoms.IText,System.Func{System.String})">
            <summary>
            Key-value pair made of strings.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.KvpOf.#ctor(Yaapii.Atoms.IText,System.String)">
            <summary>
            Key-value pair made of strings.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.KvpOf.#ctor(System.String,System.Func{System.String})">
            <summary>
            Key-value pair made of strings.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.KvpOf.#ctor(System.String,System.String)">
            <summary>
            Key-value pair made of strings.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.KvpOf.#ctor(Yaapii.Atoms.IScalar{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Key-value pair made of strings.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.KvpOf.#ctor(System.Func{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Key-value pair made of strings.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Map.KvpOf`1">
            <summary>
            Key-value pair matching a string to specified type value.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.KvpOf`1.#ctor(Yaapii.Atoms.IText,System.Func{`0})">
            <summary>
            Key-value pair matching a string to specified type value.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.KvpOf`1.#ctor(Yaapii.Atoms.IText,`0)">
            <summary>
            Key-value pair matching a string to specified type value.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.KvpOf`1.#ctor(System.String,System.Func{`0})">
            <summary>
            Key-value pair matching a string to specified type value.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.KvpOf`1.#ctor(System.String,`0)">
            <summary>
            Key-value pair matching a string to specified type value.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.KvpOf`1.#ctor(Yaapii.Atoms.IScalar{System.Collections.Generic.KeyValuePair{System.String,`0}})">
            <summary>
            Key-value pair matching a string to specified type value.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.KvpOf`1.#ctor(System.Func{System.Collections.Generic.KeyValuePair{System.String,`0}})">
            <summary>
            Key-value pair matching a string to specified type value.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Map.KvpOf`2">
            <summary>
            Key-value pair matching a key type to specified type value.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.KvpOf`2.#ctor(`0,System.Func{`1})">
            <summary>
            Key-value pair matching a key type to specified type value.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.KvpOf`2.#ctor(`0,`1)">
            <summary>
            Key-value pair matching a key type to specified type value.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.KvpOf`2.#ctor(Yaapii.Atoms.IScalar{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Key-value pair matching a key type to specified type value.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.KvpOf`2.#ctor(System.Func{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Key-value pair matching a key type to specified type value.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Map.KvpOfMany">
            <summary>
            A key to many strings.
            Since 1.9.2019
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.KvpOfMany.#ctor(System.String,System.Func{System.String}[])">
            <summary>
            A key to many values.
            The functions are executed only when the value is requested.
            The result is sticky.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.KvpOfMany.#ctor(System.String,System.String[])">
            <summary>
            A key to many values.
            The functions are executed only when the value is requested.
            The result is sticky.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.KvpOfMany.#ctor(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            A key to many values.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.KvpOfMany.#ctor(System.String,System.Func{System.Collections.Generic.IEnumerable{System.String}})">
            <summary>
            A key to many strings.
            The function is executed only when the value is requested.
            The result is sticky.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Map.KvpOfMany`1">
            <summary>
            A key to many values.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.KvpOfMany`1.#ctor(System.String,System.Func{`0}[])">
            <summary>
            A key to many strings.
            The functions are executed only when the value is requested.
            The result is sticky.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.KvpOfMany`1.#ctor(System.String,`0[])">
            <summary>
            A key to many strings.
            The functions are executed only when the value is requested.
            The result is sticky.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.KvpOfMany`1.#ctor(System.String,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            A key to many strings.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.KvpOfMany`1.#ctor(System.String,System.Func{System.Collections.Generic.IEnumerable{`0}})">
            <summary>
            A key to many values.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Map.KeyToValues`2">
            <summary>
            A key to many values.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.KeyToValues`2.#ctor(`0,System.Func{`1}[])">
            <summary>
            A key to many values.
            The functions are executed only when the value is requested.
            The result is sticky.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.KeyToValues`2.#ctor(`0,`1[])">
            <summary>
            A key to many values.
            The functions are executed only when the value is requested.
            The result is sticky.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.KeyToValues`2.#ctor(`0,System.Collections.Generic.IEnumerable{`1})">
            <summary>
            A key to many values.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.KeyToValues`2.#ctor(`0,System.Func{System.Collections.Generic.IEnumerable{`1}})">
            <summary>
            A key to many values.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Map.LazyDict">
            <summary>
            A dictionary whose values are retrieved only when accessing them.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict.#ctor(Yaapii.Atoms.IKvp[])">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict.#ctor(System.Boolean,Yaapii.Atoms.IKvp[])">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict.#ctor(System.Collections.Generic.IEnumerable{Yaapii.Atoms.IKvp},System.Boolean)">
            <summary>
            ctor
            </summary>
        </member>
        <member name="P:Yaapii.Atoms.Map.LazyDict.Item(System.String)">
            <summary>
            Access a value by key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:Yaapii.Atoms.Map.LazyDict.Keys">
            <summary>
            Access all keys
            </summary>
        </member>
        <member name="P:Yaapii.Atoms.Map.LazyDict.Values">
            <summary>
            Access all values
            </summary>
        </member>
        <member name="P:Yaapii.Atoms.Map.LazyDict.Count">
            <summary>
            Count entries
            </summary>
        </member>
        <member name="P:Yaapii.Atoms.Map.LazyDict.IsReadOnly">
            <summary>
            Yes its readonly
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict.Add(System.String,System.String)">
            <summary>
            Unsupported
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict.Add(System.Collections.Generic.KeyValuePair{System.String,System.String})">
            <summary>
            Unsupported
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict.Clear">
            <summary>
            Unsupported
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict.Contains(System.Collections.Generic.KeyValuePair{System.String,System.String})">
            <summary>
            Test if map contains entry
            </summary>
            <param name="item">item to check</param>
            <returns>true if it contains</returns>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict.ContainsKey(System.String)">
            <summary>
            Test if map contains key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict.CopyTo(System.Collections.Generic.KeyValuePair{System.String,System.String}[],System.Int32)">
            <summary>
            Copy this to an array
            </summary>
            <param name="array">target array</param>
            <param name="arrayIndex">index to start</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict.GetEnumerator">
            <summary>
            The enumerator
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict.Remove(System.String)">
            <summary>
            Unsupported
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict.Remove(System.Collections.Generic.KeyValuePair{System.String,System.String})">
            <summary>
            Unsupported
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict.TryGetValue(System.String,System.String@)">
            <summary>
            Tries to get value
            </summary>
            <param name="key">key</param>
            <param name="value">target to store value</param>
            <returns>true if success</returns>
        </member>
        <member name="T:Yaapii.Atoms.Map.LazyDict`1">
            <summary>
            A dictionary whose values are retrieved only when accessing them.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict`1.#ctor(Yaapii.Atoms.IKvp{`0}[])">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict`1.#ctor(System.Boolean,Yaapii.Atoms.IKvp{`0}[])">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict`1.#ctor(System.Collections.Generic.IEnumerable{Yaapii.Atoms.IKvp{`0}},System.Boolean)">
            <summary>
            ctor
            </summary>
        </member>
        <member name="P:Yaapii.Atoms.Map.LazyDict`1.Item(System.String)">
            <summary>
            Access a value by key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:Yaapii.Atoms.Map.LazyDict`1.Keys">
            <summary>
            Access all keys
            </summary>
        </member>
        <member name="P:Yaapii.Atoms.Map.LazyDict`1.Values">
            <summary>
            Access all values
            </summary>
        </member>
        <member name="P:Yaapii.Atoms.Map.LazyDict`1.Count">
            <summary>
            Count entries
            </summary>
        </member>
        <member name="P:Yaapii.Atoms.Map.LazyDict`1.IsReadOnly">
            <summary>
            Yes its readonly
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict`1.Add(System.String,`0)">
            <summary>
            Unsupported
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict`1.Add(System.Collections.Generic.KeyValuePair{System.String,`0})">
            <summary>
            Unsupported
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict`1.Clear">
            <summary>
            Unsupported
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict`1.Contains(System.Collections.Generic.KeyValuePair{System.String,`0})">
            <summary>
            Test if map contains entry
            </summary>
            <param name="item">item to check</param>
            <returns>true if it contains</returns>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict`1.ContainsKey(System.String)">
            <summary>
            Test if map contains key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict`1.CopyTo(System.Collections.Generic.KeyValuePair{System.String,`0}[],System.Int32)">
            <summary>
            Copy this to an array
            </summary>
            <param name="array">target array</param>
            <param name="arrayIndex">index to start</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict`1.GetEnumerator">
            <summary>
            The enumerator
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict`1.Remove(System.String)">
            <summary>
            Unsupported
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict`1.Remove(System.Collections.Generic.KeyValuePair{System.String,`0})">
            <summary>
            Unsupported
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict`1.TryGetValue(System.String,`0@)">
            <summary>
            Tries to get value
            </summary>
            <param name="key">key</param>
            <param name="value">target to store value</param>
            <returns>true if success</returns>
        </member>
        <member name="T:Yaapii.Atoms.Map.LazyDict`2">
            <summary>
            A dictionary whose values are retrieved only when accessing them.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict`2.#ctor(Yaapii.Atoms.IKvp{`0,`1}[])">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict`2.#ctor(System.Boolean,Yaapii.Atoms.IKvp{`0,`1}[])">
            <summary>
            ctor
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict`2.#ctor(System.Collections.Generic.IEnumerable{Yaapii.Atoms.IKvp{`0,`1}},System.Boolean)">
            <summary>
            ctor
            </summary>
        </member>
        <member name="P:Yaapii.Atoms.Map.LazyDict`2.Item(`0)">
            <summary>
            Access a value by key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:Yaapii.Atoms.Map.LazyDict`2.Keys">
            <summary>
            Access all keys
            </summary>
        </member>
        <member name="P:Yaapii.Atoms.Map.LazyDict`2.Values">
            <summary>
            Access all values
            </summary>
        </member>
        <member name="P:Yaapii.Atoms.Map.LazyDict`2.Count">
            <summary>
            Count entries
            </summary>
        </member>
        <member name="P:Yaapii.Atoms.Map.LazyDict`2.IsReadOnly">
            <summary>
            Yes its readonly
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict`2.Add(`0,`1)">
            <summary>
            Unsupported
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Unsupported
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict`2.Clear">
            <summary>
            Unsupported
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Test if map contains entry
            </summary>
            <param name="item">item to check</param>
            <returns>true if it contains</returns>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict`2.ContainsKey(`0)">
            <summary>
            Test if map contains key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copy this to an array
            </summary>
            <param name="array">target array</param>
            <param name="arrayIndex">index to start</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict`2.GetEnumerator">
            <summary>
            The enumerator
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict`2.Remove(`0)">
            <summary>
            Unsupported
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Unsupported
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Yaapii.Atoms.Map.LazyDict`2.TryGetValue(`0,`1@)">
            <summary>
            Tries to get value
            </summary>
            <param name="key">key</param>
            <param name="value">target to store value</param>
            <returns>true if success</returns>
        </member>
        <member name="T:Yaapii.Atoms.Map.LiveMap">
            <summary>
            A map from string to string.
            You must understand, that this map will build every time when any method is called.
            If you do not want this, use <see cref="T:Yaapii.Atoms.Map.MapOf"/>
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.LiveMap.#ctor(System.Func{System.Collections.Generic.IEnumerable{Yaapii.Atoms.IKvp}})">
            <summary>
            A map from the given key value pairs.
            </summary>
            <param name="entries">enumerable of kvps</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.LiveMap.#ctor(System.Func{System.Collections.Generic.IDictionary{System.String,System.String}})">
            <summary>
            A map from the given dictionary.
            </summary>
            <param name="input">input dictionary</param>
        </member>
        <member name="T:Yaapii.Atoms.Map.LiveMap`1">
            <summary>
            A map from string to typed value.
            You must understand, that this map will build every time when any method is called.
            If you do not want this, use <see cref="T:Yaapii.Atoms.Map.MapOf"/>
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.LiveMap`1.#ctor(System.Func{System.Collections.Generic.IEnumerable{Yaapii.Atoms.IKvp{`0}}})">
            <summary>
            A map from the given key value pairs.
            </summary>
            <param name="entries">enumerable of kvps</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.LiveMap`1.#ctor(System.Func{System.Collections.Generic.IDictionary{System.String,`0}})">
            <summary>
            A map from the given dictionary.
            </summary>
            <param name="input">input dictionary</param>
        </member>
        <member name="T:Yaapii.Atoms.Map.LiveMap`2">
            <summary>
            A map from one type to another.
            You must understand, that this map will build every time when any method is called.
            If you do not want this, use <see cref="T:Yaapii.Atoms.Map.MapOf"/>
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.LiveMap`2.#ctor(System.Func{System.Collections.Generic.IEnumerable{Yaapii.Atoms.IKvp{`0,`1}}},System.Boolean)">
            <summary>
            A map from the given key value pairs.
            </summary>
            <param name="entries">enumerable of kvps</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.LiveMap`2.#ctor(System.Func{System.Collections.Generic.IDictionary{`0,`1}})">
            <summary>
            A map from the given dictionary.
            </summary>
            <param name="input">input dictionary</param>
        </member>
        <member name="T:Yaapii.Atoms.Map.MapEnvelope">
            <summary>
            Simplified map building.
            Since 9.9.2019
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapEnvelope.#ctor(System.Func{System.Collections.Generic.IDictionary{System.String,System.String}},System.Boolean)">
            <summary>
            Simplified map building.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Map.MapEnvelope`1">
            <summary>
            Simplified map building.
            Since 9.9.2019
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapEnvelope`1.#ctor(System.Func{System.Collections.Generic.IDictionary{System.String,`0}},System.Boolean)">
            <summary>
            Simplified map building.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Map.MapEnvelope`2">
            <summary>
            Simplified map building.
            Since 9.9.2019
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapEnvelope`2.#ctor(System.Func{System.Collections.Generic.IDictionary{`0,`1}},System.Boolean)">
            <summary>
            Simplified map building.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Map.MapInputEnvelope">
            <summary>
            Simplified MapInput building.
            Since 9.9.2019
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapInputEnvelope.#ctor(System.Func{IMapInput})">
            <summary>
            Simplified DictInput building.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapInputEnvelope.#ctor(Yaapii.Atoms.IScalar{IMapInput})">
            <summary>
            Simplified DictInput building.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapInputEnvelope.#ctor(Yaapii.Atoms.IKvp[])">
            <summary>
            Simplified DictInput building.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapInputEnvelope.#ctor(System.Collections.Generic.IEnumerable{Yaapii.Atoms.IKvp})">
            <summary>
            Simplified DictInput building.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapInputEnvelope.#ctor(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Simplified DictInput building.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapInputEnvelope.#ctor(System.Func{System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,System.String}})">
            <summary>
            Simplified DictInput building.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapInputEnvelope.Apply(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Apply this input to a map.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapInputEnvelope.Self">
            <summary>
            Return this as IMapInput.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Yaapii.Atoms.Map.MapInputEnvelope`1">
            <summary>
            Simplified MapInput building.
            Since 9.9.2019
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapInputEnvelope`1.#ctor(System.Func{IMapInput{`0}})">
            <summary>
            Simplified DictInput building.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapInputEnvelope`1.#ctor(Yaapii.Atoms.IScalar{IMapInput{`0}})">
            <summary>
            Simplified DictInput building.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapInputEnvelope`1.#ctor(Yaapii.Atoms.IKvp{`0}[])">
            <summary>
            Simplified DictInput building.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapInputEnvelope`1.#ctor(System.Collections.Generic.IEnumerable{Yaapii.Atoms.IKvp{`0}})">
            <summary>
            Simplified DictInput building.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapInputEnvelope`1.#ctor(System.Collections.Generic.IDictionary{System.String,`0})">
            <summary>
            Simplified DictInput building.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapInputEnvelope`1.#ctor(System.Func{System.Collections.Generic.IDictionary{System.String,`0},System.Collections.Generic.IDictionary{System.String,`0}})">
            <summary>
            Simplified DictInput building.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapInputEnvelope`1.Apply(System.Collections.Generic.IDictionary{System.String,`0})">
            <summary>
            Apply this input to a map.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapInputEnvelope`1.Self">
            <summary>
            Return this as IMapInput.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Yaapii.Atoms.Map.MapInputEnvelope`2">
            <summary>
            Simplified MapInput building.
            Since 9.9.2019
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapInputEnvelope`2.#ctor(System.Func{IMapInput{`0,`1}})">
            <summary>
            Simplified DictInput building.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapInputEnvelope`2.#ctor(Yaapii.Atoms.IScalar{IMapInput{`0,`1}})">
            <summary>
            Simplified DictInput building.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapInputEnvelope`2.#ctor(Yaapii.Atoms.IKvp{`0,`1}[])">
            <summary>
            Simplified DictInput building.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapInputEnvelope`2.#ctor(System.Collections.Generic.IEnumerable{Yaapii.Atoms.IKvp{`0,`1}})">
            <summary>
            Simplified DictInput building.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapInputEnvelope`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Simplified DictInput building.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapInputEnvelope`2.#ctor(System.Func{System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IDictionary{`0,`1}})">
            <summary>
            Simplified DictInput building.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapInputEnvelope`2.Apply(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Apply this input to a map.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapInputEnvelope`2.Self">
            <summary>
            Return this as IMapInput.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Yaapii.Atoms.Map.MapInputOf">
            <summary>
            MapInput from key-value pairs.
            Since 9.9.2019
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapInputOf.#ctor(Yaapii.Atoms.IKvp[])">
            <summary>
            MapInput from key-value pairs.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapInputOf.#ctor(System.Collections.Generic.IEnumerable{Yaapii.Atoms.IKvp})">
            <summary>
            MapInput from key-value pairs.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Map.MapInputOf`1">
            <summary>
            MapInput from key-value pairs.
            Since 9.9.2019
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapInputOf`1.#ctor(Yaapii.Atoms.IKvp{`0}[])">
            <summary>
            MapInput from key-value pairs.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapInputOf`1.#ctor(System.Collections.Generic.IEnumerable{Yaapii.Atoms.IKvp{`0}})">
            <summary>
            MapInput from key-value pairs.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Map.MapInputOf`2">
            <summary>
            MapInput from key-value pairs.
            Since 9.9.2019
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapInputOf`2.#ctor(Yaapii.Atoms.IKvp{`0,`1}[])">
            <summary>
            MapInput from key-value pairs.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapInputOf`2.#ctor(System.Collections.Generic.IEnumerable{Yaapii.Atoms.IKvp{`0,`1}})">
            <summary>
            MapInput from key-value pairs.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Map.MapOf">
            <summary>
            A map from string to string.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf.#ctor(System.Collections.Generic.KeyValuePair{System.String,System.String},System.Collections.Generic.KeyValuePair{System.String,System.String}[])">
            <summary>
            A map from the given KeyValuePairs
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf.#ctor(System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.KeyValuePair{System.String,System.String}[])">
            <summary>
            A map from the given KeyValuePairs and appends them to the given Dictionary.
            </summary>
            <param name="src">source dictionary</param>
            <param name="list">KeyValuePairs to append</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf.#ctor(System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            A map by merging the given KeyValuePairs to the given Dictionary.
            </summary>
            <param name="src"></param>
            <param name="list"></param>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf.#ctor(System.Collections.Generic.IEnumerator{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            A map by taking the given entries.
            </summary>
            <param name="entries">enumerator of KeyValuePairs</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf.#ctor(Yaapii.Atoms.IKvp,Yaapii.Atoms.IKvp[])">
            <summary>
            A map from the given key value pairs.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf.#ctor(System.Collections.Generic.IEnumerable{Yaapii.Atoms.IKvp})">
            <summary>
            A map from the given key value pairs.
            Rejects building of all values
            </summary>
            <param name="entries">enumerable of kvps</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf.#ctor(System.Collections.Generic.IEnumerable{Yaapii.Atoms.IKvp},System.Boolean)">
            <summary>
            A map from the given key value pairs.
            </summary>
            <param name="entries">enumerable of kvps</param>
            <param name="rejectBuildingAllValues">if you have KVPs with value functions, it is by default prevented to build all values by getting the enumerator. You can deactivate that here.</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf.#ctor(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            A map from another map.
            </summary>
            <param name="entries">enumerable of entries</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            A map from the given entries.
            </summary>
            <param name="entries">enumerable of entries</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf.#ctor(System.String,System.String,System.String[])">
            <summary>
            A map from string to string.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            A map from string to string.
            </summary>
            <param name="pairSequence">Pairs as a sequence, ordered like this: key-1, value-1, ... key-n, value-n</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf.#ctor(IMapInput[])">
            <summary>
            A map from the given inputs.
            </summary>
            <param name="inputs">inputs</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf.#ctor(System.Collections.Generic.IEnumerable{IMapInput})">
            <summary>
            A map from the given inputs.
            </summary>
            <param name="inputs">enumerable of map inputs</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf.#ctor(System.Func{System.Collections.Generic.IDictionary{System.String,System.String}})">
            <summary>
            A map from the given dictionary.
            </summary>
            <param name="input">input dictionary</param>
        </member>
        <member name="T:Yaapii.Atoms.Map.MapOf`1">
            <summary>
            A map from string to typed value.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf`1.#ctor(System.Collections.Generic.KeyValuePair{System.String,`0},System.Collections.Generic.KeyValuePair{System.String,`0}[])">
            <summary>
            A map from the given KeyValuePairs
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf`1.#ctor(System.Collections.Generic.IEnumerator{System.Collections.Generic.KeyValuePair{System.String,`0}})">
            <summary>
            A map by taking the given entries.
            </summary>
            <param name="entries">enumerator of KeyValuePairs</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf`1.#ctor(Yaapii.Atoms.IKvp{`0},Yaapii.Atoms.IKvp{`0}[])">
            <summary>
            A map from the given IKvps.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf`1.#ctor(System.Collections.Generic.IEnumerable{Yaapii.Atoms.IKvp{`0}},System.Boolean)">
            <summary>
            A map from the given key value pairs.
            </summary>
            <param name="entries">enumerable of kvps</param>
            <param name="rejectBuildingAllValues">if you have KVPs with value functions, it is by default prevented to build all values by getting the enumerator. You can deactivate that here.</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf`1.#ctor(System.Collections.Generic.IDictionary{System.String,`0})">
            <summary>
            A map from another map.
            </summary>
            <param name="entries">enumerable of entries</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf`1.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,`0}})">
            <summary>
            A map from the given entries.
            </summary>
            <param name="entries">enumerable of entries</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf`1.#ctor(IMapInput{`0}[])">
            <summary>
            A map from the given inputs.
            </summary>
            <param name="inputs">inputs</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf`1.#ctor(System.Collections.Generic.IEnumerable{IMapInput{`0}})">
            <summary>
            A map from the given inputs.
            </summary>
            <param name="inputs">enumerable of map inputs</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf`1.#ctor(System.Func{System.Collections.Generic.IDictionary{System.String,`0}})">
            <summary>
            A map from the given dictionary.
            </summary>
            <param name="input">input dictionary</param>
        </member>
        <member name="T:Yaapii.Atoms.Map.MapOf`2">
            <summary>
            A map from string to typed value.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf`2.#ctor(System.Collections.Generic.KeyValuePair{`0,`1},System.Collections.Generic.KeyValuePair{`0,`1}[])">
            <summary>
            A map from the given KeyValuePairs
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.KeyValuePair{`0,`1}[])">
            <summary>
            A map from the given KeyValuePairs and appends them to the given Dictionary.
            </summary>
            <param name="src">source dictionary</param>
            <param name="list">KeyValuePairs to append</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            A map by merging the given KeyValuePairs to the given Dictionary.
            </summary>
            <param name="src"></param>
            <param name="list"></param>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf`2.#ctor(System.Collections.Generic.IEnumerator{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            A map by taking the given entries.
            </summary>
            <param name="entries">enumerator of KeyValuePairs</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf`2.#ctor(Yaapii.Atoms.IKvp{`0,`1},Yaapii.Atoms.IKvp{`0,`1}[])">
            <summary>
            A map from the given key value pairs.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf`2.#ctor(System.Collections.Generic.IEnumerable{Yaapii.Atoms.IKvp{`0,`1}},System.Boolean)">
            <summary>
            A map from the given key value pairs.
            </summary>
            <param name="entries">enumerable of kvps</param>
            <param name="rejectBuildingAllValues">if you have KVPs with value functions, it is by default prevented to build all values by getting the enumerator. You can deactivate that here.</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            A map from another map.
            </summary>
            <param name="entries">enumerable of entries</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            A map from the given entries.
            </summary>
            <param name="entries">enumerable of entries</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf`2.#ctor(IMapInput{`0,`1}[])">
            <summary>
            A map from the given inputs.
            </summary>
            <param name="inputs">inputs</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf`2.#ctor(System.Collections.Generic.IEnumerable{IMapInput{`0,`1}})">
            <summary>
            A map from the given inputs.
            </summary>
            <param name="inputs">enumerable of map inputs</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.MapOf`2.#ctor(System.Func{System.Collections.Generic.IDictionary{`0,`1}})">
            <summary>
            A map from the given dictionary.
            </summary>
            <param name="input">input dictionary</param>
        </member>
        <member name="T:Yaapii.Atoms.Map.NoNulls`2">
            <summary>
            A decorator of map that tolerates no NULLs.
            </summary>
            <typeparam name="Key">type of key</typeparam>
            <typeparam name="Value">type of value</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Map.NoNulls`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            ctor
            </summary>
            <param name="map">IDictionary</param>
        </member>
        <member name="P:Yaapii.Atoms.Map.NoNulls`2.Item(`0)">
            <summary>
            Access a value by key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:Yaapii.Atoms.Map.NoNulls`2.Keys">
            <summary>
            Access all keys
            </summary>
        </member>
        <member name="P:Yaapii.Atoms.Map.NoNulls`2.Values">
            <summary>
            Access all values
            </summary>
        </member>
        <member name="P:Yaapii.Atoms.Map.NoNulls`2.Count">
            <summary>
            Count entries
            </summary>
        </member>
        <member name="P:Yaapii.Atoms.Map.NoNulls`2.IsReadOnly">
            <summary>
            Gets a value indicating whether the map is read-only.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.NoNulls`2.Add(`0,`1)">
            <summary>
            Adds an element with the provided key and value to the map
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:Yaapii.Atoms.Map.NoNulls`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Adds an element with the provided entry to the map
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Yaapii.Atoms.Map.NoNulls`2.Clear">
            <summary>
            Removes all elements from the map
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.NoNulls`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Test if map contains entry
            </summary>
            <param name="item">item to check</param>
            <returns>true if it contains the entry</returns>
        </member>
        <member name="M:Yaapii.Atoms.Map.NoNulls`2.ContainsKey(`0)">
            <summary>
            Test if map contains key
            </summary>
            <param name="key"></param>
            <returns>true if it contains the key</returns>
        </member>
        <member name="M:Yaapii.Atoms.Map.NoNulls`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copy this to an array
            </summary>
            <param name="array">target array</param>
            <param name="arrayIndex">index to start</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.NoNulls`2.GetEnumerator">
            <summary>
            The enumerator
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="M:Yaapii.Atoms.Map.NoNulls`2.Remove(`0)">
            <summary>
             Removes the entry with the specified key from the map
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.NoNulls`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Removes the first occurrence of a specific entry from the map
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.NoNulls`2.TryGetValue(`0,`1@)">
            <summary>
            Tries to get value
            </summary>
            <param name="key">key</param>
            <param name="value">target to store value</param>
            <returns>true if success</returns>
        </member>
        <member name="T:Yaapii.Atoms.Map.Solid`2">
            <summary>
            A map that is both threadsafe and sticky.
            </summary>
            <typeparam name="Key">type of key</typeparam>
            <typeparam name="Value">type of value</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Map.Solid`2.#ctor(System.Tuple{`0,`1}[])">
            <summary>
            A map from the given Tuple pairs.
            </summary>
            <param name="pairs">Pairs of mappings</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Solid`2.#ctor(System.Collections.Generic.IEnumerable{System.Tuple{`0,`1}})">
            <summary>
            A map from the given Tuple pairs.
            </summary>
            <param name="pairs">Pairs of mappings</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Solid`2.#ctor(System.Collections.Generic.KeyValuePair{`0,`1}[])">
            <summary>
            Makes a map from the given values.
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Solid`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.KeyValuePair{`0,`1}[])">
            <summary>
            Makes a map by merging the given values into the given dictionary.
            </summary>
            <param name="map">map to merge to</param>
            <param name="list">list of values to merge</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Solid`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            ctor
            </summary>
            <param name="list">List of values</param>        
        </member>
        <member name="M:Yaapii.Atoms.Map.Solid`2.#ctor(System.Collections.Generic.IEnumerator{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            ctor
            </summary>
            <param name="list">List of values</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Solid`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            ctor
            </summary>
            <param name="map">map to merge to</param>
            <param name="list">list of values to merge</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Solid`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            ctor
            </summary>
            <param name="map"></param>
        </member>
        <member name="T:Yaapii.Atoms.Map.Sorted`2">
            <summary>
            Sorts the given map with the given comparer
            </summary>
            <typeparam name="Key">Key Type of the Map</typeparam>
            <typeparam name="Value">Value Type of the Map</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Map.Sorted`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Sorts the given map with the default comperator of the key
            </summary>
            <param name="dict">Map to be sorted</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Sorted`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Func{`0,`0,System.Int32})">
            <summary>
            Sorts the given map with the given compare function
            </summary>
            <param name="dict">Map to be sorted</param>
            <param name="compare">Function to compare two keys</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Sorted`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Sorts the given map with the default comperator of the key
            </summary>
            <param name="pairs">Map elements to be sorted</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Sorted`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Func{`0,`0,System.Int32})">
            <summary>
            Sorts the given map with the given key compare function
            </summary>
            <param name="pairs">Map elements to be sorted</param>
            <param name="compare">Function to compare two keys</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Sorted`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Func{System.Collections.Generic.KeyValuePair{`0,`1},System.Collections.Generic.KeyValuePair{`0,`1},System.Int32})">
            <summary>
            Sorts the given map with the given compare function
            </summary>
            <param name="pairs">Map elements to be sorted</param>
            <param name="compare">Function to compare two elements</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Sorted`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IComparer{`0})">
            <summary>
            Sorts the given map with the given key comparer
            </summary>
            <param name="pairs">Map elements to be sorted</param>
            <param name="cmp">Comparer comparing keys</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Sorted`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IComparer{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Sorts the given map with the given comparer
            </summary>
            <param name="pairs">Map elements to be sorted</param>
            <param name="cmp">Comparer comparing elements</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Sorted`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IComparer{`0})">
            <summary>
            Sorts the given map with the given comparer
            </summary>
            <param name="dict">Map to be sorted</param>
            <param name="cmp">Comparer comparing keys</param>
        </member>
        <member name="T:Yaapii.Atoms.Map.Sorted`1">
            <summary>
            Sorts the given map with the given comparer
            </summary>
            <typeparam name="Value">Value Type of the Map</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Map.Sorted`1.#ctor(System.Collections.Generic.IDictionary{System.String,`0})">
            <summary>
            Sorts the given map with the default comperator of the key
            </summary>
            <param name="dict">Map to be sorted</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Sorted`1.#ctor(System.Collections.Generic.IDictionary{System.String,`0},System.Func{System.String,System.String,System.Int32})">
            <summary>
            Sorts the given map with the given compare function
            </summary>
            <param name="dict">Map to be sorted</param>
            <param name="compare">Function to compare two keys</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Sorted`1.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,`0}})">
            <summary>
            Sorts the given map with the default comperator of the key
            </summary>
            <param name="pairs">Map elements to be sorted</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Sorted`1.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,`0}},System.Func{System.String,System.String,System.Int32})">
            <summary>
            Sorts the given map with the given key compare function
            </summary>
            <param name="pairs">Map elements to be sorted</param>
            <param name="compare">Function to compare two keys</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Sorted`1.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,`0}},System.Func{System.Collections.Generic.KeyValuePair{System.String,`0},System.Collections.Generic.KeyValuePair{System.String,`0},System.Int32})">
            <summary>
            Sorts the given map with the given compare function
            </summary>
            <param name="pairs">Map elements to be sorted</param>
            <param name="compare">Function to compare two elements</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Sorted`1.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,`0}},System.Collections.Generic.IComparer{System.String})">
            <summary>
            Sorts the given map with the given key comparer
            </summary>
            <param name="pairs">Map elements to be sorted</param>
            <param name="cmp">Comparer comparing keys</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Sorted`1.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,`0}},System.Collections.Generic.IComparer{System.Collections.Generic.KeyValuePair{System.String,`0}})">
            <summary>
            Sorts the given map with the given comparer
            </summary>
            <param name="pairs">Map elements to be sorted</param>
            <param name="cmp">Comparer comparing elements</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Sorted`1.#ctor(System.Collections.Generic.IDictionary{System.String,`0},System.Collections.Generic.IComparer{System.String})">
            <summary>
            Sorts the given map with the given comparer
            </summary>
            <param name="dict">Map to be sorted</param>
            <param name="cmp">Comparer comparing keys</param>
        </member>
        <member name="T:Yaapii.Atoms.Map.Sorted">
            <summary>
            Sorts the given map with the given comparer
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.Sorted.#ctor(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Sorts the given map with the default comperator of the key
            </summary>
            <param name="dict">Map to be sorted</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Sorted.#ctor(System.Collections.Generic.IDictionary{System.String,System.String},System.Func{System.String,System.String,System.Int32})">
            <summary>
            Sorts the given map with the given compare function
            </summary>
            <param name="dict">Map to be sorted</param>
            <param name="compare">Function to compare two keys</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Sorted.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Sorts the given map with the default comperator of the key
            </summary>
            <param name="pairs">Map elements to be sorted</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Sorted.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}},System.Func{System.String,System.String,System.Int32})">
            <summary>
            Sorts the given map with the given key compare function
            </summary>
            <param name="pairs">Map elements to be sorted</param>
            <param name="compare">Function to compare two keys</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Sorted.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}},System.Func{System.Collections.Generic.KeyValuePair{System.String,System.String},System.Collections.Generic.KeyValuePair{System.String,System.String},System.Int32})">
            <summary>
            Sorts the given map with the given compare function
            </summary>
            <param name="pairs">Map elements to be sorted</param>
            <param name="compare">Function to compare two elements</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Sorted.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}},System.Collections.Generic.IComparer{System.String})">
            <summary>
            Sorts the given map with the given key comparer
            </summary>
            <param name="pairs">Map elements to be sorted</param>
            <param name="cmp">Comparer comparing keys</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Sorted.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}},System.Collections.Generic.IComparer{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Sorts the given map with the given comparer
            </summary>
            <param name="pairs">Map elements to be sorted</param>
            <param name="cmp">Comparer comparing elements</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Sorted.#ctor(System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IComparer{System.String})">
            <summary>
            Sorts the given map with the given comparer
            </summary>
            <param name="dict">Map to be sorted</param>
            <param name="cmp">Comparer comparing keys</param>
        </member>
        <member name="T:Yaapii.Atoms.Map.SimpleComparer`1">
            <summary>
            Simple Comparer comparing two elements
            </summary>
            <typeparam name="T">Type of the elements</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Map.SimpleComparer`1.#ctor(System.Func{`0,`0,System.Int32})">
            <summary>
            Comparer from a function comparing two elements
            </summary>
            <param name="compare">Function comparing two elements</param>
        </member>
        <member name="T:Yaapii.Atoms.Map.KeyComparer`2">
            <summary>
            Comparer comparing two KeyValuePairs by key
            </summary>
            <typeparam name="Key">Key Type</typeparam>
            <typeparam name="Value">Value Type</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Map.KeyComparer`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Comparer comparing two KeyValuePairs by key
            </summary>
            <param name="cmp">Comparer compairing the key type</param>
        </member>
        <member name="T:Yaapii.Atoms.Map.Synced`2">
            <summary>
            A map that is threadsafe.
            </summary>
            <typeparam name="Key">type of key</typeparam>
            <typeparam name="Value">type of value</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Map.Synced`2.#ctor(System.Collections.Generic.KeyValuePair{`0,`1}[])">
            <summary>
            Makes a map that is threadsafe.
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Synced`2.#ctor(System.Collections.Generic.Dictionary{`0,`1},System.Collections.Generic.KeyValuePair{`0,`1}[])">
            <summary>
            Makes a map that is threadsafe.
            </summary>
            <param name="map">map to merge to</param>
            <param name="list">list of entries to merge</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Synced`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Makes a map that is threadsafe.
            </summary>
            <param name="list">list of entries</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Synced`2.#ctor(System.Collections.Generic.IEnumerator{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Makes a map that is threadsafe.
            </summary>
            <param name="list">list of entries</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Synced`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            A merged map that is treadsafe.
            </summary>
            <param name="map">map to merge to</param>
            <param name="list">items to merge</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Synced`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            A merged map that is threadsafe.
            </summary>
            <param name="map">Map to make threadsafe</param>
        </member>
        <member name="T:Yaapii.Atoms.Map.Sync`3">
            <summary>
            Makes a threadsafe map
            </summary>
            <typeparam name="Source">source value type</typeparam>
            <typeparam name="Key">type of key</typeparam>
            <typeparam name="Value">type of value</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Map.Sync`3.#ctor(System.Collections.Generic.IDictionary{`1,`2},System.Collections.Generic.IEnumerable{`0},System.Func{`0,`1},System.Func{`0,`2})">
            <summary>
            Makes a threadsafe map.
            </summary>
            <param name="map">source map to merge to</param>
            <param name="list">list of values to merge</param>
            <param name="key">func to get the key</param>
            <param name="value">func to get the value</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Sync`3.#ctor(System.Collections.Generic.IEnumerable{`0},System.Func{`0,`1},System.Func{`0,`2})">
            <summary>
            Makes a threadsafe map.
            </summary>
            <param name="list">list of values to merge</param>
            <param name="key">func to get the key</param>
            <param name="value">func to get the value</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Sync`3.#ctor(System.Collections.Generic.IEnumerable{`0},System.Func{`0,System.Collections.Generic.KeyValuePair{`1,`2}})">
            <summary>
            Makes a threadsafe map.
            </summary>
            <param name="list">list of values to merge</param>
            <param name="entry">func to get the entry</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Sync`3.#ctor(System.Collections.Generic.IDictionary{`1,`2},System.Collections.Generic.IEnumerable{`0},System.Func{`0,System.Collections.Generic.KeyValuePair{`1,`2}})">
            <summary>
            Makes a threadsafe map.
            </summary>
            <param name="map"></param>
            <param name="list"></param>
            <param name="entry"></param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Sync`3.#ctor(System.Collections.Generic.IDictionary{`1,`2},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`1,`2}})">
            <summary>
            A merged map that is treadsafe.
            </summary>
            <param name="map">map to merge to</param>
            <param name="list">items to merge</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Sync`3.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`1,`2}})">
            <summary>
            Makes a map that is threadsafe.
            </summary>
            <param name="list">list of entries</param>
        </member>
        <member name="M:Yaapii.Atoms.Map.Sync`3.#ctor(System.Collections.Generic.IDictionary{`1,`2})">
            <summary>
            A merged map that is threadsafe.
            </summary>
            <param name="map">Map to make threadsafe</param>
        </member>
        <member name="T:Yaapii.Atoms.Map.VersionMap">
            <summary>
            A map which matches a version. 
            It can match the version range, not the exact version.
            This means if you have two krvps inside: 1.0 and 3.0, and your key is 2.0, the version 1.0 is matched.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Map.VersionMap`1">
            <summary>
            A dictionary which matches a version. 
            It matches the version range, not the exact version.
            This means if you have two kvps inside: 1.0 and 3.0, and your key is 2.0, the version 1.0 is matched.
            </summary>
            <typeparam name="Value"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Map.VersionMap`1.#ctor(Yaapii.Atoms.IKvp{System.Version,`0}[])">
            <summary>
            A dictionary which matches a version. 
            It matches the version range, not the exact version.
            This means if you have two kvps inside: 1.0 and 3.0, and your key is 2.0, the version 1.0 is matched.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.VersionMap`1.#ctor(System.Boolean,Yaapii.Atoms.IKvp{System.Version,`0}[])">
            <summary>
            A dictionary which matches a version. 
            It matches the version range, not the exact version.
            This means if you have two kvps inside: 1.0 and 3.0, and your key is 2.0, the version 1.0 is matched.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Map.VersionMap`1.#ctor(System.Collections.Generic.IEnumerable{Yaapii.Atoms.IKvp{System.Version,`0}},System.Boolean)">
            <summary>
            A dictionary which matches a version. 
            It matches the version range, not the exact version.
            This means if you have two kvps inside: 1.0 and 3.0, and your key is 2.0, the version 1.0 is matched.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Number.AvgOf">
             <summary>
             Average of numbers.
            
             <para>Here is how you can use it to fine mathematical average of numbers:</para>
            
             <code>
             int sum = new AvgOf(1, 2, 3, 4).intValue();
             long sum = new AvgOf(1L, 2L, 3L).longValue();
             int sum = new AvgOf(numbers.toArray(new Integer[numbers.size()])).intValue();
             </code>
             </summary>
        </member>
        <member name="M:Yaapii.Atoms.Number.AvgOf.#ctor(System.Double[])">
             <summary>
             Average of doubles.
            
             <para>Here is how you can use it to fine mathematical average of numbers:</para>
            
             <code>
             int sum = new AvgOf(new Many.Of&lt;double&gt;(1D, 2D, 3D, 4D)).AsInt();
             </code>
             </summary>
             <param name="src">doubles</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.AvgOf.#ctor(System.Int32[])">
             <summary>
             Average of integers.
            
             <para>Here is how you can use it to fine mathematical average of numbers:</para>
            
             <code>
             int sum = new AvgOf(new Many.Of&lt;int&gt;(1, 2, 3, 4)).AsInt();
             </code>
             </summary>
             <param name="src">integers</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.AvgOf.#ctor(System.Int64[])">
             <summary>
             Average of longs.
            
             <para>Here is how you can use it to fine mathematical average of numbers:</para>
            
             <code>
             int sum = new AvgOf(new Many.Of&lt;long&gt;(1, 2, 3, 4)).AsInt();
             </code>
             </summary>
             <param name="src"></param>
        </member>
        <member name="M:Yaapii.Atoms.Number.AvgOf.#ctor(System.Single[])">
             <summary>
             Average of floats.
            
             <para>Here is how you can use it to fine mathematical average of numbers:</para>
            
             <code>
             int sum = new AvgOf(new Many.Of&lt;float&gt;(1F, 2F, 3F, 4F)).AsInt();
             </code>
             </summary>
             <param name="src">floats</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.AvgOf.#ctor(System.Collections.Generic.IEnumerable{System.Double})">
             <summary>
             Average of doubles.
            
             <para>Here is how you can use it to fine mathematical average of numbers:</para>
            
             <code>
             int sum = new AvgOf(new Many.Of&lt;double&gt;(1D, 2D, 3D, 4D)).AsInt();
             </code>
             </summary>
             <param name="src"></param>
        </member>
        <member name="M:Yaapii.Atoms.Number.AvgOf.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
             <summary>
             Average of integers.
            
             <para>Here is how you can use it to fine mathematical average of numbers:</para>
            
             <code>
             int sum = new AvgOf(new Many.Of&lt;int&gt;(1, 2, 3, 4)).AsInt();
             </code>
             </summary>
             <param name="src"></param>
        </member>
        <member name="M:Yaapii.Atoms.Number.AvgOf.#ctor(System.Collections.Generic.IEnumerable{System.Int64})">
             <summary>
             Average of integers.
            
             <para>Here is how you can use it to fine mathematical average of numbers:</para>
            
             <code>
             int sum = new AvgOf(new Many.Of&lt;long&gt;(1L, 2L, 3L, 4L)).AsInt();
             </code>
             </summary>
             <param name="src"></param>
        </member>
        <member name="M:Yaapii.Atoms.Number.AvgOf.#ctor(System.Collections.Generic.IEnumerable{System.Single})">
             <summary>
             Average of integers.
            
             <para>Here is how you can use it to fine mathematical average of numbers:</para>
            
             <code>
             long sum = new AvgOf(new Many.Of&lt;float&gt;(1F, 2F, 3F, 4F)).AsLong();
             </code>
             </summary>
             <param name="src"></param>
        </member>
        <member name="T:Yaapii.Atoms.Number.LiveNumber">
            <summary>
            A parsed number
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Number.LiveNumber.#ctor(System.Func{System.String},System.String,System.String)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> as a <see cref="T:Yaapii.Atoms.INumber"/>
            </summary>
            <param name="text">text to parse</param>
            <param name="blockSeperator">seperator for blocks, for example 1.000</param>
            <param name="decimalSeperator">seperator for floating point numbers, for example 16,235 </param>
        </member>
        <member name="M:Yaapii.Atoms.Number.LiveNumber.#ctor(System.Func{System.String})">
            <summary>
            A <see cref="T:System.Int32"/> as a <see cref="T:Yaapii.Atoms.INumber"/>
            </summary>
            <param name="str">The string</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.LiveNumber.#ctor(System.Func{System.String},Yaapii.Atoms.IScalar{System.IFormatProvider})">
            <summary>	
            A <see cref="T:System.String"/> as a <see cref="T:Yaapii.Atoms.INumber"/>	
            </summary>	
            <param name="str">The string</param>	
            <param name="provider">a number format provider</param>	
        </member>
        <member name="M:Yaapii.Atoms.Number.LiveNumber.#ctor(System.Func{System.String},System.IFormatProvider)">
            <summary>
            A <see cref="T:System.Int32"/> as a <see cref="T:Yaapii.Atoms.INumber"/>
            </summary>
            <param name="str">The string</param>
            <param name="provider">a number format provider</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.LiveNumber.#ctor(System.Func{System.Int32})">
            <summary>
            A <see cref="T:System.Int32"/> as a <see cref="T:Yaapii.Atoms.INumber"/>
            </summary>
            <param name="integer">The integer</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.LiveNumber.#ctor(System.Func{System.Double})">
            <summary>
            A <see cref="T:System.Double"/> as a <see cref="T:Yaapii.Atoms.INumber"/>
            </summary>
            <param name="dbl">The double</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.LiveNumber.#ctor(System.Func{System.Int64})">
            <summary>
            A <see cref="T:System.Int64"/> as a <see cref="T:Yaapii.Atoms.INumber"/>
            </summary>
            <param name="lng">The long</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.LiveNumber.#ctor(System.Func{System.Single})">
            <summary>
            A <see cref="T:System.Single"/> as a <see cref="T:Yaapii.Atoms.INumber"/>
            </summary>
            <param name="flt">The float</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.LiveNumber.#ctor(Yaapii.Atoms.IScalar{System.Int64},Yaapii.Atoms.IScalar{System.Int32},Yaapii.Atoms.IScalar{System.Single},Yaapii.Atoms.IScalar{System.Double})">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> as a <see cref="T:Yaapii.Atoms.INumber"/>
            </summary>
            <param name="lng"></param>
            <param name="itg"></param>
            <param name="flt"></param>
            <param name="dbl"></param>
        </member>
        <member name="M:Yaapii.Atoms.Number.LiveNumber.AsDouble">
            <summary>
            Number as double representation
            Precision: ±5.0e−324 to ±1.7e308	(15-16 digits)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Yaapii.Atoms.Number.LiveNumber.AsFloat">
            <summary>
            Number as float representation
            Precision: 	±1.5e−45 to ±3.4e38	    (7 digits)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Yaapii.Atoms.Number.LiveNumber.AsInt">
            <summary>
            Number as integer representation
            Range -2,147,483,648 to 2,147,483,647	(Signed 32-bit integer)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Yaapii.Atoms.Number.LiveNumber.AsLong">
            <summary>
            Number as long representation
            Range -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807	(Signed 64-bit integer)
            </summary>
            <returns></returns>
        </member>
        <member name="T:Yaapii.Atoms.Number.MaxOf">
            <summary>
            The maximum of the given numbers
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Number.MaxOf.#ctor(System.Int32[])">
            <summary>
            The maximum of the source integers
            </summary>
            <param name="src">integers to find max in</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.MaxOf.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            The maximum of the source integers
            </summary>
            <param name="src">integers to find max in</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.MaxOf.#ctor(System.Double[])">
            <summary>
            The maximum of the source integers
            </summary>
            <param name="src">integers to find max in</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.MaxOf.#ctor(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            The maximum of the source integers
            </summary>
            <param name="src">integers to find max in</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.MaxOf.#ctor(System.Int64[])">
            <summary>
            The maximum of the source integers
            </summary>
            <param name="src">integers to find max in</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.MaxOf.#ctor(System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            The maximum of the source integers
            </summary>
            <param name="src">integers to find max in</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.MaxOf.#ctor(System.Single[])">
            <summary>
            The maximum of the source integers
            </summary>
            <param name="src">integers to find max in</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.MaxOf.#ctor(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            The maximum of the source integers
            </summary>
            <param name="src">integers to find max in</param>
        </member>
        <member name="T:Yaapii.Atoms.Number.MinOf">
            <summary>
            The minimum of the given numbers
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Number.MinOf.#ctor(System.Int32[])">
            <summary>
            The minimum of the source integers
            </summary>
            <param name="src">integers to find max in</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.MinOf.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            The minimum of the source integers
            </summary>
            <param name="src">integers to find max in</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.MinOf.#ctor(System.Double[])">
            <summary>
            The minimum of the source integers
            </summary>
            <param name="src">integers to find max in</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.MinOf.#ctor(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            The minimum of the source integers
            </summary>
            <param name="src">integers to find max in</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.MinOf.#ctor(System.Int64[])">
            <summary>
            The minimum of the source integers
            </summary>
            <param name="src">integers to find max in</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.MinOf.#ctor(System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            The minimum of the source integers
            </summary>
            <param name="src">integers to find max in</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.MinOf.#ctor(System.Single[])">
            <summary>
            The minimum of the source integers
            </summary>
            <param name="src">integers to find max in</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.MinOf.#ctor(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            The minimum of the source integers
            </summary>
            <param name="src">integers to find max in</param>
        </member>
        <member name="T:Yaapii.Atoms.Number.NumberEnvelope">
            <summary>
            Wraps up Conversions to <see cref="T:Yaapii.Atoms.INumber"/>
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Number.NumberEnvelope.#ctor(System.Double)">
            <summary>
            A <see cref="T:Yaapii.Atoms.INumber"/> from a <see cref="T:System.Double"/>
            </summary>
            <param name="dbl">the double</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.NumberEnvelope.#ctor(System.Int32)">
            <summary>
            A <see cref="T:Yaapii.Atoms.INumber"/> from a <see cref="T:System.Int32"/>
            </summary>
            <param name="itg">the int</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.NumberEnvelope.#ctor(System.Int64)">
            <summary>
            A <see cref="T:Yaapii.Atoms.INumber"/> from a <see cref="T:System.Int64"/>
            </summary>
            <param name="lng">the long</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.NumberEnvelope.#ctor(System.Single)">
            <summary>
            A <see cref="T:Yaapii.Atoms.INumber"/> from a <see cref="T:System.Single"/>
            </summary>
            <param name="flt">the float</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.NumberEnvelope.#ctor(Yaapii.Atoms.IScalar{System.Single})">
            <summary>
            A <see cref="T:Yaapii.Atoms.INumber"/> from a <see cref="T:System.Single"/>
            </summary>
            <param name="flt">the float</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.NumberEnvelope.#ctor(Yaapii.Atoms.IScalar{System.Int32})">
            <summary>
            A <see cref="T:Yaapii.Atoms.INumber"/> from a <see cref="T:System.Int32"/>
            </summary>
            <param name="itg">the int</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.NumberEnvelope.#ctor(Yaapii.Atoms.IScalar{System.Int64})">
            <summary>
            A <see cref="T:Yaapii.Atoms.INumber"/> from a <see cref="T:System.Int64"/>
            </summary>
            <param name="lng">the long</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.NumberEnvelope.#ctor(Yaapii.Atoms.IScalar{System.Double})">
            <summary>
            A <see cref="T:Yaapii.Atoms.INumber"/> from a <see cref="T:System.Double"/>
            </summary>
            <param name="dbl"></param>
        </member>
        <member name="M:Yaapii.Atoms.Number.NumberEnvelope.#ctor(Yaapii.Atoms.IScalar{System.Double},Yaapii.Atoms.IScalar{System.Int32},Yaapii.Atoms.IScalar{System.Int64},Yaapii.Atoms.IScalar{System.Single})">
            <summary>
            A <see cref="T:Yaapii.Atoms.INumber"/> from the given inputs
            </summary>
            <param name="dbl"></param>
            <param name="itg"></param>
            <param name="lng"></param>
            <param name="flt"></param>
        </member>
        <member name="M:Yaapii.Atoms.Number.NumberEnvelope.AsDouble">
            <summary>
            Number as double representation
            Precision: ±5.0e−324 to ±1.7e308	(15-16 digits)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Yaapii.Atoms.Number.NumberEnvelope.AsFloat">
            <summary>
            Number as float representation
            Precision: 	±1.5e−45 to ±3.4e38	    (7 digits)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Yaapii.Atoms.Number.NumberEnvelope.AsInt">
            <summary>
            Number as integer representation
            Range -2,147,483,648 to 2,147,483,647	(Signed 32-bit integer)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Yaapii.Atoms.Number.NumberEnvelope.AsLong">
            <summary>
            Number as long representation
            Range -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807	(Signed 64-bit integer)
            </summary>
            <returns></returns>
        </member>
        <member name="T:Yaapii.Atoms.Number.NumberOf">
            <summary>
            A parsed number
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Number.NumberOf.#ctor(System.String,System.String,System.String)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> as a <see cref="T:Yaapii.Atoms.INumber"/>
            </summary>
            <param name="text">text to parse</param>
            <param name="blockSeperator">seperator for blocks, for example 1.000</param>
            <param name="decimalSeperator">seperator for floating point numbers, for example 16,235 </param>
        </member>
        <member name="M:Yaapii.Atoms.Number.NumberOf.#ctor(System.String)">
            <summary>
            A <see cref="T:System.Int32"/> as a <see cref="T:Yaapii.Atoms.INumber"/>
            </summary>
            <param name="str">The string</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.NumberOf.#ctor(System.String,Yaapii.Atoms.IScalar{System.IFormatProvider})">
            <summary>
            A <see cref="T:System.String"/> as a <see cref="T:Yaapii.Atoms.INumber"/>
            </summary>
            <param name="str">The string</param>
            <param name="provider">a number format provider</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.NumberOf.#ctor(System.String,System.IFormatProvider)">
            <summary>
            A <see cref="T:System.String"/> as a <see cref="T:Yaapii.Atoms.INumber"/>
            </summary>
            <param name="str">The string</param>
            <param name="provider">a number format provider</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.NumberOf.#ctor(Yaapii.Atoms.IText)">
            <summary>
            A <see cref="T:System.Int32"/> as a <see cref="T:Yaapii.Atoms.INumber"/>
            </summary>
            <param name="text">The text</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.NumberOf.#ctor(Yaapii.Atoms.IText,System.IFormatProvider)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> as a <see cref="T:Yaapii.Atoms.INumber"/>
            </summary>
            <param name="text">The text</param>
            <param name="provider">a number format provider</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.NumberOf.#ctor(System.Int32)">
            <summary>
            A <see cref="T:System.Int32"/> as a <see cref="T:Yaapii.Atoms.INumber"/>
            </summary>
            <param name="integer">The integer</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.NumberOf.#ctor(System.Double)">
            <summary>
            A <see cref="T:System.Double"/> as a <see cref="T:Yaapii.Atoms.INumber"/>
            </summary>
            <param name="dbl">The double</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.NumberOf.#ctor(System.Int64)">
            <summary>
            A <see cref="T:System.Int64"/> as a <see cref="T:Yaapii.Atoms.INumber"/>
            </summary>
            <param name="lng">The long</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.NumberOf.#ctor(System.Single)">
            <summary>
            A <see cref="T:System.Single"/> as a <see cref="T:Yaapii.Atoms.INumber"/>
            </summary>
            <param name="flt">The float</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.NumberOf.#ctor(Yaapii.Atoms.IScalar{System.Int64},Yaapii.Atoms.IScalar{System.Int32},Yaapii.Atoms.IScalar{System.Single},Yaapii.Atoms.IScalar{System.Double})">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> as a <see cref="T:Yaapii.Atoms.INumber"/>
            </summary>
            <param name="lng"></param>
            <param name="itg"></param>
            <param name="flt"></param>
            <param name="dbl"></param>
        </member>
        <member name="T:Yaapii.Atoms.Number.Similar">
            <summary>
            Checks if two Numbers are similar with a given accuracy
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Number.Similar.#ctor(Yaapii.Atoms.INumber,Yaapii.Atoms.INumber)">
            <summary>
            Checks if two Numbers are similar with a given accuracy
            </summary>
            <param name="first">First Number</param>
            <param name="second">Second Number</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.Similar.#ctor(Yaapii.Atoms.INumber,Yaapii.Atoms.INumber,System.Int32)">
            <summary>
            Checks if two Numbers are similar with a given accuracy
            </summary>
            <param name="first">First Number</param>
            <param name="second">Second Number</param>
            <param name="accuracy">Number of equal decimal places</param>
        </member>
        <member name="T:Yaapii.Atoms.Number.SumOf">
            <summary>
            Calculated sum of numbers.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Number.SumOf.#ctor(System.Single[])">
            <summary>
            A sum of floats
            </summary>
            <param name="src">source floats</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.SumOf.#ctor(System.Int64[])">
            <summary>
            A sum of longs
            </summary>
            <param name="src">source longs</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.SumOf.#ctor(System.Int32[])">
            <summary>
            A sum of ints
            </summary>
            <param name="src">source ints</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.SumOf.#ctor(System.Double[])">
            <summary>
            A sum of doubles
            </summary>
            <param name="src">source doubles</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.SumOf.#ctor(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            A sum of doubles
            </summary>
            <param name="src">source doubles</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.SumOf.#ctor(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            A sum of integers
            </summary>
            <param name="src">source integers</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.SumOf.#ctor(System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            A sum of longs
            </summary>
            <param name="src">source longs</param>
        </member>
        <member name="M:Yaapii.Atoms.Number.SumOf.#ctor(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            A sum of floats
            </summary>
            <param name="src">source floats</param>
        </member>
        <member name="T:Yaapii.Atoms.Text.BoolOf">
            <summary>
            A bool out of text objects.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.BoolOf.#ctor(System.String)">
            <summary>
            <see cref="T:System.String"/> as bool
            </summary>
            <param name="str">source string</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.BoolOf.#ctor(Yaapii.Atoms.IText)">
            <summary>
            <see cref="T:Yaapii.Atoms.IText"/> as bool
            </summary>
            <param name="text">source text "true" or "false"</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.BoolOf.Value">
            <summary>
            Bool value
            </summary>
            <returns>true or false</returns>
        </member>
        <member name="T:Yaapii.Atoms.Text.DoubleOf">
            <summary>
            A double out of text.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.DoubleOf.#ctor(System.String)">
            <summary>
            A double out of <see cref="T:System.String"/>.
            </summary>
            <param name="str">a double as a string</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.DoubleOf.#ctor(Yaapii.Atoms.IText)">
            <summary>
            A double out of <see cref="T:Yaapii.Atoms.IText"/>.
            </summary>
            <param name="text">a double as a text</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.DoubleOf.#ctor(System.String,System.Globalization.CultureInfo)">
            <summary>
            A double out of <see cref="T:System.String"/> using the given <see cref="T:System.Text.Encoding"/>.
            </summary>
            <param name="str">a double as a string</param>
            <param name="culture">culture of the given string</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.DoubleOf.#ctor(Yaapii.Atoms.IText,System.Globalization.CultureInfo)">
            <summary>
            A double out of <see cref="T:Yaapii.Atoms.IText"/> using the given <see cref="T:System.Globalization.CultureInfo"/>.
            </summary>
            <param name="text">a double as a text</param>
            <param name="culture">culture of the given text</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.DoubleOf.#ctor(Yaapii.Atoms.IScalar{System.Double})">
            <summary>
            A double out of a encapsulating <see cref="T:Yaapii.Atoms.IScalar`1"/>
            </summary>
            <param name="value">a scalar of the double to sum</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.DoubleOf.Value">
            <summary>
            Get the value.
            </summary>
            <returns>value as double</returns>
        </member>
        <member name="T:Yaapii.Atoms.Text.FloatOf">
            <summary>
            A float out of text.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.FloatOf.#ctor(System.String)">
            <summary>
            A float out of a <see cref="T:System.String"/> using invariant culture.
            </summary>
            <param name="str">a float as a string</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.FloatOf.#ctor(Yaapii.Atoms.IText)">
            <summary>
            A float out of a <see cref="T:Yaapii.Atoms.IText"/> using invariant culture.
            </summary>
            <param name="text">a float as a text</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.FloatOf.#ctor(System.String,System.Globalization.CultureInfo)">
            <summary>
            A float out of a <see cref="T:System.String"/>.
            </summary>
            <param name="str">a float as a string</param>
            <param name="culture">culture of the string</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.FloatOf.#ctor(Yaapii.Atoms.IText,System.Globalization.CultureInfo)">
            <summary>
            A float out of a <see cref="T:Yaapii.Atoms.IText"/> using the given <see cref="T:System.Globalization.CultureInfo"/>.
            </summary>
            <param name="text">a float as a text</param>
            <param name="culture">a culture of the string</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.FloatOf.Value">
            <summary>
            Get the float.
            </summary>
            <returns>the float</returns>
        </member>
        <member name="T:Yaapii.Atoms.Text.IntOf">
            <summary>
            A <see cref="T:System.Int32"/> of a text.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.IntOf.#ctor(System.String)">
            <summary>
            A int out of a <see cref="T:System.String"/> using invariant culture.
            </summary>
            <param name="str">a int as a string</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.IntOf.#ctor(Yaapii.Atoms.IText)">
            <summary>
            A int out of a <see cref="T:Yaapii.Atoms.IText"/> using invariant culture.
            </summary>
            <param name="text">a int as a text</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.IntOf.#ctor(System.String,System.Globalization.CultureInfo)">
            <summary>
            A int out of a <see cref="T:System.String"/> using the given <see cref="T:System.Globalization.CultureInfo"/>.
            </summary>
            <param name="str">a int as a string</param>
            <param name="culture">culture of the string</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.IntOf.#ctor(Yaapii.Atoms.IText,System.Globalization.CultureInfo)">
            <summary>
            A int out of a <see cref="T:Yaapii.Atoms.IText"/> using the given <see cref="T:System.Globalization.CultureInfo"/>.
            </summary>
            <param name="text">a int as a string</param>
            <param name="culture">culture of the string</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.IntOf.#ctor(Yaapii.Atoms.IScalar{System.Int32})">
            <summary>
            A int out of a scalar.
            </summary>
            <param name="value">the scalar returning the float</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.IntOf.Value">
            <summary>
            Get the int.
            </summary>
            <returns>the int</returns>
        </member>
        <member name="T:Yaapii.Atoms.Text.LongOf">
            <summary>
            Text as long
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.LongOf.#ctor(System.String)">
            <summary>
            A long out of a <see cref="T:System.String"/> using invariant culture.
            </summary>
            <param name="str">a long as a string</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LongOf.#ctor(Yaapii.Atoms.IText)">
            <summary>
            A long out of a <see cref="T:Yaapii.Atoms.IText"/> using invariant culture.
            </summary>
            <param name="text">a long as a text</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LongOf.#ctor(System.String,System.Globalization.CultureInfo)">
            <summary>
            A long out of a <see cref="T:System.String"/> using the given <see cref="T:System.Globalization.CultureInfo"/>.
            </summary>
            <param name="str">a long as a string</param>
            <param name="culture">culture of the string</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LongOf.#ctor(Yaapii.Atoms.IText,System.Globalization.CultureInfo)">
            <summary>
            A long out of a <see cref="T:System.String"/> using the given <see cref="T:System.Globalization.CultureInfo"/>.
            </summary>
            <param name="text">a string as a text</param>
            <param name="culture">culture of the text</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LongOf.#ctor(Yaapii.Atoms.IScalar{System.Int64})">
            <summary>
            A long out of encapsulating <see cref="T:Yaapii.Atoms.IScalar`1"/>
            </summary>
            <param name="value">a scalar of the number</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LongOf.Value">
            <summary>
            The value as a long.
            </summary>
            <returns>value as a long</returns>
        </member>
        <member name="T:Yaapii.Atoms.Text.Base64Text">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> as Base64 decoded <see cref="T:Yaapii.Atoms.IText"/>
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Base64Text.#ctor(System.String,System.Boolean)">
            <summary>
            A <see cref="T:System.String"/> as Base64 decoded <see cref="T:Yaapii.Atoms.IText"/>
            </summary>
            <param name="str">string to decode</param>
            <param name="live">should the object build its value live, every time it is used?</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Base64Text.#ctor(Yaapii.Atoms.IText,System.Boolean)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> as Base64 decoded <see cref="T:Yaapii.Atoms.IText"/>
            </summary>
            <param name="text">text to decode</param>
            <param name="live">should the object build its value live, every time it is used?</param>
        </member>
        <member name="T:Yaapii.Atoms.Text.Comparable">
            <summary>
            A Text that can be compared using the Equals method.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Comparable.#ctor(Yaapii.Atoms.IText)">
            <summary>
            A Text that can be compared using the Equals method.
            The text is always sticky (non live)
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Text.Contains">
            <summary> Check if a text contains a pattern </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Contains.#ctor(System.String,System.String,System.Boolean)">
            <summary> Checks if a text contains a pattern using strings </summary>
            <param name="inputStr"> text as string </param>
            <param name="patternStr"> pattern as string </param>
            <param name="ignoreCase"> Enables case sensitivity </param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Contains.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText,System.Boolean)">
            <summary> Checks if a text contains a pattern using IText </summary>
            <param name="inputText"> text as IText </param>
            <param name="patternText"> pattern as IText </param>
            <param name="ignoreCase"> Enables case sensitivity </param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Contains.#ctor(Yaapii.Atoms.IScalar{System.String},Yaapii.Atoms.IScalar{System.String})">
            <summary> Checks if a text contains a pattern using IScalar </summary>
            <param name="inputValue"> text as IScalar of string </param>
            <param name="pattern"> pattern as IScalar of string </param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Contains.#ctor(Yaapii.Atoms.IScalar{System.String},Yaapii.Atoms.IScalar{System.String},Yaapii.Atoms.IScalar{System.StringComparison})">
            <summary> Checks if a text contains a pattern using IScalar </summary>
            <param name="inputValue"> text as IScalar of string </param>
            <param name="pattern"> pattern as IScalar of string </param>
            <param name="stringComparison"> Enables case sensitivity (as IScalar of bool) </param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Contains.#ctor(System.Func{System.String},System.Func{System.String},System.Func{System.StringComparison})">
            <summary> Checks if a text contains a pattern using IScalar </summary>
            <param name="inputValue"> text as IScalar of string </param>
            <param name="pattern"> pattern as IScalar of string </param>
            <param name="stringComparison"> Enables case sensitivity (as IScalar of bool) </param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Contains.Value">
            <summary> Returns if the inputValue contains the pattern </summary>
            <returns> bool </returns>
        </member>
        <member name="T:Yaapii.Atoms.Text.EndsWith">
            <summary>
            Checks if a text ends with a given content.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.EndsWith.#ctor(Yaapii.Atoms.IText,System.String)">
            <summary>
            Checks if a <see cref="T:Yaapii.Atoms.IText"/> ends with a given <see cref="T:System.String"/>
            </summary>
            <param name="text">Text to test</param>
            <param name="tail">Ending content to use in the test</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.EndsWith.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText)">
            <summary>
            Checks if a <see cref="T:Yaapii.Atoms.IText"/> ends with a given <see cref="T:Yaapii.Atoms.IText"/>
            </summary>
            <param name="text">Text to test</param>
            <param name="tail">Ending content to use in the test</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.EndsWith.Value">
            <summary>
            Gets the result
            </summary>
            <returns>The result</returns>
        </member>
        <member name="T:Yaapii.Atoms.Text.Formatted">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> formatted with arguments.
            Use C# formatting syntax: new FormattedText("{0} is {1}", "OOP", "great").AsString() will be "OOP is great"
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Formatted.#ctor(System.String,Yaapii.Atoms.IText[])">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> formatted with arguments.
            </summary>
            <param name="ptn">pattern to put arguments in</param>
            <param name="arguments">arguments to apply</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Formatted.#ctor(System.String,System.Object[])">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> formatted with arguments.
            </summary>
            <param name="ptn">pattern to put arguments in</param>
            <param name="arguments">arguments to apply</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Formatted.#ctor(System.String,System.Boolean,System.Object[])">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> formatted with arguments.
            </summary>
            <param name="ptn">pattern to put arguments in</param>
            <param name="arguments">arguments to apply</param>
            <param name="live">should the object build its value live, every time it is used?</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Formatted.#ctor(Yaapii.Atoms.IText,System.Object[])">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> formatted with arguments.
            </summary>
            <param name="ptn">pattern to put arguments in</param>
            <param name="arguments">arguments to apply</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Formatted.#ctor(Yaapii.Atoms.IText,System.Boolean,System.Object[])">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> formatted with arguments.
            </summary>
            <param name="ptn">pattern to put arguments in</param>
            <param name="arguments">arguments to apply</param>
            <param name="live">should the object build its value live, every time it is used?</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Formatted.#ctor(Yaapii.Atoms.IText,System.Globalization.CultureInfo,System.Object[])">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> formatted with arguments.
            </summary>
            <param name="ptn">pattern</param>
            <param name="local">CultureInfo</param>
            <param name="arguments">arguments to apply</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Formatted.#ctor(Yaapii.Atoms.IText,System.Globalization.CultureInfo,System.Boolean,System.Object[])">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> formatted with arguments.
            </summary>
            <param name="ptn">pattern</param>
            <param name="local">CultureInfo</param>
            <param name="arguments">arguments to apply</param>
            <param name="live">should the object build its value live, every time it is used?</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Formatted.#ctor(System.String,System.Globalization.CultureInfo,System.Object[])">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> formatted with arguments.
            </summary>
            <param name="ptn">pattern to put arguments in</param>
            <param name="locale">a specific culture</param>
            <param name="arguments">arguments to apply</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Formatted.#ctor(System.String,System.Globalization.CultureInfo,System.Boolean,System.Object[])">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> formatted with arguments.
            </summary>
            <param name="ptn">pattern to put arguments in</param>
            <param name="locale">a specific culture</param>
            <param name="arguments">arguments to apply</param>
            <param name="live">should the object build its value live, every time it is used?</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Formatted.#ctor(System.String,System.Boolean,Yaapii.Atoms.IText[])">
            <summary>
             A <see cref="T:Yaapii.Atoms.IText"/> formatted with arguments.
            </summary>
            <param name="ptn">pattern to put arguments in</param>
            <param name="arguments">arguments as <see cref="T:Yaapii.Atoms.IText"/> to apply</param>
            <param name="live">should the object build its value live, every time it is used?</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Formatted.#ctor(System.String,System.Globalization.CultureInfo,Yaapii.Atoms.IText[])">
            <summary>
             A <see cref="T:Yaapii.Atoms.IText"/> formatted with arguments.
            </summary>
            <param name="ptn">pattern to put arguments in</param>
            <param name="locale">a specific culture</param>
            <param name="arguments">arguments as <see cref="T:Yaapii.Atoms.IText"/> to apply</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Formatted.#ctor(System.String,System.Globalization.CultureInfo,System.Boolean,Yaapii.Atoms.IText[])">
            <summary>
             A <see cref="T:Yaapii.Atoms.IText"/> formatted with arguments.
            </summary>
            <param name="ptn">pattern to put arguments in</param>
            <param name="locale">a specific culture</param>
            <param name="arguments">arguments as <see cref="T:Yaapii.Atoms.IText"/> to apply</param>
            <param name="live">should the object build its value live, every time it is used?</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Formatted.#ctor(Yaapii.Atoms.IText,System.Globalization.CultureInfo,Yaapii.Atoms.IScalar{System.Object[]},System.Boolean)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> formatted with arguments.
            </summary>
            <param name="ptn">pattern to put arguments in</param>
            <param name="locale">a specific culture</param>
            <param name="arguments">arguments to apply</param>
            <param name="live">should the object build its value live, every time it is used?</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Formatted.#ctor(Yaapii.Atoms.IText,System.Globalization.CultureInfo,System.Func{System.Object[]},System.Boolean)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> formatted with arguments.
            </summary>
            <param name="ptn">pattern to put arguments in</param>
            <param name="locale">a specific culture</param>
            <param name="arguments">arguments to apply</param>
            <param name="live">should the object build its value live, every time it is used?</param>
        </member>
        <member name="T:Yaapii.Atoms.Text.HexOf">
            <summary>
            Hexadecimal representation of Bytes.
            This object is sticky by default.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.HexOf.#ctor(Yaapii.Atoms.IBytes)">
            <summary>
            Hexadecimal representation of Bytes.
            </summary>
            <param name="bytes">bytes</param>
        </member>
        <member name="T:Yaapii.Atoms.Text.IsWhitespace">
            <summary>
            Checks if a text is whitespace.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.IsWhitespace.#ctor(System.String)">
            <summary>
            Checks if a A <see cref="T:System.String"/> is whitespace.
            </summary>
            <param name="text">text to check</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.IsWhitespace.#ctor(Yaapii.Atoms.IText)">
            <summary>
            Checks if a A <see cref="T:Yaapii.Atoms.IText"/> is whitespace.
            </summary>
            <param name="text">text to check</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.IsWhitespace.Value">
            <summary>
            Get the result.
            </summary>
            <returns>the result</returns>
        </member>
        <member name="T:Yaapii.Atoms.Text.Joined">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> of texts joined together.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Joined.#ctor(System.String,System.String[])">
            <summary>
            Joins A <see cref="T:Yaapii.Atoms.IText"/>s together with the delimiter between them.
            </summary>
            <param name="delimit">delimiter</param>
            <param name="strs">texts to join</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Joined.#ctor(System.String,System.Boolean,System.String[])">
            <summary>
            Joins A <see cref="T:Yaapii.Atoms.IText"/>s together with the delimiter between them.
            </summary>
            <param name="delimit">delimiter</param>
            <param name="strs">texts to join</param>
            <param name="live">should the object build its value live, every time it is used?</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Joined.#ctor(System.String,System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            Joins texts together with the delimiter between them.
            </summary>
            <param name="delimit">delimiter</param>
            <param name="strs">texts to join</param>
            <param name="live">should the object build its value live, every time it is used?</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Joined.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText[])">
            <summary>
            Joins texts together with the delimiter between them.
            </summary>
            <param name="delimit">delimiter</param>
            <param name="txts">texts to join</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Joined.#ctor(Yaapii.Atoms.IText,System.Boolean,Yaapii.Atoms.IText[])">
            <summary>
            Joins texts together with the delimiter between them.
            </summary>
            <param name="delimit">delimiter</param>
            <param name="txts">texts to join</param>
            <param name="live">should the object build its value live, every time it is used?</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Joined.#ctor(System.String,Yaapii.Atoms.IText[])">
            <summary>
            Joins texts together with the delimiter between them.
            </summary>
            <param name="delimit">delimiter</param>
            <param name="txts">texts to join</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Joined.#ctor(System.String,System.Boolean,Yaapii.Atoms.IText[])">
            <summary>
            Joins texts together with the delimiter between them.
            </summary>
            <param name="delimit">delimiter</param>
            <param name="txts">texts to join</param>
            <param name="live">should the object build its value live, every time it is used?</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Joined.#ctor(System.String,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText},System.Boolean)">
            <summary>
            Joins texts together with the delimiter between them.
            </summary>
            <param name="delimit">delimiter</param>
            <param name="txts">texts to join</param>
            <param name="live">should the object build its value live, every time it is used?</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Joined.#ctor(System.String,System.Func{System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText}},System.Boolean)">
            <summary>
            Joins texts together with the delimiter between them.
            </summary>
            <param name="delimit">delimiter</param>
            <param name="txts">texts to join</param>
            <param name="live">should the object build its value live, every time it is used?</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Joined.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IScalar{System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText}},System.Boolean)">
            <summary>
            Joins texts together with the delimiter between them.
            </summary>
            <param name="delimit">delimiter</param>
            <param name="txts">texts to join</param>
            <param name="live">should the object build its value live, every time it is used?</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Joined.#ctor(Yaapii.Atoms.IText,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText},System.Boolean)">
            <summary>
            Joins texts together with the delimiter between them.
            </summary>
            <param name="delimit">delimiter</param>
            <param name="txts">texts to join</param>
            <param name="live">should the object build its value live, every time it is used?</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Joined.#ctor(Yaapii.Atoms.IText,System.Func{System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText}},System.Boolean)">
            <summary>
            Joins texts together with the delimiter between them.
            </summary>
            <param name="delimit">delimiter</param>
            <param name="txts">scalars of texts to join</param>
            <param name="live">should the object build its value live, every time it is used?</param>
        </member>
        <member name="T:Yaapii.Atoms.Text.LiveText">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of other objects.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(System.Int32)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a int.
            </summary>
            <param name="input">number</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(System.Int64)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a long.
            </summary>
            <param name="input">number</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(System.Double)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a double
            </summary>
            <param name="input">a <see cref="T:System.Double"/></param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(System.Double,System.Globalization.CultureInfo)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a double
            </summary>
            <param name="input">a <see cref="T:System.Double"/></param>
            <param name="cultureInfo">The </param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(System.Single)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a float
            </summary>
            <param name="input">a <see cref="T:System.Single"/></param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(System.Single,System.Globalization.CultureInfo)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a double
            </summary>
            <param name="input">a <see cref="T:System.Single"/></param>
            <param name="cultureInfo">The </param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(System.Uri)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:System.Uri"/>.
            </summary>
            <param name="uri">a file <see cref="T:System.Uri"/></param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(System.Uri,System.Text.Encoding)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:System.Uri"/>.
            </summary>
            <param name="uri">a file <see cref="T:System.Uri"/></param>
            <param name="encoding">encoding of the data at the uri</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(System.IO.FileInfo)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:System.IO.FileInfo"/>
            </summary>
            <param name="file"></param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(System.IO.FileInfo,System.Text.Encoding)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:System.IO.FileInfo"/>
            </summary>
            <param name="file"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(System.IO.Stream)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:Yaapii.Atoms.IInput"/>.
            </summary>
            <param name="stream">a <see cref="T:System.IO.Stream"/></param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(Yaapii.Atoms.IInput)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:Yaapii.Atoms.IInput"/>.
            </summary>
            <param name="input">a <see cref="T:Yaapii.Atoms.IInput"/></param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(Yaapii.Atoms.IInput,System.Int32)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:Yaapii.Atoms.IInput"/>.
            </summary>
            <param name="input">a input</param>
            <param name="max">maximum buffer size</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(Yaapii.Atoms.IInput,System.Text.Encoding)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:Yaapii.Atoms.IInput"/>.
            </summary>
            <param name="input">a input</param>
            <param name="encoding"><see cref="T:System.Text.Encoding"/> of the input</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(Yaapii.Atoms.IInput,System.Int32,System.Text.Encoding)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:Yaapii.Atoms.IInput"/>.
            </summary>
            <param name="input">a <see cref="T:Yaapii.Atoms.IInput"/></param>
            <param name="encoding">encoding of the <see cref="T:Yaapii.Atoms.IInput"/></param>
            <param name="max">maximum buffer size</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(System.IO.StringReader)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:System.IO.StreamReader"/>.
            </summary>
            <param name="rdr">a <see cref="T:System.IO.StreamReader"/></param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(System.IO.StringReader,System.Text.Encoding)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:System.IO.StreamReader"/>.
            </summary>
            <param name="rdr">a <see cref="T:System.IO.StreamReader"/></param>
            <param name="enc"><see cref="T:System.Text.Encoding"/> of the <see cref="T:System.IO.StreamReader"/></param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(System.IO.StreamReader)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:System.IO.StreamReader"/>.
            </summary>
            <param name="rdr">a <see cref="T:System.IO.StreamReader"/></param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(System.IO.StreamReader,System.Text.Encoding)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:System.IO.StreamReader"/>.
            </summary>
            <param name="rdr">a <see cref="T:System.IO.StreamReader"/></param>
            <param name="cset"><see cref="T:System.Text.Encoding"/> of the <see cref="T:System.IO.StreamReader"/></param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(System.IO.StreamReader,System.Text.Encoding,System.Int32)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:System.IO.StreamReader"/>.
            </summary>
            <param name="rdr">a <see cref="T:System.IO.StreamReader"/></param>
            <param name="cset"><see cref="T:System.Text.Encoding"/> of the <see cref="T:System.IO.StreamReader"/></param>
            <param name="max">maximum buffer size</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(System.Text.StringBuilder)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="builder">a <see cref="T:System.Text.StringBuilder"/></param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(System.Text.StringBuilder,System.Text.Encoding)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="builder">a <see cref="T:System.Text.StringBuilder"/></param>
            <param name="enc"><see cref="T:System.Text.Encoding"/> of the <see cref="T:System.IO.StreamReader"/></param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(System.Char[])">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:System.Char"/> array.
            </summary>
            <param name="chars">a char array</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(System.Char[],System.Text.Encoding)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:System.Char"/> array.
            </summary>
            <param name="chars">a char array</param>
            <param name="encoding"><see cref="T:System.Text.Encoding"/> of the chars</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(System.Exception)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:System.Exception"/>.
            </summary>
            <param name="error"><see cref="T:System.Exception"/> to serialize</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(System.Byte[])">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:System.Byte"/> array.
            </summary>
            <param name="bytes">a byte array</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(Yaapii.Atoms.IBytes)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of <see cref="T:Yaapii.Atoms.IBytes"/> object.
            </summary>
            <param name="bytes">A <see cref="T:Yaapii.Atoms.IBytes"/> object</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(Yaapii.Atoms.IBytes,System.Text.Encoding)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of <see cref="T:Yaapii.Atoms.IBytes"/> object.
            </summary>
            <param name="bytes">A <see cref="T:Yaapii.Atoms.IBytes"/> object</param>
            <param name="encoding"><see cref="T:System.Text.Encoding"/> of the <see cref="T:Yaapii.Atoms.IBytes"/> object</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(System.String)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of <see cref="T:System.String"/>.
            </summary>
            <param name="input">a string</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(System.String,System.Text.Encoding)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of <see cref="T:System.String"/>.
            </summary>
            <param name="input">a string</param>
            <param name="encoding"><see cref="T:System.Text.Encoding"/> of the string</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(Yaapii.Atoms.IFunc{System.String})">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of the return value of a <see cref="T:Yaapii.Atoms.IFunc`1"/>.
            </summary>
            <param name="fnc">func returning a string</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(Yaapii.Atoms.IScalar{System.String})">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of encapsulating <see cref="T:Yaapii.Atoms.IScalar`1"/>.
            </summary>
            <param name="scalar">scalar of a string</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.LiveText.#ctor(System.Func{System.String})">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of encapsulating <see cref="T:Yaapii.Atoms.IScalar`1"/>.
            </summary>
            <param name="txt">func building a of a string</param>
        </member>
        <member name="T:Yaapii.Atoms.Text.Lower">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> as lowercase.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Lower.#ctor(Yaapii.Atoms.IText)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/>  as lowercase.
            </summary>
            <param name="text">text to lower</param>
        </member>
        <member name="T:Yaapii.Atoms.Text.Normalized">
            <summary>
            Normalized A <see cref="T:Yaapii.Atoms.IText"/> (whitespaces replaced with one single space)
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Normalized.#ctor(System.String)">
            <summary>
            Normalized A <see cref="T:Yaapii.Atoms.IText"/>  (whitespaces replaced with one single space)
            </summary>
            <param name="text">text to normalize</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Normalized.#ctor(Yaapii.Atoms.IText)">
            <summary>
            Normalized A <see cref="T:Yaapii.Atoms.IText"/>  (whitespaces replaced with one single space)
            </summary>
            <param name="text">text to normalize</param>
        </member>
        <member name="T:Yaapii.Atoms.Text.NotNull">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> that can't accept null.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.NotNull.#ctor(Yaapii.Atoms.IText)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/>  that can't accept null.
            </summary>
            <param name="text"></param>
        </member>
        <member name="T:Yaapii.Atoms.Text.Paragraph">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(System.String,System.Collections.Generic.IEnumerable{System.String},System.String[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.String[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.String[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.String[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(System.String,System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.String[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(System.String,System.String,System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.String[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.String[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(Yaapii.Atoms.IText,System.Collections.Generic.IEnumerable{System.String},System.String[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText,System.Collections.Generic.IEnumerable{System.String},System.String[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,System.Collections.Generic.IEnumerable{System.String},System.String[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,System.Collections.Generic.IEnumerable{System.String},System.String[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,System.Collections.Generic.IEnumerable{System.String},System.String[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,System.Collections.Generic.IEnumerable{System.String},System.String[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,System.Collections.Generic.IEnumerable{System.String},System.String[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(System.String,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText},System.String[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(System.String,System.String,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText},System.String[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(System.String,System.String,System.String,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText},System.String[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText},System.String[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(System.String,System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText},System.String[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(System.String,System.String,System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText},System.String[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText},System.String[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(Yaapii.Atoms.IText,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText},System.String[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText},System.String[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText},System.String[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText},System.String[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText},System.String[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText},System.String[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText},System.String[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(System.String,System.Collections.Generic.IEnumerable{System.String},Yaapii.Atoms.IText[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(System.String,System.String,System.Collections.Generic.IEnumerable{System.String},Yaapii.Atoms.IText[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},Yaapii.Atoms.IText[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},Yaapii.Atoms.IText[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(System.String,System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},Yaapii.Atoms.IText[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(System.String,System.String,System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},Yaapii.Atoms.IText[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},Yaapii.Atoms.IText[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(Yaapii.Atoms.IText,System.Collections.Generic.IEnumerable{System.String},Yaapii.Atoms.IText[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText,System.Collections.Generic.IEnumerable{System.String},Yaapii.Atoms.IText[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,System.Collections.Generic.IEnumerable{System.String},Yaapii.Atoms.IText[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,System.Collections.Generic.IEnumerable{System.String},Yaapii.Atoms.IText[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,System.Collections.Generic.IEnumerable{System.String},Yaapii.Atoms.IText[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,System.Collections.Generic.IEnumerable{System.String},Yaapii.Atoms.IText[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,System.Collections.Generic.IEnumerable{System.String},Yaapii.Atoms.IText[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(System.String,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText},Yaapii.Atoms.IText[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(System.String,System.String,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText},Yaapii.Atoms.IText[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(System.String,System.String,System.String,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText},Yaapii.Atoms.IText[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText},Yaapii.Atoms.IText[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(System.String,System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText},Yaapii.Atoms.IText[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(System.String,System.String,System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText},Yaapii.Atoms.IText[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText},Yaapii.Atoms.IText[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(Yaapii.Atoms.IText,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText},Yaapii.Atoms.IText[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText},Yaapii.Atoms.IText[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText},Yaapii.Atoms.IText[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText},Yaapii.Atoms.IText[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText},Yaapii.Atoms.IText[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText},Yaapii.Atoms.IText[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,Yaapii.Atoms.IText,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText},Yaapii.Atoms.IText[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(System.String[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(Yaapii.Atoms.IText[])">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Paragraph.#ctor(System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText})">
            <summary>
            A paragraph which seperates the given lines by a carriage return.
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Text.Repeated">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> repeated multiple times.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Repeated.#ctor(System.String,System.Int32)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/>  repeated multiple times.
            </summary>
            <param name="text">text to repeat</param>
            <param name="count">how often to repeat</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Repeated.#ctor(Yaapii.Atoms.IText,System.Int32)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/>  repeated multiple times.
            </summary>
            <param name="text">text to repeat</param>
            <param name="count">how often to repeat</param>
        </member>
        <member name="T:Yaapii.Atoms.Text.Replaced">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> whose contents have been replaced by another text.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Replaced.#ctor(Yaapii.Atoms.IText,System.String,System.String)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/>  whose contents have been replaced by another text.
            </summary>
            <param name="text">text to replace contents in</param>
            <param name="find">part to replace</param>
            <param name="replace">replacement to insert</param>
        </member>
        <member name="T:Yaapii.Atoms.Text.Reversed">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> which has been reversed.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Reversed.#ctor(Yaapii.Atoms.IText)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> which has been reversed.
            </summary>
            <param name="text">text to reverse</param>
        </member>
        <member name="T:Yaapii.Atoms.Text.Rotated">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> whose characters have been rotated.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Rotated.#ctor(Yaapii.Atoms.IText,System.Int32)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> whose characters have been rotated.
            </summary>
            <param name="text">text to rotate</param>
            <param name="shift">direction and amount of chars to rotate (minus means rotate left, plus means rotate right)</param>
        </member>
        <member name="T:Yaapii.Atoms.Text.Split">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> which has been splitted at the given string.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Split.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> which has been splitted at the given string.
            </summary>
            <param name="text">text to split</param>
            <param name="rgx">regex to use for splitting</param>
            <param name="remBlank">switch to remove empty or whitspace stirngs from result or not</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Split.#ctor(System.String,Yaapii.Atoms.IText,System.Boolean)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> which has been splitted at the given string.
            </summary>
            <param name="text">text to split</param>
            <param name="rgx">regex to use for splitting</param>
            <param name="remBlank">switch to remove empty or whitspace stirngs from result or not</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Split.#ctor(Yaapii.Atoms.IText,System.String,System.Boolean)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> which has been splitted at the given string.
            </summary>
            <param name="text">text to split</param>
            <param name="rgx">regex to use for splitting</param>
            <param name="remBlank">switch to remove empty or whitspace stirngs from result or not</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Split.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText,System.Boolean)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> which has been splitted at the given string.
            </summary>
            <param name="text">text to split</param>
            <param name="rgx">regex to use for splitting</param>
            <param name="remBlank">switch to remove empty or whitspace stirngs from result or not</param>
        </member>
        <member name="T:Yaapii.Atoms.Text.StartsWith">
            <summary>
            Checks if a text starts with a given content.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.StartsWith.#ctor(Yaapii.Atoms.IText,System.String)">
            <summary>
            Checks if a <see cref="T:Yaapii.Atoms.IText"/> starts with a given <see cref="T:System.String"/>
            </summary>
            <param name="text">Text to test</param>
            <param name="start">Starting content to use in the test</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.StartsWith.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText)">
            <summary>
            Checks if a <see cref="T:Yaapii.Atoms.IText"/> starts with a given <see cref="T:Yaapii.Atoms.IText"/>
            </summary>
            <param name="text">Text to test</param>
            <param name="start">Starting content to use in the test</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.StartsWith.Value">
            <summary>
            Gets the result
            </summary>
            <returns>The result</returns>
        </member>
        <member name="T:Yaapii.Atoms.Text.Strict">
            <summary>
            A strict text which can only be one of the specified valid texts.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Strict.#ctor(System.String,System.String[])">
            <summary>
            A strict text which can only be one of the specified valid texts, ignoring case.
            </summary>
            <param name="candidate">The canidate to check for valid texts</param>
            <param name="valid">The valid texts</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Strict.#ctor(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            A strict text which can only be one of the specified valid texts, ignoring case.
            </summary>
            <param name="candidate">The canidate to check for valid texts</param>
            <param name="valid">The valid texts</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Strict.#ctor(System.String,System.Boolean,System.String[])">
            <summary>
            A strict text which can only be one of the specified valid texts.
            </summary>
            <param name="candidate">The canidate to check for valid texts</param>
            <param name="ignoreCase">Ignore case in the canidate and valid texts</param>
            <param name="valid">The valid texts</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Strict.#ctor(System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            A strict text which can only be one of the specified valid texts.
            </summary>
            <param name="candidate">The canidate to check for valid texts</param>
            <param name="ignoreCase">Ignore case in the canidate and valid texts</param>
            <param name="valid">The valid texts</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Strict.#ctor(Yaapii.Atoms.IText,System.String[])">
            <summary>
            A strict text which can only be one of the specified valid texts, ignoring case.
            </summary>
            <param name="candidate">The canidate to check for valid texts</param>
            <param name="valid">The valid texts</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Strict.#ctor(Yaapii.Atoms.IText,System.Boolean,System.String[])">
            <summary>
            A strict text which can only be one of the specified valid texts.
            </summary>
            <param name="candidate">The canidate to check for valid texts</param>
            <param name="ignoreCase">Ignore case in the canidate and valid texts</param>
            <param name="valid">The valid texts</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Strict.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText[])">
            <summary>
            A strict text which can only be one of the specified valid texts, ignoring case.
            </summary>
            <param name="candidate">The canidate to check for valid texts</param>
            <param name="valid">The valid texts</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Strict.#ctor(Yaapii.Atoms.IText,System.Boolean,Yaapii.Atoms.IText[])">
            <summary>
            A strict text which can only be one of the specified valid texts.
            </summary>
            <param name="candidate">The canidate to check for valid texts</param>
            <param name="ignoreCase">Ignore case in the canidate and valid texts</param>
            <param name="valid">The valid texts</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Strict.#ctor(Yaapii.Atoms.IText,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText})">
            <summary>
            A strict text which can only be one of the specified valid texts, ignoring case.
            </summary>
            <param name="candidate">The canidate to check for valid texts</param>
            <param name="valid">The valid texts</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Strict.#ctor(Yaapii.Atoms.IText,System.Boolean,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText})">
            <summary>
            A strict text which can only be one of the specified valid texts.
            </summary>
            <param name="candidate">The canidate to check for valid texts</param>
            <param name="ignoreCase">Ignore case in the canidate and valid texts</param>
            <param name="valid">The valid texts</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Strict.#ctor(Yaapii.Atoms.IText,System.Collections.Generic.IEnumerable{Yaapii.Atoms.IText},Yaapii.Atoms.IScalar{System.StringComparison})">
            <summary>
            A strict text which can only be one of the specified valid texts.
            </summary>
            <param name="candidate">The canidate to check for valid texts</param>
            <param name="valid">The valid texts</param>
            <param name="stringComparer">Ignore case in the canidate and valid texts</param>
        </member>
        <member name="T:Yaapii.Atoms.Text.SubText">
            <summary>
            Extracted subtext from a <see cref="T:Yaapii.Atoms.IText"/>.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.SubText.#ctor(System.String,System.Int32)">
            <summary>
            Extracted subtext from a <see cref="T:System.String"/>.
            </summary>
            <param name="text">text to extreact from</param>
            <param name="strt">where to start</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.SubText.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Extracted subtext from a <see cref="T:System.String"/>.
            </summary>
            <param name="text">text to extract from</param>
            <param name="strt">where to start</param>
            <param name="end">where to end</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.SubText.#ctor(Yaapii.Atoms.IText,System.Int32)">
            <summary>
            Extracted subtext from a <see cref="T:Yaapii.Atoms.IText"/>.
            </summary>
            <param name="text">text to extract from</param>
            <param name="strt">where to start</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.SubText.#ctor(Yaapii.Atoms.IText,System.Int32,System.Int32)">
            <summary>
            Extracted subtext from a <see cref="T:Yaapii.Atoms.IText"/>.
            </summary>
            <param name="text">text to extract from</param>
            <param name="strt">where to start</param>
            <param name="end">where to end</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.SubText.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.Scalar.Live{System.Int32},Yaapii.Atoms.Scalar.Live{System.Int32},System.Boolean)">
            <summary>
            Extracted subtext from a <see cref="T:Yaapii.Atoms.IText"/>.
            </summary>
            <param name="text">text to extract from</param>
            <param name="strt">where to start encapsulated in a scalar</param>
            <param name="len">where to end encapsulated in a scalar</param>
            <param name="live">should the object build its value live, every time it is used?</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.SubText.#ctor(Yaapii.Atoms.IText,System.Func{System.Int32},System.Func{System.Int32})">
            <summary>
            Extracted subtext from a <see cref="T:Yaapii.Atoms.IText"/>.
            </summary>
            <param name="text">text to extract from</param>
            <param name="strt">where to start encapsulated in a scalar</param>
            <param name="len">where to end encapsulated in a scalar</param>
        </member>
        <member name="T:Yaapii.Atoms.Text.Synced">
            <summary>
            An <see cref="T:Yaapii.Atoms.IText"/> which is thread safe.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Synced.#ctor(Yaapii.Atoms.IText)">
            <summary>
            An <see cref="T:Yaapii.Atoms.IText"/> which is thread safe.
            </summary>
            <param name="text">Text to be accessed thread safe</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Synced.#ctor(Yaapii.Atoms.IText,System.Object)">
            <summary>
            An <see cref="T:Yaapii.Atoms.IText"/> which is thread safe.
            </summary>
            <param name="text">Text to be accessed thread safe</param>
            <param name="lck">Object to be locked to ensure thread safety</param>
            <returns></returns>
        </member>
        <member name="T:Yaapii.Atoms.Text.TextBase64">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> as Base64 encoded <see cref="T:Yaapii.Atoms.IText"/>
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextBase64.#ctor(System.String)">
            <summary>
            A <see cref="T:System.String"/> as Base64-Encoded <see cref="T:Yaapii.Atoms.IText"/>
            </summary>
            <param name="str">string to encode</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextBase64.#ctor(Yaapii.Atoms.IText)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> as Base64-Encoded <see cref="T:Yaapii.Atoms.IText"/>
            </summary>
            <param name="text">text to encode</param>
        </member>
        <member name="T:Yaapii.Atoms.Text.TextEnvelope">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> envelope.
            The envelope can work in live or in sticky mode.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextEnvelope.#ctor(Yaapii.Atoms.IText,System.Boolean)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> envelope.
            The envelope can work in live or in sticky mode.
            </summary>
            <param name="text">Origin text</param>
            <param name="live">should the value be created every time the object is used?</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextEnvelope.#ctor(System.Func{System.String},System.Boolean)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> envelope.
            The envelope can work in live or in sticky mode.
            </summary>
            <param name="origin">How to create the value</param>
            <param name="live">should the value be created every time the object is used?</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextEnvelope.AsString">
            <summary>
            Gives the text as a string.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Yaapii.Atoms.Text.TextOf">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of other objects.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(System.Int32)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a int.
            </summary>
            <param name="input">number</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(System.Int64)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a long.
            </summary>
            <param name="input">number</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(System.Double)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a double
            </summary>
            <param name="input">a <see cref="T:System.Double"/></param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(System.Double,System.Globalization.CultureInfo)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a double
            </summary>
            <param name="input">a <see cref="T:System.Double"/></param>
            <param name="cultureInfo">The </param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(System.Single)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a float
            </summary>
            <param name="input">a <see cref="T:System.Single"/></param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(System.Single,System.Globalization.CultureInfo)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a double
            </summary>
            <param name="input">a <see cref="T:System.Single"/></param>
            <param name="cultureInfo">The </param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(System.Uri)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:System.Uri"/>.
            </summary>
            <param name="uri">a file <see cref="T:System.Uri"/></param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(System.Uri,System.Text.Encoding)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:System.Uri"/>.
            </summary>
            <param name="uri">a file <see cref="T:System.Uri"/></param>
            <param name="encoding">encoding of the data at the uri</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(System.IO.FileInfo)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:System.IO.FileInfo"/>
            </summary>
            <param name="file"></param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(System.IO.FileInfo,System.Text.Encoding)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:System.IO.FileInfo"/>
            </summary>
            <param name="file"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(System.IO.Stream)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:Yaapii.Atoms.IInput"/>.
            </summary>
            <param name="stream">a <see cref="T:System.IO.Stream"/></param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(Yaapii.Atoms.IInput)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:Yaapii.Atoms.IInput"/>.
            </summary>
            <param name="input">a <see cref="T:Yaapii.Atoms.IInput"/></param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(Yaapii.Atoms.IInput,System.Int32)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:Yaapii.Atoms.IInput"/>.
            </summary>
            <param name="input">a input</param>
            <param name="max">maximum buffer size</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(Yaapii.Atoms.IInput,System.Text.Encoding)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:Yaapii.Atoms.IInput"/>.
            </summary>
            <param name="input">a input</param>
            <param name="encoding"><see cref="T:System.Text.Encoding"/> of the input</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(Yaapii.Atoms.IInput,System.Int32,System.Text.Encoding)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:Yaapii.Atoms.IInput"/>.
            </summary>
            <param name="input">a <see cref="T:Yaapii.Atoms.IInput"/></param>
            <param name="encoding">encoding of the <see cref="T:Yaapii.Atoms.IInput"/></param>
            <param name="max">maximum buffer size</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(System.IO.StringReader)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:System.IO.StreamReader"/>.
            </summary>
            <param name="rdr">a <see cref="T:System.IO.StreamReader"/></param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(System.IO.StringReader,System.Text.Encoding)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:System.IO.StreamReader"/>.
            </summary>
            <param name="rdr">a <see cref="T:System.IO.StreamReader"/></param>
            <param name="enc"><see cref="T:System.Text.Encoding"/> of the <see cref="T:System.IO.StreamReader"/></param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(System.IO.StreamReader)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:System.IO.StreamReader"/>.
            </summary>
            <param name="rdr">a <see cref="T:System.IO.StreamReader"/></param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(System.IO.StreamReader,System.Text.Encoding)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:System.IO.StreamReader"/>.
            </summary>
            <param name="rdr">a <see cref="T:System.IO.StreamReader"/></param>
            <param name="cset"><see cref="T:System.Text.Encoding"/> of the <see cref="T:System.IO.StreamReader"/></param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(System.IO.StreamReader,System.Text.Encoding,System.Int32)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:System.IO.StreamReader"/>.
            </summary>
            <param name="rdr">a <see cref="T:System.IO.StreamReader"/></param>
            <param name="cset"><see cref="T:System.Text.Encoding"/> of the <see cref="T:System.IO.StreamReader"/></param>
            <param name="max">maximum buffer size</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(System.Text.StringBuilder)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="builder">a <see cref="T:System.Text.StringBuilder"/></param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(System.Text.StringBuilder,System.Text.Encoding)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="builder">a <see cref="T:System.Text.StringBuilder"/></param>
            <param name="enc"><see cref="T:System.Text.Encoding"/> of the <see cref="T:System.IO.StreamReader"/></param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(System.Char[])">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:System.Char"/> array.
            </summary>
            <param name="chars">a char array</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(System.Char[],System.Text.Encoding)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:System.Char"/> array.
            </summary>
            <param name="chars">a char array</param>
            <param name="encoding"><see cref="T:System.Text.Encoding"/> of the chars</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(System.Exception)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:System.Exception"/>.
            </summary>
            <param name="error"><see cref="T:System.Exception"/> to serialize</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(System.Byte[])">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of a <see cref="T:System.Byte"/> array.
            </summary>
            <param name="bytes">a byte array</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(Yaapii.Atoms.IBytes)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of <see cref="T:Yaapii.Atoms.IBytes"/> object.
            </summary>
            <param name="bytes">A <see cref="T:Yaapii.Atoms.IBytes"/> object</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(Yaapii.Atoms.IBytes,System.Text.Encoding)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of <see cref="T:Yaapii.Atoms.IBytes"/> object.
            </summary>
            <param name="bytes">A <see cref="T:Yaapii.Atoms.IBytes"/> object</param>
            <param name="encoding"><see cref="T:System.Text.Encoding"/> of the <see cref="T:Yaapii.Atoms.IBytes"/> object</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(System.String)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of <see cref="T:System.String"/>.
            </summary>
            <param name="input">a string</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(System.String,System.Text.Encoding)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of <see cref="T:System.String"/>.
            </summary>
            <param name="input">a string</param>
            <param name="encoding"><see cref="T:System.Text.Encoding"/> of the string</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(Yaapii.Atoms.IFunc{System.String})">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of the return value of a <see cref="T:Yaapii.Atoms.IFunc`1"/>.
            </summary>
            <param name="fnc">func returning a string</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(Yaapii.Atoms.IScalar{System.String})">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of encapsulating <see cref="T:Yaapii.Atoms.IScalar`1"/>.
            </summary>
            <param name="scalar">scalar of a string</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TextOf.#ctor(System.Func{System.String})">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> out of encapsulating <see cref="T:Yaapii.Atoms.IScalar`1"/>.
            </summary>
            <param name="txt">scalar of a string</param>
        </member>
        <member name="T:Yaapii.Atoms.Text.UriOf">
            <summary>
            A text as a <see cref="T:System.Uri"/>
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.UriOf.#ctor(System.String)">
            <summary>
            A <see cref="T:System.String"/> as a <see cref="T:System.Uri"/>
            </summary>
            <param name="url">url as a string</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.UriOf.#ctor(Yaapii.Atoms.IText)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> as a <see cref="T:System.Uri"/>
            </summary>
            <param name="url">uri as text</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.UriOf.Value">
            <summary>
            Get the uri.
            </summary>
            <returns>the uri</returns>
        </member>
        <member name="T:Yaapii.Atoms.Text.Trimmed">
            <summary>
            An <see cref="T:Yaapii.Atoms.IText"/> without whitespaces / control characters or defined letters or a defined text on both sides.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Trimmed.#ctor(System.String)">
            <summary>
            A <see cref="T:System.String"/> trimmed (removed whitespaces) on both sides.
            </summary>
            <param name="text">text to trim</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Trimmed.#ctor(Yaapii.Atoms.IText)">
            <summary>
            An <see cref="T:Yaapii.Atoms.IText"/> trimmed (removed whitespaces) on both sides.
            </summary>
            <param name="text">text to trim</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Trimmed.#ctor(System.String,System.Char[])">
            <summary>
            A <see cref="T:System.String"/> trimmed with a <see cref="T:System.Char"/>[] on both sides.
            </summary>
            <param name="text">text to trim</param>
            <param name="trimText">text that trims the text</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Trimmed.#ctor(Yaapii.Atoms.IText,System.Char[])">
            <summary>
            An <see cref="T:Yaapii.Atoms.IText"/> trimmed with a <see cref="T:System.Char"/>[] on both sides.
            </summary>
            <param name="text">text to trim</param>
            <param name="trimText">text that trims the text</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Trimmed.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IScalar{System.Char[]})">
            <summary>
            An <see cref="T:Yaapii.Atoms.IText"/> trimmed with an IScalar&lt;<see cref="T:System.Char"/>[]&gt; on both sides.
            </summary>
            <param name="text">text to trim</param>
            <param name="trimText">text that trims the text</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Trimmed.#ctor(System.String,System.String)">
            <summary>
            A <see cref="T:System.String"/> from which a <see cref="T:System.String"/> is removed on both sides.
            </summary>
            <param name="text">text to trim</param>
            <param name="removeText">text that is removed from the text</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Trimmed.#ctor(System.String,Yaapii.Atoms.IText)">
            <summary>
            A <see cref="T:System.String"/> from which an <see cref="T:Yaapii.Atoms.IText"/> is removed on both sides.
            </summary>
            <param name="text">text to trim</param>
            <param name="removeText">text that is removed from the text</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Trimmed.#ctor(Yaapii.Atoms.IText,System.String)">
            <summary>
            An <see cref="T:Yaapii.Atoms.IText"/> from which a <see cref="T:System.String"/> is removed on both sides.
            </summary>
            <param name="text">text to trim</param>
            <param name="removeText">text that is removed from the text</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Trimmed.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText)">
            <summary>
            An <see cref="T:Yaapii.Atoms.IText"/> from which an IScalar&lt;<see cref="T:Yaapii.Atoms.IText"/>&gt; is removed on both sides.
            </summary>
            <param name="text">text to trim</param>
            <param name="removeText">text that is removed from the text</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.Trimmed.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText,System.Boolean)">
            <summary>
            An <see cref="T:Yaapii.Atoms.IText"/> from which an IScalar&lt;<see cref="T:Yaapii.Atoms.IText"/>&gt; is removed on both sides.
            </summary>
            <param name="text">text to trim</param>
            <param name="ignoreCase">Trim by disregarding case.</param>
            <param name="removeText">text that is removed from the text</param>
        </member>
        <member name="T:Yaapii.Atoms.Text.TrimmedLeft">
            <summary>
            An <see cref="T:Yaapii.Atoms.IText"/> without whitespaces / control characters or defined letters or a defined text on the left side.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.TrimmedLeft.#ctor(System.String)">
            <summary>
            A <see cref="T:System.String"/> trimmed (removed whitespaces) on the left side.
            </summary>
            <param name="text">text to trim</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TrimmedLeft.#ctor(Yaapii.Atoms.IText)">
            <summary>
            An <see cref="T:Yaapii.Atoms.IText"/> trimmed (removed whitespaces) on the left side.
            </summary>
            <param name="text">text to trim</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TrimmedLeft.#ctor(System.String,System.Char[])">
            <summary>
            A <see cref="T:System.String"/> trimmed with a <see cref="T:System.Char"/>[] on the left side.
            </summary>
            <param name="text">text to trim</param>
            <param name="trimText">text that trims the text</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TrimmedLeft.#ctor(Yaapii.Atoms.IText,System.Char[])">
            <summary>
            An <see cref="T:Yaapii.Atoms.IText"/> trimmed with a <see cref="T:System.Char"/>[] on the left side.
            </summary>
            <param name="text">text to trim</param>
            <param name="trimText">text that trims the text</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TrimmedLeft.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IScalar{System.Char[]})">
            <summary>
            An <see cref="T:Yaapii.Atoms.IText"/> trimmed with an IScalar&lt;<see cref="T:System.Char"/>[]&gt; on the left side.
            </summary>
            <param name="text">text to trim</param>
            <param name="trimText">text that trims the text</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TrimmedLeft.#ctor(System.String,System.String)">
            <summary>
            A <see cref="T:System.String"/> from which a <see cref="T:System.String"/> is removed on the left side.
            </summary>
            <param name="text">text to trim</param>
            <param name="removeText">text that is removed from the text</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TrimmedLeft.#ctor(System.String,Yaapii.Atoms.IText)">
            <summary>
            A <see cref="T:System.String"/> from which an <see cref="T:Yaapii.Atoms.IText"/> is removed on the left side.
            </summary>
            <param name="text">text to trim</param>
            <param name="removeText">text that is removed from the text</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TrimmedLeft.#ctor(Yaapii.Atoms.IText,System.String)">
            <summary>
            An <see cref="T:Yaapii.Atoms.IText"/> from which a <see cref="T:System.String"/> is removed on the left side.
            </summary>
            <param name="text">text to trim</param>
            <param name="removeText">text that is removed from the text</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TrimmedLeft.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText)">
            <summary>
            An <see cref="T:Yaapii.Atoms.IText"/> from which an IScalar&lt;<see cref="T:Yaapii.Atoms.IText"/>&gt; is removed on the left side.
            </summary>
            <param name="text">text to trim</param>
            <param name="removeText">text that is removed from the text</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TrimmedLeft.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText,System.Boolean)">
            <summary>
            An <see cref="T:Yaapii.Atoms.IText"/> from which an IScalar&lt;<see cref="T:Yaapii.Atoms.IText"/>&gt; is removed on the left side.
            </summary>
            <param name="text">text to trim</param>
            <param name="removeText">text that is removed from the text</param>
            <param name="ignoreCase">Trim by disregarding case.</param>
        </member>
        <member name="T:Yaapii.Atoms.Text.TrimmedRight">
            <summary>
            An <see cref="T:Yaapii.Atoms.IText"/> without whitespaces / control characters or defined letters or a defined text on the left side.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.TrimmedRight.#ctor(System.String)">
            <summary>
            A <see cref="T:System.String"/> trimmed (removed whitespaces) on the right side.
            </summary>
            <param name="text">text to trim</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TrimmedRight.#ctor(Yaapii.Atoms.IText)">
            <summary>
            An <see cref="T:Yaapii.Atoms.IText"/> trimmed (removed whitespaces) on the right side.
            </summary>
            <param name="text">text to trim</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TrimmedRight.#ctor(System.String,System.Char[])">
            <summary>
            A <see cref="T:System.String"/> trimmed with a <see cref="T:System.Char"/>[] on the right side.
            </summary>
            <param name="text">text to trim</param>
            <param name="trimText">text that trims the text</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TrimmedRight.#ctor(Yaapii.Atoms.IText,System.Char[])">
            <summary>
            An <see cref="T:Yaapii.Atoms.IText"/> trimmed with a <see cref="T:System.Char"/>[] on the right side.
            </summary>
            <param name="text">text to trim</param>
            <param name="trimText">text that trims the text</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TrimmedRight.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IScalar{System.Char[]})">
            <summary>
            An <see cref="T:Yaapii.Atoms.IText"/> trimmed with an IScalar&lt;<see cref="T:System.Char"/>[]&gt; on the right side.
            </summary>
            <param name="text">text to trim</param>
            <param name="trimText">text that trims the text</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TrimmedRight.#ctor(System.String,System.String)">
            <summary>
            A <see cref="T:System.String"/> from which a <see cref="T:System.String"/> is removed on the right side.
            </summary>
            <param name="text">text to trim</param>
            <param name="removeText">text that is removed from the text</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TrimmedRight.#ctor(System.String,Yaapii.Atoms.IText)">
            <summary>
            A <see cref="T:System.String"/> from which an <see cref="T:Yaapii.Atoms.IText"/> is removed on the right side.
            </summary>
            <param name="text">text to trim</param>
            <param name="removeText">text that is removed from the text</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TrimmedRight.#ctor(Yaapii.Atoms.IText,System.String)">
            <summary>
            An <see cref="T:Yaapii.Atoms.IText"/> from which a <see cref="T:System.String"/> is removed on the right side.
            </summary>
            <param name="text">text to trim</param>
            <param name="removeText">text that is removed from the text</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TrimmedRight.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText)">
            <summary>
            An <see cref="T:Yaapii.Atoms.IText"/> from which an IScalar&lt;<see cref="T:Yaapii.Atoms.IText"/>&gt; is removed on the right side.
            </summary>
            <param name="text">text to trim</param>
            <param name="removeText">text that is removed from the text</param>
        </member>
        <member name="M:Yaapii.Atoms.Text.TrimmedRight.#ctor(Yaapii.Atoms.IText,Yaapii.Atoms.IText,System.Boolean)">
            <summary>
            An <see cref="T:Yaapii.Atoms.IText"/> from which an IScalar&lt;<see cref="T:Yaapii.Atoms.IText"/>&gt; is removed on the right side.
            </summary>
            <param name="text">text to trim</param>
            <param name="removeText">text that is removed from the text</param>
            <param name="ignoreCase">Trim by disregarding case.</param>
        </member>
        <member name="T:Yaapii.Atoms.Text.Upper">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> as uppercase.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Text.Upper.#ctor(Yaapii.Atoms.IText)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IText"/> as uppercase.
            </summary>
            <param name="text">text to uppercase</param>
        </member>
        <member name="T:Yaapii.Atoms.Scalar.CharOf">
            <summary>
            A <see cref="T:System.Char"/> out of other objects.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.CharOf.#ctor(System.Int32)">
            <summary>
            Converts the value of the specified 32-bit signed integer to its equivalent Unicode character.
            </summary>
            <param name="integer">The 32-bit signed integer to convert.</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.CharOf.#ctor(System.UInt32)">
            <summary>
            Converts the value of the specified 32-bit unsigned integer to its equivalent Unicode character.
            </summary>
            <param name="uInteger">The 32-bit unsigned integer to convert.</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.CharOf.#ctor(System.Int16)">
            <summary>
            Converts the value of the specified 16-bit signed integer to its equivalent Unicode character.
            </summary>
            <param name="shrt">The 16-bit signed integer to convert.</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.CharOf.#ctor(System.UInt16)">
            <summary>
            Converts the value of the specified 16-bit unsigned integer to its equivalent Unicode character.
            </summary>
            <param name="uShort">The 16-bit unsigned integer to convert.</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.CharOf.#ctor(System.Int64)">
            <summary>
            Converts the value of the specified 64-bit signed integer to its equivalent Unicode character.
            </summary>
            <param name="lng">The 64-bit signed integer to convert.</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.CharOf.#ctor(System.UInt64)">
            <summary>
            Converts the value of the specified 64-bit unsigned integer to its equivalent Unicode character.
            </summary>
            <param name="ulng">The 64-bit unsigned integer to convert.</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.CharOf.#ctor(System.Double)">
            <summary>
            Converts the value of the specified double-precision floating-point number to an equivalent Unicode character.
            </summary>
            <param name="dbl">The double-precision floating-point number to convert.</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.CharOf.#ctor(System.Single)">
            <summary>
            Converts the value of the specified single-precision floating-point number to an equivalent Unicode character.
            </summary>
            <param name="flt">The single-precision floating-point number.</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.CharOf.#ctor(System.String)">
            <summary>
            Converts the first character of a specified string to a Unicode character.
            </summary>
            <param name="str">A string of length 1.</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.CharOf.#ctor(System.Byte)">
            <summary>
            Converts the value of the specified 8-bit unsigned integer to its equivalent Unicode character.
            </summary>
            <param name="byt">The 8-bit unsigned integer to convert.</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.CharOf.#ctor(System.SByte)">
            <summary>
            Converts the value of the specified 8-bit signed integer to its equivalent Unicode character.
            </summary>
            <param name="sByt">The 8-bit signed integer to convert.</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.CharOf.#ctor(Yaapii.Atoms.IScalar{System.Char})">
            <summary>
            Primary ctor
            </summary>
            <param name="converter">Converter method who returns the character.</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.CharOf.Value">
            <summary>
            the char
            </summary>
            <returns></returns>
        </member>
        <member name="T:Yaapii.Atoms.Scalar.And`1">
            <summary> Logical and. Returns true if all contents return true. </summary>
            <typeparam name="In"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.And`1.#ctor(System.Func{`0,System.Boolean},`0[])">
            <summary> Logical and. Returns true if all calls to <see cref="T:System.Func`2"/> were true. </summary>
            <param name="func"> the condition to apply </param>
            <param name="src"> list of items </param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.And`1.#ctor(System.Func{`0,System.Boolean},System.Collections.Generic.IEnumerable{`0})">
            <summary> Logical and. Returns true if all calls to <see cref="T:System.Func`2"/> were true. </summary>
            <param name="func"> the condition to apply </param>
            <param name="src"> list of items </param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.And`1.#ctor(Yaapii.Atoms.IFunc{`0,System.Boolean},`0[])">
            <summary> Logical and. Returns true if all calls to <see cref="T:Yaapii.Atoms.IFunc`2"/> were true. </summary>
            <param name="func"> the condition to apply </param>
            <param name="src"> list of items </param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.And`1.#ctor(Yaapii.Atoms.IFunc{`0,System.Boolean},System.Collections.Generic.IEnumerable{`0})">
            <summary> ctor </summary>
            <param name="func"> the condition to apply </param>
            <param name="src"> list of items </param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.And`1.#ctor(`0,System.Func{`0,System.Boolean}[])">
            <summary> True if all functions return true with given input value </summary>
            <param name="value"> Input value wich will executed by all given functions </param>
            <param name="functions"> Functions wich will executed with given input value </param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.And`1.#ctor(System.Collections.Generic.IEnumerable{Yaapii.Atoms.IScalar{System.Boolean}})">
            <summary></summary>
            <param name="src"></param>
        </member>
        <member name="T:Yaapii.Atoms.Scalar.And">
            <summary> Logical and. Returns true if all contents return true. </summary>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.And.#ctor(System.Func{System.Boolean}[])">
            <summary> Logical and. Returns true if all calls to <see cref="T:System.Func`2"/> were true. </summary>
            <param name="funcs"> the conditions to apply </param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.And.#ctor(Yaapii.Atoms.Enumerable.ManyOf{System.Func{System.Boolean}})">
            <summary> Logical and. Returns true if all calls to <see cref="T:System.Func`1"/> were true. </summary>
            <param name="funcs"> the conditions to apply </param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.And.#ctor(Yaapii.Atoms.IScalar{System.Boolean}[])">
            <summary> ctor </summary>
            <param name="src"> list of items </param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.And.#ctor(System.Boolean[])">
            <summary> ctor </summary>
            <param name="src"> list of items </param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.And.#ctor(System.Collections.Generic.IEnumerable{System.Boolean})">
            <summary> ctor </summary>
            <param name="src"> list of items </param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.And.#ctor(System.Collections.Generic.IEnumerable{Yaapii.Atoms.IScalar{System.Boolean}})">
            <summary> ctor </summary>
            <param name="src"> list of items </param>
        </member>
        <member name="T:Yaapii.Atoms.Scalar.BitAt">
            <summary>
            The value of a particular bit.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.BitAt.#ctor(Yaapii.Atoms.IBytes,System.Exception)">
            <summary>
            The value of the first bit.
            </summary>
            <param name="bytes">Bytes from where the bit is taken</param>
            <param name="exception">Exception which is thrown in case of an error</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.BitAt.#ctor(Yaapii.Atoms.IBytes,System.Int32,System.Exception)">
            <summary>
            The value of a particular bit.
            </summary>
            <param name="bytes">Bytes from where the bit is taken</param>
            <param name="position">Zero based bit index in the bytes</param>
            <param name="exception">Exception which is thrown in case of an error</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.BitAt.#ctor(Yaapii.Atoms.IBytes)">
            <summary>
            The value of the first bit.
            </summary>
            <param name="bytes">Bytes from where the bit is taken</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.BitAt.#ctor(Yaapii.Atoms.IBytes,System.Boolean)">
            <summary>
            The value of the first bit.
            </summary>
            <param name="bytes">Bytes from where the bit is taken</param>
            <param name="fallback">Result in case of an error</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.BitAt.#ctor(Yaapii.Atoms.IBytes,System.Int32,System.Boolean)">
            <summary>
            The value of a particular bit.
            </summary>
            <param name="bytes">Bytes from where the bit is taken</param>
            <param name="position">Zero based bit index in the bytes</param>
            <param name="fallback">Result in case of an error</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.BitAt.#ctor(Yaapii.Atoms.IBytes,System.Func{Yaapii.Atoms.IBytes,System.Boolean})">
            <summary>
            The value of the first bit.
            </summary>
            <param name="bytes">Bytes from where the bit is taken</param>
            <param name="fallback">Result in case of an error</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.BitAt.#ctor(Yaapii.Atoms.IBytes,Yaapii.Atoms.IFunc{Yaapii.Atoms.IBytes,System.Boolean})">
            <summary>
            The value of the first bit.
            </summary>
            <param name="bytes">Bytes from where the bit is taken</param>
            <param name="fallback">Result in case of an error</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.BitAt.#ctor(Yaapii.Atoms.IBytes,System.Int32)">
            <summary>
            The value of a particular bit.
            </summary>
            <param name="bytes">Bytes from where the bit is taken</param>
            <param name="position">Zero based bit index in the bytes</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.BitAt.#ctor(Yaapii.Atoms.IBytes,System.Int32,Yaapii.Atoms.IFunc{Yaapii.Atoms.IBytes,System.Boolean})">
            <summary>
            The value of a particular bit.
            </summary>
            <param name="bytes">Bytes from where the bit is taken</param>
            <param name="position">Zero based bit index in the bytes</param>
            <param name="fallback">Result in case of an error</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.BitAt.#ctor(Yaapii.Atoms.IBytes,System.Int32,System.Func{Yaapii.Atoms.IBytes,System.Boolean})">
            <summary>
            The value of a particular bit.
            </summary>
            <param name="bytes">Bytes from where the bit is taken</param>
            <param name="position">Zero based bit index in the bytes</param>
            <param name="fallback">Result in case of an error</param>
        </member>
        <member name="T:Yaapii.Atoms.Scalar.Each`1">
            <summary>
            Does to all elements in a <see cref="T:System.Collections.Generic.IEnumerable`1"/>
            </summary>
            <typeparam name="In"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Each`1.#ctor(System.Action{`0},`0[])">
            <summary>
            Executes the given Action for every element in the params.
            Replaces ForEach in LinQ. 
            <para>Object is <see cref="T:Yaapii.Atoms.IAction"/></para>
            </summary>
            <param name="proc">the condition to apply</param>
            <param name="src">list of items</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Each`1.#ctor(System.Action{`0},System.Collections.Generic.IEnumerable{`0})">
            <summary>
             Executes the given Action for every element in the Enumerable.
            Replaces ForEach in LinQ.
            <para>Object is <see cref="T:Yaapii.Atoms.IAction"/></para>
            </summary>
            <param name="proc">the condition to apply</param>
            <param name="src">list of items</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Each`1.#ctor(Yaapii.Atoms.IAction{`0},`0[])">
            <summary>
             Executes the given IAction for every element in the params.
            Replaces ForEach in LinQ.
            <para>Object is <see cref="T:Yaapii.Atoms.IAction"/></para>        /// </summary>
            <param name="proc">the condition to apply</param>
            <param name="src">list of items</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Each`1.#ctor(Yaapii.Atoms.IAction{`0},System.Collections.Generic.IEnumerable{`0})">
            <summary>
             Executes the given IAction for every element in the Enumerable.
            Replaces ForEach in LinQ.
            <para>Object is <see cref="T:Yaapii.Atoms.IAction"/></para>
            </summary>
            <param name="action"></param>
            <param name="enumerable"></param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Each`1.Invoke">
            <summary>
            Execute Action for each element
            </summary>
        </member>
        <member name="T:Yaapii.Atoms.Scalar.Equals`1">
            <summary>
            Checks the equality of contents.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Equals`1.#ctor(System.Func{`0},System.Func{`0})">
            <summary>
            Checks the equality of contents.
            </summary>
            <param name="first">function to return first value to compare</param>
            <param name="second">function to return second value to compare</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Equals`1.#ctor(`0,`0)">
            <summary>
            Checks the equality of contents.
            </summary>
            <param name="first">first value to compare</param>
            <param name="second">second value to compare</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Equals`1.#ctor(Yaapii.Atoms.IScalar{`0},Yaapii.Atoms.IScalar{`0})">
            <summary>
            Checks the equality of contents.
            </summary>
            <param name="first">scalar of first value to compare</param>
            <param name="second">scalar of second value to compare</param>
        </member>
        <member name="T:Yaapii.Atoms.Scalar.Fallback`1">
            <summary>
            Scalar which calls a fallback function if Value() fails.
            </summary>
            <typeparam name="Out">Type of output value</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Fallback`1.#ctor(Yaapii.Atoms.IScalar{`0},`0)">
            <summary>
            ctor
            </summary>
            <param name="origin">Scalar which can fail</param>
            <param name="fallback">Fallback if scalar fails</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Fallback`1.#ctor(Yaapii.Atoms.IScalar{`0},System.Func{`0})">
            <summary>
            ctor
            </summary>
            <param name="origin">Scalar which can fail</param>
            <param name="fallback">Fallback if scalar fails</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Fallback`1.#ctor(Yaapii.Atoms.IScalar{`0},System.Func{System.Exception,`0})">
            <summary>
            ctor
            </summary>
            <param name="origin">scalar which can fail</param>
            <param name="fallback">fallback to apply when fails</param>
        </member>
        <member name="T:Yaapii.Atoms.Scalar.False">
            <summary>
            Logical false.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.False.#ctor">
            <summary>
            Logical false.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.False.Value">
            <summary>
            Get the value.
            </summary>
            <returns>the value</returns>
        </member>
        <member name="T:Yaapii.Atoms.Scalar.FirstOf`1">
            <summary>
            First element in <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.FirstOf`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Exception)">
            <summary>
            Element from position in a <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <param name="source">source enum</param>
            <param name="ex">Exception to throw if no value can be found.</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.FirstOf`1.#ctor(System.Func{`0,System.Boolean},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Element from position in a <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <param name="source">source enum</param>
            <param name="condition">condition to find the desired item</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.FirstOf`1.#ctor(System.Func{`0,System.Boolean},System.Collections.Generic.IEnumerable{`0},System.Exception)">
            <summary>
            Element from position in a <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
            <param name="source">source enum</param>
            <param name="condition">condition to find the desired item</param>
            <param name="ex">Exception to throw if no value can be found.</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.FirstOf`1.#ctor(System.Collections.Generic.IEnumerable{`0},`0)">
            <summary>
            First element in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> with a fallback value.
            </summary>
            <param name="source">source enum</param>
            <param name="fallback">fallback func</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.FirstOf`1.#ctor(System.Func{`0,System.Boolean},System.Collections.Generic.IEnumerable{`0},`0)">
            <summary>
            First element in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> with a fallback value.
            </summary>
            <param name="source">source enum</param>
            <param name="fallback">fallback func</param>
            <param name="condition">condition to match in order to find the desired item</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.FirstOf`1.#ctor(System.Collections.Generic.IEnumerable{`0},Yaapii.Atoms.IScalar{`0})">
            <summary>
            First Element in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> fallback function <see cref="T:Yaapii.Atoms.IFunc`2"/>.
            </summary>
            <param name="source">source enum</param>
            <param name="fallback">fallback func</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.FirstOf`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Func{System.Collections.Generic.IEnumerable{`0},`0})">
            <summary>
            First element in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> fallback function <see cref="T:Yaapii.Atoms.IBiFunc`3"/>
            </summary>
            <param name="src">source enumerable</param>
            <param name="fallback">fallback if no match</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.FirstOf`1.#ctor(System.Func{`0,System.Boolean},System.Collections.Generic.IEnumerable{`0},System.Func{System.Collections.Generic.IEnumerable{`0},`0})">
            <summary>
            First element in a <see cref="T:System.Collections.Generic.IEnumerable`1"/> fallback function <see cref="T:Yaapii.Atoms.IBiFunc`3"/>
            </summary>
            <param name="src">source enumerable</param>
            <param name="fallback">fallback if no match</param>
            <param name="condition">condition to match</param>
        </member>
        <member name="T:Yaapii.Atoms.Scalar.IsNumber">
            <summary>
            Checks whether a given text is a number
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.IsNumber.#ctor(System.String)">
            <summary>
            Checks whether the given text is a number
            </summary>
            <param name="text">the text</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.IsNumber.#ctor(System.String,System.IFormatProvider)">
            <summary>
            Checks whether the given text is a number
            </summary>
            <param name="text">the text</param>
            <param name="provider">number format provider</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.IsNumber.#ctor(Yaapii.Atoms.IText)">
            <summary>
            Checks whether the given text is a number
            </summary>
            <param name="text">the text</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.IsNumber.#ctor(Yaapii.Atoms.IText,System.IFormatProvider)">
            <summary>
            Checks whether the given text is a number
            </summary>
            <param name="text">the text</param>
            <param name="provider">number format provider</param>
        </member>
        <member name="T:Yaapii.Atoms.Scalar.Live`1">
            <summary>
            A <see cref="T:Yaapii.Atoms.IScalar`1"/> out of other objects
            </summary>
            <typeparam name="T">type of the value</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Live`1.#ctor(`0)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IScalar`1"/> out of an object.
            </summary>
            <param name="org"></param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Live`1.#ctor(Yaapii.Atoms.IFunc{`0})">
            <summary>
            A <see cref="T:Yaapii.Atoms.IScalar`1"/> out of the return value from a <see cref="T:System.Func`2"/>.
            </summary>
            <param name="func"></param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Live`1.#ctor(Yaapii.Atoms.IFunc{System.Boolean,`0})">
            <summary>
            A <see cref="T:Yaapii.Atoms.IScalar`1"/> out of the return value from a <see cref="T:System.Func`2"/>.
            </summary>
            <param name="func"></param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Live`1.#ctor(System.Func{System.Boolean,`0})">
            <summary>
            A <see cref="T:Yaapii.Atoms.IScalar`1"/> out of the return value from an <see cref="T:Yaapii.Atoms.IFunc`2"/>
            </summary>
            <param name="func"></param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Live`1.#ctor(System.Func{`0})">
            <summary>
            Primary ctor
            </summary>
            <param name="func"></param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Live`1.Value">
            <summary>
            Gives the value
            </summary>
            <returns></returns>
        </member>
        <member name="T:Yaapii.Atoms.Scalar.NoNull`1">
            <summary>
            Scalar that will raise error or return fallback if value is null.
            </summary>
            <typeparam name="T">type of return value</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.NoNull`1.#ctor(`0)">
            <summary>
            A scalar with a fallback if value is null.
            </summary>
            <param name="origin">the original</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.NoNull`1.#ctor(`0,System.Exception)">
            <summary>
            A scalar with a fallback if value is null.
            </summary>
            <param name="origin">the original</param>
            <param name="ex">error to raise if null</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.NoNull`1.#ctor(`0,`0)">
            <summary>
            A scalar with a fallback if value is null.
            </summary>
            <param name="origin">the original</param>
            <param name="fallback">the fallback value</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.NoNull`1.#ctor(Yaapii.Atoms.IScalar{`0},`0)">
            <summary>
            A scalar with a fallback if value is null.
            </summary>
            <param name="origin">the original scalar</param>
            <param name="fallback">the fallback value</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.NoNull`1.#ctor(Yaapii.Atoms.IScalar{`0},Yaapii.Atoms.IFunc{`0})">
            <summary>
            A scalar with a fallback if value is null.
            </summary>
            <param name="origin">the original scalar</param>
            <param name="fallback">the fallback</param>
        </member>
        <member name="T:Yaapii.Atoms.Scalar.Not">
            <summary>
            Logical negative.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Not.#ctor(Yaapii.Atoms.IScalar{System.Boolean})">
            <summary>
            Logical negative.
            </summary>
            <param name="scalar">scalar to negate</param>
        </member>
        <member name="T:Yaapii.Atoms.Scalar.Or`1">
            <summary>
            Logical or. Returns true if any contents return true.
            </summary>
            <typeparam name="In"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Or`1.#ctor(System.Func{`0,System.Boolean},`0[])">
            <summary>
            Logical or. Returns true if any calls to <see cref="T:System.Func`2"/>
            were true.
            </summary>
            <param name="func">the condition to apply</param>
            <param name="src">list of items</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Or`1.#ctor(System.Func{`0,System.Boolean},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Logical or. Returns true if any calls to <see cref="T:System.Func`2"/>
            were true.
            </summary>
            <param name="func">the condition to apply</param>
            <param name="src">list of items</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Or`1.#ctor(Yaapii.Atoms.IFunc{`0,System.Boolean},`0[])">
            <summary>
            Logical or. Returns true if any calls to <see cref="T:Yaapii.Atoms.IFunc`2"/>
            were true.
            </summary>
            <param name="func">the condition to apply</param>
            <param name="src">list of items</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Or`1.#ctor(Yaapii.Atoms.IFunc{`0,System.Boolean},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            ctor
            </summary>
            <param name="func">the condition to apply</param>
            <param name="src">list of items</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Or`1.#ctor(`0,System.Func{`0,System.Boolean}[])">
            <summary>
            True if any functions return true with given input value
            </summary>
            <param name="value">
            Input value wich will executed by all given functions
            </param>
            <param name="functions">
            Functions wich will executed with given input value
            </param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Or`1.#ctor(System.Collections.Generic.IEnumerable{Yaapii.Atoms.IScalar{System.Boolean}})">
            <summary>
            ctor
            </summary>
            <param name="src">list of items</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Or`1.#ctor(Yaapii.Atoms.Scalar.Or)">
            <summary>
            Private primary ctor
            </summary>
            <param name="or">Non generic or</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Or`1.Value">
            <summary>
            Get the value.
            </summary>
            <returns>the value</returns>
        </member>
        <member name="T:Yaapii.Atoms.Scalar.Or">
            <summary>
            Logical or. Returns true if any contents return true.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Or.#ctor(System.Func{System.Boolean}[])">
            <summary>
            Logical or. Returns true if any calls to <see cref="T:System.Func`2"/>
            were true.
            </summary>
            <param name="funcs">the conditions to apply</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Or.#ctor(Yaapii.Atoms.Enumerable.ManyOf{System.Func{System.Boolean}})">
            <summary>
            Logical or. Returns true if any calls to <see cref="T:System.Func`1"/> were
            true.
            </summary>
            <param name="funcs">the conditions to apply</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Or.#ctor(Yaapii.Atoms.IScalar{System.Boolean}[])">
            <summary>
            ctor
            </summary>
            <param name="src">list of items</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Or.#ctor(System.Boolean[])">
            <summary>
            ctor
            </summary>
            <param name="src">list of items</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Or.#ctor(System.Collections.Generic.IEnumerable{System.Boolean})">
            <summary>
            ctor
            </summary>
            <param name="src">list of items</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Or.#ctor(System.Collections.Generic.IEnumerable{Yaapii.Atoms.IScalar{System.Boolean}})">
            <summary>
            ctor
            </summary>
            <param name="src">list of items</param>
        </member>
        <member name="T:Yaapii.Atoms.Scalar.ParallelAnd`1">
            <summary>
            Logical conjunction, in multiple threads. Returns true if all contents return true.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.ParallelAnd`1.#ctor(Yaapii.Atoms.IScalar{System.Boolean}[])">
            <summary>
            Logical conjunction, in multiple threads. Returns true if all contents return true.
            </summary>
            <param name="src"></param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.ParallelAnd`1.#ctor(Yaapii.Atoms.IAction{`0},`0[])">
            <summary>
            Logical conjunction, in multiple threads. Returns true if all contents return true.
            </summary>
            <param name="proc"></param>
            <param name="src"></param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.ParallelAnd`1.#ctor(Yaapii.Atoms.IFunc{`0,System.Boolean},`0[])">
            <summary>
            Logical conjunction, in multiple threads. Returns true if all contents return true.
            </summary>
            <param name="func"></param>
            <param name="src"></param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.ParallelAnd`1.#ctor(Yaapii.Atoms.IAction{`0},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Logical conjunction, in multiple threads. Returns true if all contents return true.
            </summary>
            <param name="proc"></param>
            <param name="src"></param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.ParallelAnd`1.#ctor(Yaapii.Atoms.IFunc{`0,System.Boolean},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Logical conjunction, in multiple threads. Returns true if all contents return true.
            </summary>
            <param name="func"></param>
            <param name="src"></param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.ParallelAnd`1.#ctor(System.Collections.Generic.IEnumerable{Yaapii.Atoms.IScalar{System.Boolean}})">
            <summary>
            Logical conjunction, in multiple threads. Returns true if all contents return true.
            </summary>
            <param name="src"></param>
        </member>
        <member name="T:Yaapii.Atoms.Scalar.Retry`1">
            <summary>
            <see cref="T:Yaapii.Atoms.IScalar`1"/> which will retry multiple times before throwing an exception.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Retry`1.#ctor(System.Func{`0},System.Int32)">
            <summary>
            <see cref="T:Yaapii.Atoms.IScalar`1"/> which will retry multiple times before throwing an exception.
            </summary>
            <param name="scalar">func to retry when needed</param>
            <param name="attempts">how often to retry</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Retry`1.#ctor(Yaapii.Atoms.IScalar{`0},System.Int32)">
            <summary>
            <see cref="T:Yaapii.Atoms.IScalar`1"/> which will retry multiple times before throwing an exception.
            </summary>
            <param name="scalar">scalar to retry when needed</param>
            <param name="attempts">how often to retry</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Retry`1.#ctor(Yaapii.Atoms.IScalar{`0},Yaapii.Atoms.IFunc{System.Int32,System.Boolean})">
            <summary>
            <see cref="T:Yaapii.Atoms.IScalar`1"/> which will retry until the given condition <see cref="T:Yaapii.Atoms.IFunc`2"/> matches before throwing an exception.
            </summary>
            <param name="scalar">scalar to retry when needed</param>
            <param name="exit"></param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.ScalarEnvelope`1.Value">
            <summary>
            Get the result.
            </summary>
            <returns>the result</returns>
        </member>
        <member name="T:Yaapii.Atoms.Scalar.ScalarOf`1">
            <summary>
            A s<see cref="T:Yaapii.Atoms.IScalar`1"/> that will return the same value from a cache always.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.ScalarOf`1.#ctor(`0)">
            <summary>
            A s<see cref="T:Yaapii.Atoms.IScalar`1"/> that will return the same value from a cache always.
            </summary>
            <param name="src">func to cache result from</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.ScalarOf`1.#ctor(System.Func{`0})">
            <summary>
            A s<see cref="T:Yaapii.Atoms.IScalar`1"/> that will return the same value from a cache always.
            </summary>
            <param name="src">func to cache result from</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.ScalarOf`1.#ctor(Yaapii.Atoms.IScalar{`0})">
            <summary>
            A s<see cref="T:Yaapii.Atoms.IScalar`1"/> that will return the same value from a cache always.
            </summary>
            <param name="src">scalar to cache result from</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.ScalarOf`1.#ctor(System.Func{`0},System.Func{`0,System.Boolean})">
            <summary>
            A s<see cref="T:Yaapii.Atoms.IScalar`1"/> that will return the same value from a cache as long the reload condition is false.
            </summary>
            <param name="srcFunc">func to cache result from</param>
            <param name="shouldReload">reload condition func</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.ScalarOf`1.#ctor(Yaapii.Atoms.IFunc{`0},System.Func{`0,System.Boolean})">
            <summary>
            A s<see cref="T:Yaapii.Atoms.IScalar`1"/> that will return the same value from a cache as long the reload condition is false.
            </summary>
            <param name="srcFunc">func to cache result from</param>
            <param name="shouldReload">reload condition func</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.ScalarOf`1.#ctor(Yaapii.Atoms.IScalar{`0},System.Func{`0,System.Boolean})">
            <summary>
            A s<see cref="T:Yaapii.Atoms.IScalar`1"/> that will return the same value from a cache as long the reload condition is false.
            </summary>
            <param name="src">scalar to cache result from</param>
            <param name="shouldReload">reload condition func</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.ScalarOf`1.Value">
            <summary>
            Get the value.
            </summary>
            <returns>the value</returns>
        </member>
        <member name="T:Yaapii.Atoms.Scalar.Solid`1">
            <summary>
            A Scalar that is both threadsafe and sticky.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Solid`1.#ctor(System.Func{`0})">
            <summary>
            A <see cref="T:Yaapii.Atoms.IScalar`1"/> that is threadsafe.
            </summary>
            <param name="src">the scalar to make operate threadsafe</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Solid`1.#ctor(System.Func{`0},System.Object)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IScalar`1"/> that is threadsafe and sticky.
            </summary>
            <param name="src">the scalar to make operate threadsafe</param>
            <param name="lck">the object to lock</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Solid`1.#ctor(Yaapii.Atoms.IScalar{`0})">
            <summary>
            A <see cref="T:Yaapii.Atoms.IScalar`1"/> that is threadsafe and sticky.
            </summary>
            <param name="src">the scalar to make operate threadsafe</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Solid`1.#ctor(Yaapii.Atoms.IScalar{`0},System.Object)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IScalar`1"/> that is threadsafe and sticky.
            </summary>
            <param name="src">the scalar to make operate threadsafe</param>
            <param name="lck">object to lock while using scalar</param>
        </member>
        <member name="T:Yaapii.Atoms.Scalar.Sync`1">
            <summary>
            A <see cref="T:Yaapii.Atoms.IScalar`1"/> that is threadsafe.
            </summary>
            <typeparam name="T">type of value</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Sync`1.#ctor(System.Func{`0})">
            <summary>
            A <see cref="T:Yaapii.Atoms.IScalar`1"/> that is threadsafe.
            </summary>
            <param name="src">the scalar to make operate threadsafe</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Sync`1.#ctor(System.Func{`0},System.Object)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IScalar`1"/> that is threadsafe.
            </summary>
            <param name="src">the scalar to make operate threadsafe</param>
            <param name="lck">the object to lock</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Sync`1.#ctor(Yaapii.Atoms.IScalar{`0})">
            <summary>
            A <see cref="T:Yaapii.Atoms.IScalar`1"/> that is threadsafe.
            </summary>
            <param name="src">the scalar to make operate threadsafe</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Sync`1.#ctor(Yaapii.Atoms.IScalar{`0},System.Object)">
            <summary>
            A <see cref="T:Yaapii.Atoms.IScalar`1"/> that is threadsafe.
            </summary>
            <param name="src">the scalar to make operate threadsafe</param>
            <param name="lck">object to lock while using scalar</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Sync`1.Value">
            <summary>
            Get the value.
            </summary>
            <returns>the value</returns>
        </member>
        <member name="T:Yaapii.Atoms.Scalar.Ternary`2">
            <summary>
            A ternary operation.
            </summary>
            <typeparam name="In">type of input</typeparam>
            <typeparam name="Out">type of output</typeparam>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Ternary`2.#ctor(`0,System.Func{`0,System.Boolean},System.Func{`0,`1},System.Func{`0,`1})">
            <summary>
            A ternary operation using the given input and functions.
            </summary>
            <param name="input">input</param>
            <param name="condition">condition</param>
            <param name="consequent">consequent</param>
            <param name="alternative">alternative</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Ternary`2.#ctor(`0,Yaapii.Atoms.IFunc{`0,System.Boolean},Yaapii.Atoms.IFunc{`0,`1},Yaapii.Atoms.IFunc{`0,`1})">
            <summary>
            A ternary operation using the given input and functions.
            </summary>
            <param name="input">input</param>
            <param name="condition">condition</param>
            <param name="consequent">consequent</param>
            <param name="alternative">alternative</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Ternary`2.#ctor(System.Boolean,`1,`1)">
            <summary>
            A ternary operation using the given input and functions.
            </summary>
            <param name="condition">condition</param>
            <param name="consequent">consequent</param>
            <param name="alternative">alternative</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Ternary`2.#ctor(Yaapii.Atoms.IScalar{System.Boolean},`1,`1)">
            <summary>
            A ternary operation using the given input and functions.
            </summary>
            <param name="condition">condition</param>
            <param name="consequent">consequent</param>
            <param name="alternative">alternative</param>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.Ternary`2.#ctor(Yaapii.Atoms.IScalar{System.Boolean},Yaapii.Atoms.IScalar{`1},Yaapii.Atoms.IScalar{`1})">
            <summary>
            A ternary operation using the given input and functions.
            </summary>
            <param name="condition">condition</param>
            <param name="consequent">consequent</param>
            <param name="alternative">alternative</param>
        </member>
        <member name="T:Yaapii.Atoms.Scalar.True">
            <summary>
            Logical truth.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.True.#ctor">
            <summary>
            Logical truth.
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Scalar.True.Value">
            <summary>
            True or not.
            </summary>
            <returns>True or not</returns>
        </member>
        <member name="T:Yaapii.Atoms.Time.DateAsText">
            <summary>
            A date formatted as a text
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Time.DateAsText.#ctor">
            <summary>
            Current Datetime as ISO
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Time.DateAsText.#ctor(System.DateTime)">
            <summary>
            A date formatted as ISO
            </summary>
            <param name="date"></param>
        </member>
        <member name="M:Yaapii.Atoms.Time.DateAsText.#ctor(Yaapii.Atoms.IScalar{System.DateTime})">
            <summary>
            A date formatted as ISO
            </summary>
            <param name="date"></param>
        </member>
        <member name="M:Yaapii.Atoms.Time.DateAsText.#ctor(System.DateTime,System.String)">
            <summary>
            A date formatted by using a format-string and <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>
            </summary>
            <param name="date">a date</param>
            <param name="format">a format pattern</param>
        </member>
        <member name="M:Yaapii.Atoms.Time.DateAsText.#ctor(Yaapii.Atoms.IScalar{System.DateTime},System.String)">
            <summary>
            A date formatted by using a format-string and <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>
            </summary>
            <param name="date">a date</param>
            <param name="format">a format pattern</param>
        </member>
        <member name="M:Yaapii.Atoms.Time.DateAsText.#ctor(System.DateTime,Yaapii.Atoms.IText)">
            <summary>
            A date formatted by using a format-string and <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>
            </summary>
            <param name="date">a date</param>
            <param name="format">a format pattern</param>
        </member>
        <member name="M:Yaapii.Atoms.Time.DateAsText.#ctor(Yaapii.Atoms.IScalar{System.DateTime},Yaapii.Atoms.IText)">
            <summary>
            A date formatted by using a format-string and <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>
            </summary>
            <param name="date">a date</param>
            <param name="format">a format pattern</param>
        </member>
        <member name="M:Yaapii.Atoms.Time.DateAsText.#ctor(Yaapii.Atoms.IScalar{System.DateTime},Yaapii.Atoms.IText,System.IFormatProvider)">
            <summary>
            A date formatted as <see cref="T:Yaapii.Atoms.IText"/> by using a <see cref="T:System.IFormatProvider"/>
            </summary>
            <param name="date">a date</param>
            <param name="format">a format pattern</param>
            <param name="provider">a format provider</param>
        </member>
        <member name="M:Yaapii.Atoms.Time.DateAsText.AsString">
            <summary>
            The formatted <see cref="T:System.DateTime"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Yaapii.Atoms.Time.DateAsText.Equals(Yaapii.Atoms.IText)">
            <summary>
            Equal to another <see cref="T:Yaapii.Atoms.IText"/>
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="T:Yaapii.Atoms.Time.DateOf">
            <summary>
            A date out of a text
            </summary>
        </member>
        <member name="M:Yaapii.Atoms.Time.DateOf.#ctor(System.String)">
            <summary>
            A date parsed using a using <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>
            </summary>
            <param name="date">the date as text</param>
        </member>
        <member name="M:Yaapii.Atoms.Time.DateOf.#ctor(System.String,System.String[])">
            <summary>
            A date parsed using a pattern and a formatprovider
            </summary>
            <param name="date">the date as text</param>
            <param name="patterns"></param>
        </member>
        <member name="M:Yaapii.Atoms.Time.DateOf.#ctor(System.String,System.IFormatProvider,System.String[])">
            <summary>
            A date parsed using a pattern and a formatprovider
            </summary>
            <param name="date">the date as text</param>
            <param name="patterns"></param>
            <param name="provider"></param>
        </member>
        <member name="M:Yaapii.Atoms.Time.DateOf.#ctor(Yaapii.Atoms.IText)">
            <summary>
            A parsed <see cref="T:System.DateTime"/>
            </summary>
            <param name="date">the date as text</param>
        </member>
        <member name="M:Yaapii.Atoms.Time.DateOf.#ctor(Yaapii.Atoms.IText,System.IFormatProvider)">
            <summary>
            A date parsed using a formatprovider
            </summary>
            <param name="date">the date as text</param>
            <param name="dateFormat">format provider</param>
        </member>
        <member name="M:Yaapii.Atoms.Time.DateOf.#ctor(Yaapii.Atoms.IScalar{System.DateTime})">
            <summary>
            A date
            </summary>
            <param name="date"></param>
        </member>
        <member name="M:Yaapii.Atoms.Time.DateOf.Value">
            <summary>
            The parsed Date
            </summary>
            <returns></returns>
        </member>
        <member name="T:IMapInput">
            <summary>
            Input to be attached to a dictionary.
            </summary>
        </member>
        <member name="M:IMapInput.Apply(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Apply the input to a dictionary.
            </summary>
            <param name="map">Map to update with this input</param>
            <returns>Updated dictionary</returns>
        </member>
        <member name="M:IMapInput.Self">
            <summary>
            Access the raw IDictInput.
            </summary>
            <returns>Itself as IDictInput.</returns>
        </member>
        <member name="T:IMapInput`1">
            <summary>
            Input to be attached to a dictionary.
            </summary>
        </member>
        <member name="M:IMapInput`1.Apply(System.Collections.Generic.IDictionary{System.String,`0})">
            <summary>
            Apply the input to a dictionary.
            </summary>
            <param name="dict"></param>
            <returns>Updated dictionary</returns>
        </member>
        <member name="M:IMapInput`1.Self">
            <summary>
            Access the raw IDictInput.
            </summary>
            <returns>Itself as IDictInput.</returns>
        </member>
        <member name="T:IMapInput`2">
            <summary>
            Input to be attached to a dictionary.
            </summary>
        </member>
        <member name="M:IMapInput`2.Apply(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Apply the input to a dictionary.
            </summary>
            <param name="dict"></param>
            <returns>Updated dictionary</returns>
        </member>
        <member name="M:IMapInput`2.Self">
            <summary>
            Access the raw IDictInput.
            </summary>
            <returns>Itself as IDictInput.</returns>
        </member>
        <member name="T:Zip">
            <summary>
            Zips all Files in a Directory
            </summary>
        </member>
        <member name="M:Zip.#ctor(System.String)">
            <summary>
            Zips all Files in a Directory
            </summary>
            <param name="path"> the directory with the files to zip</param>
        </member>
        <member name="M:Zip.Stream">
            <summary>
            The Zipped Files as a Stream
            </summary>
            <returns></returns>
        </member>
    </members>
</doc>
